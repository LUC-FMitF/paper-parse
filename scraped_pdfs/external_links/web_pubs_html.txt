Source URL: http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#paxos-commit
Final URL: https://lamport.azurewebsites.net/pubs/pubs.html#paxos-commit
================================================================================

An earlier version was rejected from POPL 2007. Based on the reviews I received and comments from Simon Peyton-Jones, I revised the paper and submitted it to TOPLAS, but it was again rejected. It may be possible to write a paper about PlusCal that would be considered publishable by the programming-language community. However, such a paper is not the one I want to write. For example, two of the three TOPLAS reviewers wanted the paper to contain a formal semantics--something that I would expect people interested in using PlusCal to find quite boring. (A formal TLA+ specification of the semantics is available on the Web.) I therefore decided to publish it as an invited paper in the ICTAC conference proceedings.
Chapter in Software Specification Methods: An Overview Using a Case Study , Henri Habrias and Marc Frappier, editors. Hermes, April 2006.
I was asked to write a chapter for this book, which consists of a collection of formal specifications of the same example system written in a multitude of different formalisms. The system is so simple that the specification should be trivial in any sensible formalism. I bothered writing the chapter because it seemed like a good idea to have TLA+ represented in the book, and because it wasn't much work since I was able to copy a lot from the Z specification in Jonathan Bowen's chapter and simply explain how and why the Z and TLA+ specifications differ. Bowen's chapter is available . Because the example is so simple and involves no concurrency, its TLA+ specification is neither interesting nor enlightening. However, my comments about the specification process may be of some interest.
Implementing Dataflow With Threads
Distributed Computing 21 , 3 (2008), 163-181. Also appeared as Microsoft Research Technical Report MSR-TR-2006-181 (December 2006)..
Copyright 2008 by Springer-Verlag.
In the summer of 2005, I was writing an algorithm in PlusCal [162] and essentially needed barrier synchronization as a primitive. The easiest way to do this in PlusCal was to write a little barrier synchronization algorithm. I used the simplest algorithm I could think of, in which each process maintains a single 3-valued variable--the Barrier 1 algorithm of this paper. The algorithm seemed quite nice, and I wondered if it was new. A Web search revealed that it was. (In 2008, Wim Hesselink informed me that he had discovered this algorithm in 2001, but he had "published" it only in course notes.) I was curious about what barrier synchronization algorithm was used inside the Windows operating system and how it compared with mine, so I asked Neill Clift. He and John Rector found that my algorithm outperformed the one inside Windows. Meanwhile, I showed my algorithm to Dahlia Malkhi, who suggested some variants, including the paper's Barrier 2 algorithm. By around 1980, I knew that the producer/consumer algorithm introduced in [23] should generalize to an arbitrary marked graph, but I never thought it important enough to bother working out the details. (Marked graphs, which specify dataflow computation, are described in the discussion of [142].) I realized that these new barrier synchronization algorithms should also be instances of that generalization. The fact that the barrier algorithms worked well on a real multiprocessor made the general algorithm seem more interesting. Further thought revealed that the good performance of these barrier algorithms was not an accident. They have optimal caching behavior, and that optimal behavior can be achieved in the general case. All this makes the general synchronization algorithm relevant for the coming generation of multicore processor chips.
Leslie Lamport: The Specification Language TLA+
In , 616-620.
Copyright 2008 by Springer-Verlag.
This is a "review" of a chapter by Stephan Merz in the same book. It is mainly a brief account of the history behind TLA and TLA+. It includes an interesting quote from Brannon Battson. (See [147].)
Computation and State Machines
Unpublished (February 2008).
I have long thought that computer science is about concepts, not languages. On a visit to the University of Lugano in 2006, the question arose of what that implied about how computer science should be taught. This is a first, tentative attempt at an answer.
A TLA+ Proof System (with Kaustuv Chaudhuri, Damien Doligez, and Stephan Merz)
Proceedings of the LPAR Workshops , CEUR Workshop Proceedings No.~418, 17-37 (2008).
This is a description of the TLA+ constructs for writing formal proofs, and a preliminary description of the TLA proof system. It includes an appendix with a formal semantics of TLA+ proofs.
The Mailbox Problem (with Marcos Aguilera and Eli Gafni)
Distributed Computing 23 , 2 (2010), 113-134. (A shorter version appeared in Proceedings of the 22nd International Symposium on Distributed Computing, (DISC 2008) , 1-15.).
Copyright 2010 by Springer-Verlag.
This paper addresses a little synchronization problem that I first thought about in the 1980s. When Gafni visited MSR Silicon valley in 2008, I proposed it to him and we began working on it. I thought the problem was unsolvable, but we began to suspect that there was a solution. Gafni had an idea for an algorithm, but instead of trying to understand the idea, I asked for an actual algorithm. We then went through a series of iterations in which Gafni would propose an algorithm, I'd code it in PlusCal (see [162]) and let the model checker find an error trace, which I would then give to him. (At some point, he learned enough PlusCal to do the coding himself, but he never installed the TLA+ tools and I continued to run the model checker.) This process stopped when Aguilera joined MSR and began collaborating with us. He turned Gafni's idea into an algorithm that the model checker approved of. Gafni and Aguilera came up with the impossibility results. Aguilera and I did most of the actual writing, which included working out the details of the proofs.
ACM SIGACT News Volume 40 , Issue 1 (March 2009), 58-62.
Idit Keidar invited me to submit a note to a distributed computing column in SIGACT News devoted to teaching concurrency. In an introduction, she wrote that my note "takes a step back from the details of where, what, and how, and makes a case for the high level goal of teaching students how to think clearly." What does it say about the state of computer science education that one must make a case for teaching how to think clearly?
Vertical Paxos and Primary-Backup Replication (with Dahlia Malkhi and Lidong Zhou)
Proceedings of the 28th Annual ACM Symposium on Principles of Distributed Computing, PODC 2009 , Srikanta Tirthapura and Lorenzo Alvisi, editors. ACM (2009), 312-313.
This paper came out of much discussion between Malkhi, Zhou, and myself about reconfiguration. Some day, what we did may result in a long paper about state-machine reconfiguration containing these results and others that have not yet been published. The ideas here are related to the original, unpublished version of [152].
Computer Science and State Machines
Concurrency, Compositionality, and Correctness (Essays in Honor of Willem-Paul de Roever). Dennis Dams, Ulrich Hannemann, and Martin Steffen editors. Lecture Notes in Computer Science, number 5930 (2010), 60-65.
This is the six-page version of [166]. I think it is also the first place I have mentioned the Whorfian syndrome in print. It is structured around a lovely simple example in which an important hardware protocol is derived from a trivial specification by substituting an expression for the specification's variable. This example is supporting evidence for the thesis of [169] that computation should be described with mathematics. (Substitution of an expression for a variable is an elementary operation of mathematics, but is meaningless in a programming language.)
Reconfiguring a State Machine (with Dahlia Malkhi and Lidong Zhou)
ACM SIGACT News Volume 41 , Issue 1 (March 2010)..
This paper describes several methods of reconfiguring a state machine. All but one of them can be fairly easily derived from the basic state-machine reconfiguration method presented in the Paxos paper [123]. We felt that it was worthwhile publishing them because few people seemed to understand the basic method. (The basic method has a parameter α that I took to be 3 in [123] because I stupidly thought that everyone would realize that the 3 could be any positive integer.) The one new algorithm, here called the "brick wall" method, is just sketched. It is described in detail in [173]. This paper was rejected by the 2008 PODC conference. Idit Keidar invited us to submit it as a tutorial to her distributed computing column in SIGACT News.
Stoppable Paxos (with Dahlia Malkhi and Lidong Zhou)
Unpublished (April 2009).
This paper contains a complete description and proof of the "brick wall" algorithm that was sketched in [172]. It was rejected from the 2008 DISC conference.
Temporal Logic: The Lesser of Three Evils
Unpublished (April 2010).
This paper was written for a symposium in memory of Amir Pnueli held at New York University in May of 2010. I liked and greatly respected Amir, and I made the mistake of writing a paper he would have enjoyed. This was a mistake because a memorial is not for the dead, but for the people who loved him. Those people found the paper unsuitable for a memorial, and I don't question their judgement. I hope enough time has passed so that people can now read the paper and see in it a small indication of my gratitude to Amir for what he did, as I would have expressed it to him.
Verifying Safety Properties With the TLA+ Proof System (with Kaustuv Chaudhuri et al.)
Fifth International Joint Conference on Automated Reasoning (IJCAR), Edinburgh, UK. (July 2010) 142-148.
This was essentially a progress report on the development of the TLAPS proof system. I believe it describes the state of the system, largely implemented by Chaudhuri, at the end of his post-doc position on the project.
Byzantizing Paxos by Refinement
Distributed Computing: 25th International Symposium: DISC 2011 , David Peleg, editor. Springer-Verlag (2011) 211-224.
The Castro-Liskov algorithm (Miguel Castro and Barbara Liskov, Practical Byzantine Fault Tolerance and Proactive Recovery , TOCS 20:4 [2002] 398-461) intuitively seems like a modification of Paxos [123] to handle Byzantine failures, using 3n+1 processes instead of 2n+1 to handle n failures. In 2003 I realized that a nice way to think about the algorithm is that 2n+1 non-faulty processes are trying to implement ordinary Paxos in the presence of n malicious processes--each good process not knowing which of the other processes are malicious. Although I mentioned the idea in lectures, I didn't work out the details. The development of TLAPS, the TLA+ proof system, inspired me to write formal TLA+ specifications of the two algorithms and a TLAPS-checked proof that the Castro-Liskov algorithm refines ordinary Paxos. This paper describes the results. The complete specifications and proof are available .
Leaderless Byzantine Paxos
Distributed Computing: 25th International Symposium: DISC 2011 , David Peleg, editor. Springer-Verlag (2011) 141-142.
This two-page note describes a simple idea that I had in 2005. I have found the Castro-Liskov algorithm and other "Byzantine Paxos" algorithms unsatisfactory because they use a leader and, for progress, they require detecting and removing a malicious leader. My idea was to eliminate the leader by using a synchronous Byzantine agreement algorithm to implement a virtual leader. The note is too short to discuss the practical details, but they seem to be straightforward.
Euclid Writes an Algorithm: A Fairytale
International Journal of Software and Informatics 5 , 1-2 (2011) Part 1, 7-20.
This was an invited paper for a festschrift in honor of Manfred Broy's 60th birthday. It's a whimsical introduction to TLA+, including proofs. Judged as literature, it's probably the best thing I have ever written.
How to Write a 21st Century Proof
Journal of Fixed Point Theory and Applications doi:10.1007/s11784-012-0071-6 (6 March 2012)..
Copyright 2012 by Springer-Verlag.
I was invited to give a talk at a celebration of the 80th birthday of Richard Palais. It was at a celebration of his 60th birthday that I first gave a talk about how to write a proof--a talk that led to [102]. So, I thought it would be fun to give the same talk, updated to reflect my 20 years of experience writing structured proofs. The talk was received much more calmly than my earlier one, and the mathematicians were open to considering that I might have something interesting to say about writing proofs. Perhaps in the last 20 years I have learned to be more persuasive, or perhaps the mathematicians in the audience had just grown older and calmer. In any case, they were still not ready to try changing how they write their own proofs. My experience preparing and giving the talk made me realize it was time for a new paper on the subject. This paper is built around a simple example--a lemma from Michael Spivak's calculus text. I tried to show how a mathematician can easily transform the proofs she now writes into structured proofs. The paper also briefly describes how formal structured proofs are written in TLA+, and an appendix contains a machine-checked proof of Spivak's lemma. While mathematicians will not write formal proofs in the foreseeable future, I argue that learning how to write them is a good way to learn how to write rigorous informal proofs.
TLA+ Proofs (with Denis Cousineau et al.)
Proceedings of the 18th International Symposium on Formal Methods (FM 2012) , Dimitra Giannakopoulou and Dominique Mery, editors. Springer-Verlag Lecture Notes in Computer Science, Volume 7436 (2012) 147-154.
This is a short paper describing TLAPS, the TLA+ proof system being developed at the Microsoft Research-INRIA Joint Centre.
Why We Should Build Software Like We Build Houses
Published on-line by Wired in January 2013, but no longer available on their site.
I was approached by an editor at Wired to write an article for them. After a great deal of discussion and rewriting, we finally came up with this compromise between what Wired wanted and what I was willing to sign my name to. The basic message of the piece is that, when programming, it's a good idea to think before you code. I was surprised when the posted comments revealed that this is a controversial statement. The version contained here is the latest one that I have and is probably what was published by Wired. I later expanded it to paper number [184].
Adaptive Register Allocation with a Linear Number of Registers (with Delporte-Gallet et al.)
Proceedings of the 27th International Symposium on Distributed Computing (DISC 2013) 269-283.
I had little to do with the algorithms in this paper. I was mainly responsible for writing them in PlusCal and getting a written.
Coalescing: Syntactic Abstraction for Reasoning in First-Order Modal Logics (with Damien Doligez et al.)
Proceedings of the Workshop on Automated Reasoning in Quantified Non-Classical Logics (ARNL 2014).
When using a theorem prover that reasons about a certain class of mathematical operators to reason about expressions containing a larger class of operators, we have to hide from the prover the operators it can't handle. For example, a prover for ordinary mathematics would (incorrectly) deduce that the TLA+ action formula (x = y) => (x' = y') is a tautology if it were to treat priming ( ' ) as an ordinary mathematical operator. We call this kind of hiding coalescing. This paper shows that coalescing is somewhat more subtle than one might think, and explains how to do it correctly in some important cases.
Who Builds a House without Drawing Blueprints?
Communications of the ACM 58 , 4 (April 2015), 38-41.
Discusses informal specification. It is an expanded version of [181].
The Computer Science of Concurrency: The Early Years
Communications of the ACM, June 2015 , Vol. 58 No. 6, Pages 71-76.
This is the written version of my Turing lecture, which I gave at the PODC conference in Paris in July, 2014.
Auxiliary Variables in TLA+ (with Stephan Merz)
Unpublished, arXiv paper 1703.05121 (May 2017).
Although most of the ideas were already well-established at the time, paper . There are three types of auxiliary variables, each with its own module. In addition to history variables that record the past and prophecy variables that predict the future, there are stuttering variables that add stuttering steps (steps that do nothing). Paper [92] used prophecy variables to add stuttering steps, but we have long known that it's better to use a separate kind of variable for that purpose. The auxiliary variables described in the paper can be defined semantically; they are not specific to the TLA+ language. We hope in a later paper to define them in a language-independent fashion, and to prove a completeness result similar to that of paper [92]. We believe that the new kind of prophecy variable is more powerful than the original one, and that completeness does not require the hypothesis of finite internal nondeterminism needed for the original prophecy variables.
If You�re Not Writing a Program, Don�t Use a Programming Language
Bulletin of EATCS (The European Association for Theoretical Computer Science) No. 125, June 2018.
In January, 2018 I was invited to contribute an article to the Distributed Computing column of the EATCS Bulletin. I replied that I had nothing to say on that subject to the EATCS community, and I offered instead to write something along the lines of [169]. That offer was accepted, and I wrote this article. It discusses in detail what I could only sketch in my earlier article: how to describe algorithms with mathematics.
Recursive Operator Definitions (with Georges Gonthier)
Inria Research Report No. 9341 , May 2020.
We can recursively define the cardinality of a finite set by defining the cardinality of the empty set to be 0 and the cardinality of any other finite set to be 1 plus the cardinality of the set obtained from it by removing one of its elements. Mathematicians will call cardinality a function, until you remind them that a function has a domain that must be a set, and the collection of all finite sets is not a set. Cardinality is not a function; I call it an operator. The TLA+ specification language originally allowed recursive function definitions; it did not allow recursive operator definitions because I didn't know how to define their semantics, and apparently no one else did either. To appreciate the problem, consider the recursive definition of an operator Op asserting, for any v , that Op(v) equals some value not equal to Op(v). (It's easy to write this definition in TLA+.) In 2005, I had an idea of how to define a semantics for recursive operator definitions, and Georges Gonthier converted my idea into a correct definition. In 2019 I decided that the definition should be documented, and I persuaded Georges to join me in writing this paper.
The TLA+ Toolbox (with Markus Kuppe and Daniel Ricketts)
Proceedings of the Fifth Workshop on Formal Integrated Development Environments (October 2019), pages 50-62.
The TLA+ Toolbox is an integrated development environment for the TLA+ tools. It was originally written by Simon Zambrovski under my supervision. Shortly thereafter, Daniel Ricketts added a nice interface for running the TLAPS prover from the Toolbox. In recent years, Markus Kuppe has been improving the Toolbox. Kuppe and I decided it was time to write a paper describing the most novel features of the Toolbox. Kuppe wrote almost all of the paper, and Ricketts and I edited what he had written.
Prophecy Made Simple (with Stephan Merz)
ACM Transactions on Programming Languages and Systems 44 , 2 (June 2022), 1-27. Published version [available here.
This paper provides what we hope is a simple explanation of the ideas in [186]. That paper contained an account of auxiliary variables that was buried under a mountain of details on how to use them in actual TLA+ specifications. Its most important contribution was a new kind of prophecy variable that is more powerful and much simpler to use than the original prophecy variable introduced in [92]. This paper explains auxiliary variables through a series of simple examples, concentrating on prophecy variables. In addition, it explains prophecy constants-an idea introduced by Hesselink in 2005-and sketches a completeness result. It assumes no prior knowledge of TLA or auxiliary variables.
Verifying Hyperproperties with TLA (with Fred B. Schneider)
To appear in the Proceedings of the 34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021.
At a workshop in Norway in 2018, I heard Fred Schneider give a talk about hyperproperties. An ordinary property is a predicate on system executions; a hyperproperty is a predicate on sets of executions. Hyperproperties have been used to express security conditions--usually ones that forbid information leaks. A system specification can be written as a TLA formula that is true just on possible executions of the system. When listening to Schneider's talk, it occurred to me that for a hyperproperty depending on only a finite number of executions, the assertion that a system satisfies the hyperproperty can can be written as a TLA formula containing multiple copies of the system's specification. Schneider and I spent part of the following two years figuring out how to make the idea work and writing this paper about it. We found that TLA and the TLA+ tools can in principle check if high-level system designs satisfy all the security hyperproperties we saw in the literature. However, TLA had to be used in a new way that was not needed for verifying ordinary properties. This paper won the USA National Security Agency's 2022 Annual Best Scientific Cybersecurity Paper Competition. TLA+ files (and their pretty-printed versions) containing the examples in the paper and their verifications are available .
Deconstructing the Bakery to Build a Distributed State Machine
Communications of the ACM 65 , 9 (September 2022), 58-66.
The paper begins with: "the reader and I will journey between two concurrent algorithms of the 1970s that are still studied today." The journey goes from .
Chapter 4 in Edsger Wybe Dijkstra: His Life, Work, and Legacy , edited by Krzysztof R. Apt and Tony Hoare. ACM Books, volume 45. ACM / Morgan Claypoo.
This is a chapter in a biography of Edsger Dijkstra--one of an ACM series of scientific biographies of Turing Award winners. The chapter is a survey of his concurrent algorithms. Writing it made me realize how great a computer scientist he was, and how much I learned from his work. Any study of concurrency should include these algorithms. I hope that the work done in the decades since Dijkstra invented the algorithms enabled me to make them and their significance easier to understand.
Making Math More Rigorous
Section 4 of Mathematical Proof Between Generations by Jonas Bayer et al. in Notices of the American Mathematical Society , Volume~71, No.~1 (January 2024).
I was invited along with nine other people to submit a section of the paper in the AMS Notices. The paper is mainly about the potential influence on mathematics of machine-checked proofs. I contributed this section essentially as an advertisement for papers [102] and [179]. I don't expect it to achieve anything, since I've given up trying to convince mathematicians to write structured proofs. That they make it harder to publish an incorrect result is too much of a disincentive. I apparently didn't pay too much attention to what I had written, because formulas (1) and (2) in the published version were egregiously wrong; I corrected them in this version.
Some Data on the Frequency of Errors in Mathematics Papers
Rejected by The American Mathematical Monthly and the Proceedings of the National Academy of Sciences (December 2023).
This paper reports that in a non-random selection of 84 papers published in one small field of mathematics, 1/3 of them contained serious errors. The data are meager, but a Web search indicates they are the only data on the subject. While the data proves nothing, it does strongly suggest that there are lots of errors in published mathematics paper. Since the frequency of such errors is an interesting topic, and this very short paper (less than one page in a journal format) presents the only data on this topic, I think that it's worth publishing. The reasons for rejection given by the editors and reviewers seemed reasonable. However, the reaction to my proposals in [102] and [179] for writing proofs taught me that mathematicians become irrational when I point out that the proofs they write are not the paradigms of logical rigor they pretend them to be. So, I am suspicious. I will let the reader decide whether this paper should have been rejected.
A Science of Concurrent Programs
To be published by Cambridge University Press.
This book explains the scientific principles underlying the TLA+ language and its use for specifying and reasoning about concurrent programs and systems. It contains a lot of math. All the math beyond high school algebra is explained, but it will be tough going for readers not familiar with the math taught in introductory university math classes for computer science students, which includes topics like sets and logic. The book contains little discussion of how TLA+ is used in practice, but it explains why TLA+ is what it is.