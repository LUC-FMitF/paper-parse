Source URL: https://members.loria.fr/SMerz/talks/argentina2005/Charpentier/charpov/Teaching/CS-986/TLC/
Final URL: https://members.loria.fr/SMerz/talks/argentina2005/Charpentier/charpov/Teaching/CS-986/TLC/
================================================================================

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Case Study in TLA+ / TLC</title>
  </head>

  <body>
    <h2>Case Study in TLA<sup>+</sup> / TLC</h2>

<img align="left" src="testNB03-small.png" vspace=5 hspace=30>
<p> As part of the course <a href="../index.html">CS-986:
Advanced Topics in Program Verification</a>, we (the students and
myself) used <a
href="http://research.microsoft.com/users/lamport/tla/tla.html"
target=_top>TLA+</a> to specify and verify properties of
several concurrent algorithms.  When it was possible (i.e., when
processes states were finite), we also used <a
href="http://research.microsoft.com/users/lamport/tla/tlc.html"
target=_top>TLC</a> to help us debug / verify our formal models.  One
of these cases seemed a good enough illustration of TLC to us to
possibly be of interest to other TLA<sup>+</sup> and/or TLC users.
This is the reason for this web page.

<p> The starting point is a paper on "<em>Non-blocking atomic commitment</em>"
by
Babaoglu and Toueg, from Mulender's book on <a
href="http://www.aw.com/catalog/academic/product/1,4096,0201624273,00.html"
target=_top>Distributed Systems</a>.  They
present an algorithm for distributed atomic commitment that enjoys
different sets of properties depending on what type of broadcast is
used.  They give an informal correctness proof which they claim is
compositional, although I'd rather call it incremental (when the algorithm
is modified, the proof is modified accordingly, some parts being
reused).

<p> I wanted to see how similar (or not) a TLA proof would be and,
possibly, attempt a true compositional proof later.  So, we have
modeled this algorithm in TLA<sup>+</sup>.  Although I'm still not
done with the proof, I've used TLC extensively on this specification,
and I think it can provide an interesting example of what the tool can
(and cannot) do.

<p> The original description assumes a reliable synchronous
communication model (transmission times are bounded), and relies on it
to detect faulty sites.  In order to simplify the model, we switched
to a reliable (implicit) asynchronous communication model where a site
can either receive a message from another site (if the message was
sent) or realize that this other site is down (if the message was not
sent).  We don't specify explicitly how this detection is achieved.

<p> A first TLA<sup>+</sup> module (<a href="index.html#ACP_SB">ACP_SB</a>)
implements the generic algorithm from the paper with a simple
broadcast (messages are simply sent successively).  It satisfies some
atomic commitment properties, but does not always terminate in the
presence of failure.

<p> Probably because we tried to separate safety and liveness concerns
as much as possible, we ended up with a set of properties that is a
bit stronger than the original.  (The original specification does not
force an abort decision if at least a vote is <em>No</em> and no failures
occur.  Ours does.)

<p> ACP_SB is then extended into an <a href="index.html#ACP_NB">ACP_NB</a>
module where the simple broadcast is replaced with a reliable
broadcast.  This reliable broadcast is achieved by having each
participant forward the decision it receives to all other
participants.  Thanks to this modification, the algorithm now always
terminates, even in the presence of failures.

<p> Interestingly enough, we made a mistake when we wrote this module
for the first time.  It's important that a decision is <em>not</em>
delivered locally <em>before</em> it has been forwarded to all other
participants.  If this happens (<a
href="index.html#ACP_NB_WRONG">ACP_NB_WRONG</a>), then the consistency property
(all decisions are the same) is violated.  We were careless, and TLC
provided us with a nice counterexample that helped realize our mistake
right away, before starting any proof.  The <a
href="ACP_NB_WRONG_TLC.result">output from TLC</a> builds a prefix of a
computation that falsifies invariant <tt>AC1</tt> (and it remains
reasonably readable).  The last state shows one process that
<em>aborts</em> while the other <em>commits</em>.

<p> Once the problem was corrected (<a href="index.html#ACP_NB">ACP_NB</a>), TLC
was able to verify the safety property of the algorithm for 4
participants and the liveness for 3 participants.  The verification of
safety for 4 participants took <a href="testNB03.png">9 days, 14 hours
and 25 minutes</a> on my desk machine.  Even though the machine was
used at other tasks at the same time, it confirms that TLC is to be
considered more as a debugger than a verification tool.  In its
debugging role, TLC was quite good.

<p> Here is the list of TLA<sup>+</sup> and TLC files that were used:
<dl>
  <dt><a name="ACP_SB"><strong>ACP_SB</strong></a></dt>
  <dd>
    <ul>
      <li><a href="ACP_SB.tla">TLA+ module</a>
      <li><a href="ACP_SB_TLC.tla">TLA+ module, TLC-ready</a>
      <li><a href="ACP_SB_TLC.cfg">TLC configuration file</a>
      <li><a href="ACP_SB.ps">PostScript</a>
      <li><a href="ACP_SB.pdf">pdf</a>
    </ul><p>
  <dt><a name="ACP_NB"><strong>ACP_NB</strong></a></dt>
  <dd>
    <ul>
      <li><a href="ACP_NB.tla">TLA+ module</a>
      <li><a href="ACP_NB_TLC.tla">TLA+ module, TLC-ready</a>
      <li><a href="ACP_NB_TLC.cfg">TLC configuration file</a>
      <li><a href="ACP_NB.ps">PostScript</a>
      <li><a href="ACP_NB.pdf">pdf</a>
    </ul><p>
  <dt><a name="ACP_NB_WRONG"><strong>ACP_NB_WRONG</strong></a></dt>
  <dd>
    <ul>
      <li><a href="ACP_NB_WRONG_TLC.tla">TLA+ module, TLC-ready</a>
      <li><a href="ACP_NB_WRONG_TLC.cfg">TLC configuration file</a>
      <li><a href="ACP_NB_WRONG_TLC.ps">PostScript</a>
      <li><a href="ACP_NB_WRONG_TLC.pdf">pdf</a>
    </ul>
</dl>

<p> Following are some other files that were used and that could be of
interest to someone:
<ul>
  <li>By default, TLC stores the graph of generated states in a
    subdirectory "<em>states</em>" of the current directory.  As this
    directory can be quite huge, this is
    inconvenient if TLA files are in your home directory, and that
    directory is on a small partition or possibly accessed through
    NFS.  TLC should offer a possibility to choose where to store
    those states, but until it does, I have added this option to TLC's
    command-line.  Here is the modified <a
    href="TLC.java">TLC.java</a>.  This is the only
    file that is modified (without any authorization from TLC's
    developers, I'm afraid).  When TLC is compiled with this file, it
    offers a &nbsp;&nbsp;&nbsp;<tt>-dir&nbsp;&lt;dirname&gt;</tt>&nbsp;&nbsp;&nbsp; option.  Everything works
    fine with TLC as of version 1.63 of Jan  4, 2002 (the modification
    is minor anyway).<p>

  <li>As I could never remember the capitalization and the options of
    TLA tools, I use <tt>bash</tt> functions to launch them:
    <pre>
# TLA tools
function tlatex () {
    java -showversion tlatex.TLA -shade \
         -textwidth 550 -textheight 725 -hoffset -100 -voffset -100 $*
}
function sany () {
    java -showversion tlasany.SANY $*
}
function tlc () {
    java -showversion -Xmx1024m tlatk.TLC -dir /var/tmp/states $*
}
function tlapdf () {
    tlatex -latexCommand pdflatex $*
}
</pre><p>
    <li> Here is the <tt>bash</tt> <a href="show">script</a> used to
      generate a curve of
      the number of states in queue from TLC's output, such as <a
      href="testNB03.png">this one</a>.  I find it convenient because
      the shape of the curve in the middle of a computation gives me
      a rough idea of the amount of time still required before
      completion.  The script is horrible, though, as it generates a
      temporary file with numbers from 5 to 50000, one by line.
      There must be a way to avoid that, but I don't know enough
      <tt>gnuplot</tt> for that.<p>
</ul>

<p> Naturally, comments on this case study and feedback on similar
experiments are welcome.  Drop me a line and let me know what you think...
    
    <hr>
    <address><a href="http://www.cs.unh.edu/~charpov/" target=_top>Michel Charpentier</a> &lt;<img src="../../../email.gif" align=center>&gt;</address>
<!-- Created: Tue Oct 10 16:54:17 EDT 2000 -->
<!-- hhmts start --> Last modified: Mon May  5 17:30:41 EDT 2003 <!-- hhmts end -->

  </body>
</html>

