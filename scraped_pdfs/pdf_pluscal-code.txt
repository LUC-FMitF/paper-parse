Source: pluscal-code.pdf
================================================================================

The PlusCal Code
for
Byzantizing Paxos by Refinement
Leslie Lamport
28 June 2011
Contents
1 Algorithm Consensus 1
2 Algorithm Voting 2
3 Algorithm PCon 5
4 Algorithm BPCon 9
References 13
ThisdocumentcontainsthePlusCalcodeofthefourspecificationsdescribed
in the paper Byzantizing Paxos by Refinement, which is available on the
Web [1]. Comments are indicated by a gray background. The code comes
from the TLA+ modules, which are available on the Web site. The algo-
rithms use some constants that are declared in the TLA+ modules, but the
meanings of those constants should be clear. The code was formatted by
hand, so errors could have been introduced.
1 Algorithm Consensus
Wespecifythesafetypropertyofconsensusasatrivialalgorithmthatdescribestheallowed
behaviors of a consensus algorithm. It uses the variable chosen to represent the set of
all chosen values. The algorithm allows only behaviors that contain a single state-change
in which the variable chosen is changed from its initial value {} to the value {v} for an
arbitrary value v in Value. The algorithm itself does not specify any fairness properties,
so it also allows a behavior in which chosen is not changed. We could use a translator
optiontohavethetranslationincludeafairnessrequirement,butwedon’tbotherbecause
itiseasyenoughtoadditbyhandtothesafetyspecificationthatthetranslatorproduces.
A real specification of consensus would also include additional variables and actions. In
particular,itwouldhaveProposeactionsinwhichclientsproposevaluesandLearn actions
in which clients learn what value has been chosen. It would allow only a proposed value
to be chosen. However, the interesting part of a consensus algorithm is the choosing of a
single value. We therefore restrict our attention to that aspect of consensus algorithms.
In practice, given the algorithm for choosing a value, it is obvious how to implement the
Propose and Learn actions.
For convenience, we define the macro Choose() that describes the action of changing the
value of chosen from {} to {v}, for a nondeterministically chosen v in the set Value.
(There is little reason to encapsulate such a simple action in a macro; however our other
algorithms are easier to read when written with such macros, so we start using them
now.) The when statement can be executed only when its condition, chosen = {}, is
true. Hence, at most one Choose() action can be performed in any execution. The with
statement executes its body for a nondeterministically chosen v in Value. Execution of
thisstatementisenabledonlyifValue isnon-empty–somethingwedonotassumeatthis
point because it is not required for the safety part of consensus, which is satisfied if no
value is chosen.
We put the Choose() action inside a while statement that loops forever. Of course, only
asingleChoose()actioncanbeexecuted. ThealgorithmstopsafterexecutingaChoose()
action. Technically, the algorithm deadlocks after executing a Choose() action because
controlisatastatementwhoseexecutionisneverenabled. Formally,terminationissimply
deadlock that we want to happen. We could just as well have omitted the while and let
thealgorithmterminate. However,addingthewhileloopmakestheTLA+representation
of the algorithm a tiny bit simpler.
--algorithm Consensus {
variable chosen = {};
macro Choose() { when chosen = {};
with (v ∈ Value) { chosen := {v} }
}
{ lbl: while (true){ Choose() }
}
}
1
2 Algorithm Voting
In the algorithm, each acceptor can cast one or more votes, where each vote cast by an
acceptorhastheform(cid:104)b,v(cid:105)indicatingthattheacceptorhasvotedforvaluev inballotb.
A value is chosen if a quorum of acceptors have voted for it in the same ballot.
The algorithm uses two variables, votes and maxBal, both arrays indexed by acceptor.
Their meanings are:
votes[a] The set of votes cast by acceptor a.
maxBal[a] Thenumberofthehighest-numberedballotinwhicha hascastavote,
or −1 if it has not yet voted.
The algorithm does not let acceptor a vote in any ballot less than maxBal[a].
We specify our algorithm by the following PlusCal code. The specification Spec defined
bythisalgorithmdescribesonlythesafetypropertiesofthealgorithm. Inotherwords,it
specifieswhatstepsthealgorithmmaytake. Itdoesnotrequirethatany(non-stuttering)
steps be taken. Liveness is discussed in the TLA+ specification.
--algorithm Voting {
variables votes = [a ∈ Acceptor (cid:55)→ {}],
maxBal = [a ∈ Acceptor (cid:55)→ −1];
define {
ThedefinesectionaddsTLA+ definitionsofoperatorsthatcanusethealgorithm’svari-
ables and can be used within the algorithm.
We now define the operator SafeAt so SafeAt(b,v) is a function of the state that equals
trueifnovalueotherthanv hasbeenchosenorcaneverbechoseninthefuture(because
the values of the variables votes and maxBal are such that the algorithm does not allow
enoughacceptorstovoteforit). Wesaythatvaluev issafeatballotnumberbiffSafe(b,v)
is true. We define Safe in terms of the following two operators.
Note: Thisdefinitionisweakerthanwouldbenecessarytoallowarefinementofordinary
Paxosconsensus,sinceitallowsdifferentquorumsto“cooperate”indeterminingsafetyat
b. ThisisusedinalgorithmslikeVerticalPaxosthataredesignedtoallowreconfiguration
within a single consensus instance, but not in ordinary Paxos. See [2].
We define SafeAt in terms of the following two operators.
VotedFor(a, b, v) =∆ (cid:104)b, v(cid:105) ∈ votes[a]
True iff acceptor a has voted for v in ballot b.
DidNotVoteIn(a, b) =∆ ∀v ∈ Value : ¬VotedFor(a, b, v)
We now define SafeAt. We define it recursively. The nicest definition is:
2
recursive SafeAt( , )
SafeAt(b, v) =∆
∨b = 0
∨∃Q ∈ Quorum :
∧∀a ∈ Q : maxBal[a] ≥ b
∧∃c ∈ −1 .. (b −1) :
∧(c (cid:54)= −1) ⇒ ∧SafeAt(c, v)
∧∀a ∈ Q :
∀w ∈ Value :
VotedFor(a, c, w) ⇒ (w = v)
∧∀d ∈ (c +1) .. (b −1), a ∈ Q : DidNotVoteIn(a, d)
However,TLAPSdoesnotcurrentlysupportrecursiveoperatordefinitions. Wethere-
fore define it as follows using a recursive function definition.
SafeAt(b, v) =∆
let SA[bb ∈ Ballot] =∆
This recursively defines SA[bb] to equal SafeAt(bb,v).
∨bb = 0
∨∃Q ∈ Quorum :
∧∀a ∈ Q : maxBal[a] ≥ bb
∧∃c ∈ −1 .. (bb −1) :
∧(c (cid:54)= −1) ⇒ ∧SA[c]
∧∀a ∈ Q :
∀w ∈ Value :
VotedFor(a, c, w) ⇒ (w = v)
∧∀d ∈ (c +1) .. (bb −1), a ∈ Q : DidNotVoteIn(a, d)
in SA[b]
}
There are two possible actions that an acceptor can perform, each defined by a macro.
In these macros, self is the acceptor that is to perform the action. The first action,
IncreaseMaxBal(b) allows acceptor self to set maxBal[self] to b if b is greater than the
current value of maxBal[self].
macro IncreaseMaxBal(b) {
when b > maxBal[self] ;
maxBal[self] := b
}
3
Action VoteFor(b,v) allows acceptor self to vote for value v in ballot b if its when
condition is satisfied.
macro VoteFor(b,v) {
when ∧ maxBal[self] ≤ b
∧ DidNotVoteIn(self,b)
∧ ∀p ∈ Acceptor\{self} :
∀w ∈ Value : VotedFor(p,b,w) ⇒ (w = v)
∧ SafeAt(b,v) ;
votes[self] := votes[self]∪{(cid:104)b,v(cid:105)} ;
maxBal[self] := b
}
The following process declaration asserts that every process self in the set Acceptor exe-
cutesitsbody,whichloopsforevernondeterministicallychoosingaBallotb andexecuting
either an IncreaseMaxBal(b) action or nondeterministically choosing a value v and exe-
cuting a VoteFor(b,v) action. The single label indicates that an entire execution of the
body of the while loop is performed as a single atomic action.
From this intuitive description of the process declaration, one might think that a process
couldbedeadlockedbychoosingaballotb inwhichneitheranIncreaseMaxBal(b)action
noranyVoteFor(b,v)actionisenabled. AnexaminationoftheTLA+translation(andan
elementary knowledge of the meaning of existential quantification) shows that this is not
thecase. Youcanthinkofallpossiblechoicesofbandofv beingexaminedsimultaneously,
and one of the choices for which a step is possible being made.
process (acceptor ∈ Acceptor) {
acc : while (true) {
with (b ∈ Ballot) {
either IncreaseMaxBal(b)
or with (v ∈ Value) { VoteFor(b,v) }
}
}
}
}
4
3 Algorithm PCon
The algorithm is easiestto understand in terms of the set msgs of all messages that have
ever been sent. A more accurate model would use one or more variables to represent the
messages actually in transit, and it would include actions representing message loss and
duplication as well as message receipt.
For our purposes, there is no need to model message loss explicitly. The safety part of
the spec says only what messages may be received and does not assert that any message
actually is received. Thus, there is no difference between a lost message and one that is
never received. The liveness property of the spec will make it clear what messages must
be received (and hence either not lost or successfully retransmitted if lost) to guarantee
progress.
Anotheradvantageofmaintainingthesetofallmessagesthathaveeverbeensentisthat
it allows us to define the state function votes that implements the variable of the same
name in the voting algorithm without having to introduce a history variable.
Inadditiontothevariablemsgs,thealgorithmusesfourvariableswhosevaluesarearrays
indexed by acceptor, where for any acceptor a:
maxBal[a] The largest ballot number in which a has participated
maxVBal[a] Thelargestballotnumberinwhicha hasvoted, or−1if ithasnever
voted.
maxVVal[a] If a has voted, then this is the value it voted for in ballot maxVBal;
otherwise it equals None.
Asinthevotingalgorithm,anexecutionofthealgorithmconsistsofanexecutionofzero
or more ballots. Different ballots may be in progress concurrently, and ballots may not
complete (and need not even start). A ballot b consists of the following actions (which
need not all occur in the indicated order).
Phase1a The leader sends a 1a message for ballot b.
Phase1b If maxBal[a] < b, an acceptor a responds to the 1a message by setting
maxBal[a] to b and sending a 1b message to the leader containing the
values of maxVBal[a] and maxVVal[a].
Phase1c When the leader has received ballot-b 1b messages from a quorum, it
determines some set of values that are safe at b and sends 1c messages
for them.
Phase2a The leader sends a 2a message for some value for which it has already
sent a ballot-b 1c message.
Phase2b Upon receipt of the 2a message, if maxBal[a] ≤ b, an acceptor a sets
maxBal[a] and maxVBal[a] to b, sets maxVVal[a] to the value in the 2a
message, and votes for that value in ballot b by sending the appropriate
2b message.
5
--algorithm PCon {
variables maxBal = [a ∈ Acceptor (cid:55)→ −1] ,
maxVBal = [a ∈ Acceptor (cid:55)→ −1] ,
maxVVal = [a ∈ Acceptor (cid:55)→ None] ,
msgs = {}
define {
sentMsgs(t, b) =∆ {m ∈ msgs : (m.type = t)∧(m.bal = b)}
WedefineShowsSafeAt sothatShowsSafeAt(Q,b,v)istrueforaquorumQ iffmsgs
contain ballot-b 1b messages from the acceptors in Q showing that v is safe at b.
ShowsSafeAt(Q, b, v) =∆
let Q1b =∆ {m ∈ sentMsgs(“1b”, b) : m.acc ∈ Q}
in ∧∀a ∈ Q : ∃m ∈ Q1b : m.acc = a
∧ ∨∀m ∈ Q1b : m.mbal = −1
∨∃m1c ∈ msgs :
∧m1c = [type (cid:55)→ “1c”, bal (cid:55)→ m1c.bal, val (cid:55)→ v]
∧∀m ∈ Q1b : ∧m1c.bal ≥ m.mbal
∧(m1c.bal = m.mbal) ⇒ (m.mval = v)
}
The Actions
As before, we describe each action as a macro. The leader for process self can execute a
Phase1a() action, which sends the ballot self 1a message.
macro Phase1a() { msgs := msgs ∪ {[type (cid:55)→ “1a”, bal (cid:55)→ self]} }
Acceptor self can perform a Phase1b(b) action, which is enabled iff b > maxBal[self].
The action sets maxBal[self] to b and sends a phase 1b message to the leader containing
the values of maxVBal[self] and maxVVal[self].
macro Phase1b(b) {
when (b > maxBal[self]) ∧ (sentMsgs(“1a”,b) (cid:54)= {}) ;
maxBal[self] := b ;
msgs := msgs ∪ {[type (cid:55)→ “1b”, acc (cid:55)→ self, bal (cid:55)→ b,
mbal (cid:55)→ maxVBal[self], mval (cid:55)→ maxVVal[self]]} ;
}
6
Theballotself leadercanperformaPhase1c(S)action,whichsendsasetS of1cmessages
indicating that the value in the val field of each of them is safe at ballot b. In practice,
S willeithercontainasinglemessage, orelsewillhaveamessageforeachpossiblevalue,
indicating that all values are safe. In the first case, the leader will immediately send a
2a message with the value contained in that single message. (Both logical messages will
be sent in the same physical message.) In the latter case, the leader is informing the
acceptors that all values are safe. (All those logical messages will, of course, be encoded
in a single physical message.)
macro Phase1c(S) {
when ∀v ∈ S : ∃Q ∈ Quorum : ShowsSafeAt(Q,self,v) ;
msgs := msgs ∪ {[type (cid:55)→ “1c”, bal (cid:55)→ self, val (cid:55)→ v] : v ∈ S }
}
The ballot self leader can perform a Phase2a(v) action, sending a 2a message for value
v, if it has not already sent a 2a message (for this ballot) and it has sent a ballot self 1c
message with val field v.
macro Phase2a(v) {
when ∧ sentMsgs(“2a”,self) = {}
∧ [type (cid:55)→ “1c”, bal (cid:55)→ self, val (cid:55)→ v] ∈ msgs ;
msgs := msgs ∪ {[type (cid:55)→ “2a”, bal (cid:55)→ self, val (cid:55)→ v]}
}
The Phase2b(b) action is executed by acceptor self in response to a ballot-b 2a message.
Notethisactioncanbeexecutedmultipletimesbytheacceptor,butafterthefirstone,all
subsequent executions are stuttering steps that do not change the value of any variable.
macro Phase2b(b) {
when b ≥ maxBal[self] ;
with (m ∈ sentMsgs(“2a”,b)) {
maxBal[self] := b ;
maxVBal[self] := b ;
maxVVal[self] := m.val ;
msgs := msgs ∪{[type (cid:55)→ “2b”, acc (cid:55)→ self, bal (cid:55)→ b, val (cid:55)→ m.val]}
}
}
7
An acceptor performs the body of its while loop as a single atomic action by nonde-
terministically choosing a ballot in which its Phase1b or Phase2b action is enabled and
executing that enabled action. If no such action is enabled, the acceptor does nothing.
process (acceptor ∈ Acceptor) {
acc: while (true) {
with (b ∈ Ballot) { either Phase1b(b) or Phase2b(b) }
}
}
Theleaderofaballotnondeterministicallychoosesoneofitsactionsthatisenabled(and
the argument for which it is enabled) and performs it atomically. It does nothing if none
of its actions is enabled.
process (leader ∈ Ballot) {
ldr: while (true) {
either Phase1a()
or with (S ∈ subset Value) { Phase1c(S) }
or with (v ∈ Value) { Phase2a(v) }
}
}
}
8
4 Algorithm BPCon
In the abstract algorithm BPCon, we do not specify how acceptors learn what 1b mes-
sages have been sent. We simply introduce a variable knowsSent such that knowsSent[a]
represents the set of 1b messages that (good) acceptor a knows have been sent, and have
an action that nondeterministically adds sent 1b messages to this set.
--algorithm BPCon {
The variables:
maxBal[a] The highest ballot in which acceptor a has participated.
maxVBal[a] The highest ballot in which acceptor a has cast a vote (sent a 2b
message), or −1 if it hasn’t cast a vote.
maxVVal[a] The value acceptor a has voted for in ballot maxVBal[a], or None
if maxVBal[a]=−1.
2avSent[a] A set of records in [val : Value, bal : Ballot] describing the 2av
messages that a has sent. A record is added to this set, and any
element with the same val field (and lower bal field) removed when
a sends a 2av message.
knownSent[a] The set of 1b messages that acceptor a knows have been sent.
bmsgs The set of all messages that have been sent. See the discussion of
themsgsvariableinmodulePConProoftounderstandourmodeling
of message passing.
variables maxBal = [a ∈ Acceptor (cid:55)→ −1] ,
maxVBal = [a ∈ Acceptor (cid:55)→ −1] ,
maxVVal = [a ∈ Acceptor (cid:55)→ None] ,
2avSent = [a ∈ Acceptor (cid:55)→ {}] ,
knowsSent = [a ∈ Acceptor (cid:55)→ {}] ,
bmsgs = {}
define {
sentMsgs(type, bal) =∆ {m ∈ bmsgs : m.type = type ∧m.bal = bal}
KnowsSafeAt(ac, b, v) =∆
True for an acceptor ac, ballot b, and value v iff the set of 1b messages in
knowsSent[ac] implies that value v is safe at ballot b in the Paxos consensus al-
gorithm being emulated by the good acceptors. To understand the definition, see
the definition of ShowsSafeAt in module PConProof and recall (a) the meaning of
themCBal andmCVal fieldsofa1b messageand(b)thatthesetofrealacceptors
in a ByzQuorum forms a quorum of the PCon algorithm.
9
let S =∆ {m ∈ knowsSent[ac] : m.bal = b}
in ∨∃BQ ∈ ByzQuorum :
∀a ∈ BQ : ∃m ∈ S : ∧m.acc = a
∧m.mbal = −1
∨∃c ∈ 0 .. (b −1) :
∧∃BQ ∈ ByzQuorum :
∀a ∈ BQ : ∃m ∈ S : ∧m.acc = a
∧m.mbal ≤ c
∧(m.mbal = c) ⇒ (m.mval = v)
∧∃WQ ∈ WeakQuorum :
∀a ∈ WQ :
∃m ∈ S : ∧m.acc = a
∧∃r ∈ m.m2av : ∧r.bal ≥ c
∧r.val = v
{
We now describe the processes’ actions as macros.
AsinthePaxosconsensusalgorithm,aballotself leader(goodormalicious)canexecute
a Phase1a action at any time.
macro Phase1a() {bmsgs := bmsgs ∪ {[type (cid:55)→ “1a”, bal (cid:55)→ self]} }
The acceptor’s Phase1b ation is similar to that of the PCon algorithm.
macro Phase1b(b) {
when (b > maxBal[self])∧(sentMsgs(“1a”,b) (cid:54)= {}) ;
maxBal[self] := b ;
bmsgs := bmsgs ∪ {[type (cid:55)→ “1b”, bal (cid:55)→ b, acc (cid:55)→ self, m2av (cid:55)→ 2avSent[self],
mbal (cid:55)→ maxVBal[self], mval (cid:55)→ maxVVal[self]]}
}
A good ballot self leader can send a phase 1c message for value v if it knows that the
messagesinknowsSent[a]foraQuorumof(good)acceptorsimplythattheyknowthatv
is safe at ballot self, and that they can convince any other acceptor that the appropriate
1b messages have been sent to that it will also know that v is safe at ballot self.
Amaliciousballotself leadercansendanyphase1c messagesitwants(includingonethat
a good leader could send). We prove safety with a Phase1c action that allows a leader
to be malicious. To prove liveness, we will have to assume a good leader that sends only
correct 1c messages.
AsinthePCon algorithm,weallowaPhase1c actiontosendasetofPhase1c messages.
(This is not done in the Castro-Liskov algorithm, but seems natural in light of the PCon
algorithm.)
10
macro Phase1c() {
with (S ∈ subset [type : {“1c”}, bal : self, val : Value]) {
bmsgs := bmsgs ∪S
}
}
If acceptor self receives a ballot b phase 1c message with value v, it relays v in a phase
2av message if
• it has not already sent a 2av message in this or a later ballot and
• the messages in knowsSent[self] show it that v is safe at b in the non-Byzantine
Paxos consensus algo- rithm being emulated.
macro Phase2av(b) {
when ∧ maxBal[self] =< b
∧ ∀r ∈ 2avSent[self] : r.bal < b ;
We could just as well have used r.bal (cid:54)=b in this condition.
with (m ∈ {ms ∈ sentMsgs(“1c”,b) : KnowsSafeAt(self,b,ms.val)} ) {
bmsgs := bmsgs ∪ {[type (cid:55)→ “2av”, bal (cid:55)→ b, val (cid:55)→ m.val, acc (cid:55)→ self]};
2avSent[self] := {r ∈ 2avSent[self] : r.val (cid:54)= m.val} ∪ {[val (cid:55)→ m.val, bal (cid:55)→ b]}
} ;
maxBal[self] := b
}
Acceptor self can send a phase 2b message with value v if it has received phase 2av
messagesfromaByzantinequorum,whichimpliesthataquorumofgoodacceptorsassert
that this is the first 1c message sent by the leader and that the leader was allowed to
send that message. It sets maxBal[self], maxVBal[self], and maxVVal[self] as in the
non-Byzantine algorithm.
macro Phase2b(b) {
when maxBal[self] =< b ;
with (v ∈ {vv ∈ Value :
∃Q ∈ ByzQuorum :
∀aa ∈ Q :
∃m ∈ sentMsgs(“2av”,b) : ∧ m.val = vv
∧ m.acc = aa} ) {
bmsgs := bmsgs ∪ {[type (cid:55)→ “2b”, acc (cid:55)→ self, bal (cid:55)→ b, val (cid:55)→ v]} ;
maxVVal[self] := v
} ;
maxBal[self] := b ;
11
maxVBal[self] := b
}
At any time, an acceptor can learn that some set of 1b messages were sent (but only if
they atually were sent).
macro LearnsSent(b) {
with (S ∈ subset sentMsgs(“1b”,b)) { knowsSent[self] := knowsSent[self]∪S }
}
A malicious acceptor self can send any acceptor message indicating that it is from itself.
Sinceamaliciousacceptorcouldallowothermaliciousprocessestoforgeitsmessages,this
action could represent the sending of the message by any malicious process.
macro FakingAcceptor() {
with (m ∈ {mm ∈ 1bMessage ∪2avMessage ∪2bMessage : mm.acc = self}) {
bmsgs := bmsgs ∪{m}
}
}
We combine these individual actions into a complete algorithm in the usual way, with
separate process declarations for the acceptor, leader, and fake acceptor processes.
process (acceptor ∈ Acceptor){
acc: while (true) {
with (b ∈ Ballot) {
either Phase1b(b) or Phase2av(b) or Phase2b(b) or LearnsSent(b)
}
}
}
process (leader ∈ Ballot) {
ldr: while (true) { either Phase1a() or Phase1c() }
}
process (facceptor ∈ FakeAcceptor) {
facc: while (true) {FakingAcceptor() }
}
}
12
References
[1] Leslie Lamport. Mechanically checked safety proof of a byzantine paxos
algorithm. URL http://research.microsoft.com/users/lamport
/tla/byzpaxos.html. The page can also be found by searching the
Web for the 23-letter string obtained by removing the “-” from
uid-lamportbyzpaxosproof.
[2] Leslie Lamport, Dahlia Malkhi, and Lidong Zhou. Vertical paxos and
primary-backup replication. In Srikanta Tirthapura and Lorenzo Alvisi,
editors, Proceedings of the 28th Annual ACM Symposium on Principles
of Distributed Computing, PODC 2009, pages 312–313. ACM, 2009.
13