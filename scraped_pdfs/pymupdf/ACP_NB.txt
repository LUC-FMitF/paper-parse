
--- Page 1 ---
module ACP NB
Time-stamp: < 10 Jun 2002 at 14:06:57 by charpov on berlioz.cs.unh.edu >
Non blocking Atomic Committment Protocol (ACP-NB)
The non blocking property AC5 is obtained by using a reliable broadcast
implemented as follows:
- upon reception of a broadcast message, this message is forwarded to all
participants before it’s delivered to the local site;
- since participant i does not forward to itself, forward[i] is used to
store the decision before it’s delivered (and becomes “decision”)
extends ACP SB
Participants type is extended with a “forward” variable.
Coordinator type is unchanged.
TypeInvParticipantNB
∆= participant ∈[
participants →[
vote
: {yes, no},
alive
: boolean ,
decision
: {undecided, commit, abort},
faulty
: boolean ,
voteSent : boolean ,
forward
: [participants →{notsent, commit, abort}]
]
]
TypeInvNB
∆= TypeInvParticipantNB ∧TypeInvCoordinator
Initially, participants have not forwarded anything yet
InitParticipantNB
∆= participant ∈[
participants →[
vote
: {yes, no},
alive
: {true},
decision : {undecided},
faulty
: {false},
voteSent : {false},
forward : [participants →{notsent}]
]
]
InitNB
∆= InitParticipantNB ∧InitCoordinator
Participant statements that realize a better broadcast
forward(i, j): forwarding of the predecision from participant i to participant j
if
particpant i is alive
participant i has received a decision (stored in forward[i])
participant i has not yet forwarded this decision to participant j
then
participant i forwards the decision to participant j
forward(i, j)
∆= ∧i ̸= j
∧participant[i].alive
∧participant[i].forward[i] ̸= notsent
∧participant[i].forward[j] = notsent
∧participant′ = [participant except ![i] =
1

--- Page 2 ---
[@ except !.forward =
[@ except ![j] = participant[i].forward[i]]
]
]
∧unchanged ⟨coordinator⟩
preDecideOnForward(i, j): participant i receives decision from participant j
if
participant i is alive
participant i has yet to receive a decision
participant j has forwarded its decision to participant i
then
participant i (pre)decides in accordance with participant j’s decision
preDecideOnForward(i, j)
∆= ∧i ̸= j
∧participant[i].alive
∧participant[i].forward[i] = notsent
∧participant[j].forward[i] ̸= notsent
∧participant′ = [participant except ![i] =
[@ except !.forward =
[@ except ![i] = participant[j].forward[i]]
]
]
∧unchanged ⟨coordinator⟩
preDecide(i): participant i receives decision from coordinator
if
participant i is alive
participant i has yet to receive a decision
coordinator has sent its decision to participant i
then
participant i (pre)decides in accordance with coordinator’s decision
preDecide(i)
∆= ∧participant[i].alive
∧participant[i].forward[i] = notsent
∧coordinator.broadcast[i] ̸= notsent
∧participant′ = [participant except ![i] =
[@ except !.forward =
[@ except ![i] = coordinator.broadcast[i]]
]
]
∧unchanged ⟨coordinator⟩
decideNB(i): Actual decision, after predecision has been forwarded
if
participant i is alive
participant i has forwarded its (pre)decision to all other participants
then
participant i decides in accordance with it’s predecision
decideNB(i)
∆= ∧participant[i].alive
∧∀j ∈participants : participant[i].forward[j] ̸= notsent
∧participant′ = [participant except ![i] =
[@ except !.decision = participant[i].forward[i]]
]
∧unchanged ⟨coordinator⟩
abortOnTimeout(i): conditions for a timeout are simulated
if
participant is alive and undecided and coordinator is not alive
2

--- Page 3 ---
coordinator died before sending decision to all participants who are alive
all dead participants died before forwarding decision to a participant who is alive
then
decide abort
abortOnTimeout(i)
∆= ∧participant[i].alive
∧participant[i].decision = undecided
∧¬coordinator.alive
∧∀j ∈participants : participant[j].alive ⇒coordinator.broadcast[j] = notsent
∧∀j, k ∈participants : ¬participant[j].alive ∧participant[k].alive ⇒participant[j].forward[k] = notsent
∧participant′ = [participant except ![i] = [@ except !.decision = abort]]
∧unchanged ⟨coordinator⟩
FOR N PARTICIPANTS
parProgNB(i, j)
∆= ∨sendVote(i)
∨abortOnVote(i)
∨abortOnTimeoutRequest(i)
∨forward(i, j)
∨preDecideOnForward(i, j)
∨abortOnTimeout(i)
∨preDecide(i)
∨decideNB(i)
parProgNNB
∆= ∃i, j ∈participants : parDie(i) ∨parProgNB(i, j)
progNNB
∆= parProgNNB ∨coordProgN
fairnessNB
∆= ∧∀i ∈participants : WF⟨coordinator, participant⟩(∃j ∈participants : parProgNB(i, j))
∧WF⟨coordinator, participant⟩(coordProgB)
SpecNB
∆= InitNB ∧2[progNNB]⟨coordinator, participant⟩∧fairnessNB
(SOME) INVALID PROPERTIES
AllCommit
∆= ∀i ∈participants : 3(participant[i].decision = commit ∨participant[i].faulty)
AllAbort
∆= ∀i ∈participants : 3(participant[i].decision = abort
∨participant[i].faulty)
AllCommitYesVotes
∆= ∀i ∈participants :
∀j ∈participants : participant[j].vote = yes
; participant[i].decision = commit ∨participant[i].faulty ∨coordinator.faulty
3
