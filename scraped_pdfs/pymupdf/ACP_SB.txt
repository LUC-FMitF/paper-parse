
--- Page 1 ---
module ACP SB
Time-stamp: < 10 Jun 2002 at 12:39:50 by charpov on berlioz.cs.unh.edu >
Atomic Committment Protocol with Simple Broadcast primitive (ACP-SB)
From:
Sape Mullender , editor. Distributed Systems.
Chapter 6: Non-Blocking Atomic Commitment, by ¨O. Babao˘glu and S. Toueg.
1993.
Synchronous communication has been replaced with (implicit) asynchronous communication. Failures are detected “magically” instead or relying on
timeouts.
This version of the protocol uses a “simple broadcast” where a broadcast is simply a series of messages sent, possibly interrupted by a failure.
Consequently, this algorithm is “non terminating” and property AC5 does not hold.
constants
participants,
set of participants
yes, no,
vote
undecided, commit, abort,
decision
waiting,
coordinator state wrt a participant
notsent
broadcast state wrt a participant
variables
participant,
participants (N)
coordinator
coordinator (1)
TypeInvParticipant
∆= participant ∈[
participants →[
vote
: {yes, no},
alive
: boolean ,
decision
: {undecided, commit, abort},
faulty
: boolean ,
voteSent : boolean
]
]
TypeInvCoordinator
∆= coordinator ∈[
request
: [participants →boolean ],
vote
: [participants →{waiting, yes, no}],
broadcast : [participants →{commit, abort, notsent}],
decision
: {commit, abort, undecided},
alive
: boolean ,
faulty
: boolean
]
TypeInv
∆= TypeInvParticipant ∧TypeInvCoordinator
Initially:
All the participants:
have a yes/no vote
are alive and not faulty
have not sent in their votes yet
are undecided about ﬁnal decision
The coordinator:
has not sent vote requests yet
has not recieved votes from any participant
is alive and not faulty
has not sent broadcast messages to any participant
is undecided about ﬁnal decision
1

--- Page 2 ---
InitParticipant
∆= participant ∈[
participants →[
vote
: {yes, no},
alive
: {true},
decision : {undecided},
faulty
: {false},
voteSent : {false}
]
]
InitCoordinator
∆= coordinator ∈[
request
: [participants →{false}],
vote
: [participants →{waiting}],
alive
: {true},
broadcast : [participants →{notsent}],
decision
: {undecided},
faulty
: {false}
]
Init
∆= InitParticipant ∧InitCoordinator
COORDINATOR STATEMENTS
request(i):
if
coordinator is alive
request for vote has not been sent to participant i
then
request for vote is sent to participant i
request(i)
∆= ∧coordinator.alive
∧¬coordinator.request[i]
∧coordinator ′ = [coordinator except !.request =
[@ except ![i] = true]
]
∧unchanged ⟨participant⟩
getVote(i):
if
coordinator is alive
coordinator is still undecided
coordinator has sent request for votes to all participants
coordinator is waiting to receive a vote from participant i
participant i has sent the vote message
then
the coordinator can record the vote of participant i
getVote(i)
∆= ∧coordinator.alive
∧coordinator.decision = undecided
∧∀j ∈participants : coordinator.request[j]
∧coordinator.vote[i] = waiting
∧participant[i].voteSent
∧coordinator ′ = [coordinator except !.vote =
[@ except ![i] = participant[i].vote]
]
∧unchanged ⟨participant⟩
detectFault(i):
if
coordinator is alive
2

--- Page 3 ---
coordinator is still undecided
coordinator has sent request for votes to all participants
coordinator is waiting for vote from participant i
participant i has died without sending its vote
then
coordinator times out on participant i and decides to abort
detectFault(i)
∆= ∧coordinator.alive
∧coordinator.decision = undecided
∧∀j ∈participants : coordinator.request[j]
∧coordinator.vote[i] = waiting
∧¬participant[i].alive
∧¬participant[i].voteSent
∧coordinator ′ = [coordinator except !.decision = abort]
∧unchanged ⟨participant⟩
makeDecision:
if
coordinator is alive
coordinator is undecided
coordinator has received votes from all participants
then
if
all votes are yes
then
coordinator decides commit
else
coordinator decides abort
makeDecision
∆= ∧coordinator.alive
∧coordinator.decision = undecided
∧∀j ∈participants : coordinator.vote[j] ∈{yes, no}
∧∨∧∀j ∈participants : coordinator.vote[j] = yes
∧coordinator ′ = [coordinator except !.decision = commit]
∨∧∃j ∈participants : coordinator.vote[j] = no
∧coordinator ′ = [coordinator except !.decision = abort]
∧unchanged ⟨participant⟩
coordBroadcast(i) (simple broadcast):
if
coordinator is alive
coordinator has made a decision
coordinator has not sent the decision to participant i
then
coordinator sends its decision to participant i
coordBroadcast(i)
∆= ∧coordinator.alive
∧coordinator.decision ̸= undecided
∧coordinator.broadcast[i] = notsent
∧coordinator ′ = [coordinator except !.broadcast =
[@ except ![i] = coordinator.decision]
]
∧unchanged ⟨participant⟩
coordDie:
if
coordinator is alive
then
coordinator dies
coordinator is now faulty
3

--- Page 4 ---
coordDie
∆= ∧coordinator.alive
∧coordinator ′ = [coordinator except !.alive = false, !.faulty = true]
∧unchanged ⟨participant⟩
PARTICIPANT STATEMENTS
sendVote(i):
if
participant is alive
participant has received a request for vote
then
participant sends vote
sendVote(i)
∆= ∧participant[i].alive
∧coordinator.request[i]
∧participant′ = [participant except ![i] =
[@ except !.voteSent = true]
]
∧unchanged ⟨coordinator⟩
abortOnVote(i):
if
participant is alive
participant is undecided
participant has sent its vote to the coordinator
participant’s vote is no
then
participant decides (unilaterally) to abort
abortOnVote(i)
∆= ∧participant[i].alive
∧participant[i].decision = undecided
∧participant[i].voteSent
∧participant[i].vote = no
∧participant′ = [participant except ![i] =
[@ except !.decision = abort]
]
∧unchanged ⟨coordinator⟩
abortOnTimeoutRequest(i):
if
participant is alive
participant is still undecided
coordinator has died without sending request for vote
then
participant decides (unilaterally) to abort
abortOnTimeoutRequest(i)
∆= ∧participant[i].alive
∧participant[i].decision = undecided
∧¬coordinator.alive
∧¬coordinator.request[i]
∧participant′ = [participant except ![i] =
[@ except !.decision = abort]
]
∧unchanged ⟨coordinator⟩
decide(i):
if
participant is alive
participant is undecided
4

--- Page 5 ---
participant has recieved decision from the coordinator
then
participant decides according to decision from coordinator
decide(i)
∆= ∧participant[i].alive
∧participant[i].decision = undecided
∧coordinator.broadcast[i] ̸= notsent
∧participant′ = [participant except ![i] =
[@ except !.decision = coordinator.broadcast[i]]
]
∧unchanged ⟨coordinator⟩
parDie(i):
if
participant is alive
then
participant dies and is now faulty
parDie(i)
∆= ∧participant[i].alive
∧participant′ = [participant except ![i] =
[@ except !.alive = false, !.faulty = true]
]
∧unchanged ⟨coordinator⟩
FOR N PARTICIPANTS
parProg(i)
∆= sendVote(i) ∨abortOnVote(i) ∨abortOnTimeoutRequest(i) ∨decide(i)
parProgN
∆= ∃i ∈participants : parDie(i) ∨parProg(i)
coordProgA(i)
∆=
request(i) ∨getVote(i) ∨detectFault(i) ∨coordBroadcast(i)
coordProgB
∆= makeDecision ∨∃i ∈participants : coordProgA(i)
coordProgN
∆= coordDie ∨coordProgB
progN
∆= parProgN ∨coordProgN
Death transitions are left outside of fairness
fairness
∆= ∧∀i ∈participants : WF⟨coordinator, participant⟩(parProg(i))
∧WF⟨coordinator, participant⟩(coordProgB)
Spec
∆= Init ∧2[progN ]⟨coordinator, participant⟩∧fairness
CORRECTNESS SPECIFICATION
This speciﬁcation follows the original paper, except that AC3 is stronger: It forces participants to abort if one vote at least is NO (in the absence of
failure).
The speciﬁcation is split between safety and liveness.
SAFETY
All participants that decide reach the same decision
AC1
∆= 2∀i, j ∈participants :
∨participant[i].decision ̸= commit
∨participant[j].decision ̸= abort
5

--- Page 6 ---
If any participant decides commit, then all participants must have votes YES
AC2
∆= 2( (∃i
∈participants : participant[i].decision = commit)
⇒(∀j ∈participants : participant[j].vote = yes))
If any participant decides abort, then:
at least one participant voted NO, or
at least one participant is faulty, or
coordinator is faulty
AC3 1
∆= 2( (∃i ∈participants : participant[i].decision = abort)
⇒∨(∃j ∈participants : participant[j].vote = no)
∨(∃j ∈participants : participant[j].faulty)
∨coordinator.faulty)
Each participant decides at most once
AC4
∆= 2 ∧(∀i ∈participants : participant[i].decision = commit
⇒2(participant[i].decision = commit))
∧(∀j ∈participants : participant[j].decision = abort
⇒2(participant[j].decision = abort))
LIVENESS
(stronger for AC3 than in the original paper)
AC3 2
∆= 3 ∨∀i ∈participants : participant[i].decision ∈{abort, commit}
∨∃j ∈participants : participant[j].faulty
∨coordinator.faulty
(SOME) INTERMEDIATE PROPERTIES USED IN PROOFS
FaultyStable
∆= ∧∀i ∈participants : 2(participant[i].faulty ⇒2participant[i].faulty)
∧2(coordinator.faulty ⇒2coordinator.faulty)
VoteStable
∆= ∀i ∈participants :
∨2(participant[i].vote = yes)
∨2(participant[i].vote = no)
StrongerAC2
∆= 2( (∃i ∈participants : participant[i].decision = commit)
⇒∧(∀j ∈participants : participant[j].vote = yes)
∧coordinator.decision = commit)
StrongerAC3 1
∆= 2( (∃i ∈participants : participant[i].decision = abort)
⇒∨(∃j ∈participants : participant[j].vote = no)
∨∧∃j ∈participants : participant[j].faulty
∧coordinator.decision = abort
∨∧coordinator.faulty
∧coordinator.decision = undecided)
(AC1 follows from StrongerAC2 ∧StrongerAC3 1)
NoRecovery
∆= 2 ∧∀i ∈participants : participant[i].alive ≡¬participant[i].faulty
∧coordinator.alive ≡¬coordinator.faulty
(SOME) INVALID PROPERTIES
DecisionReachedNoFault
∆= (∀i ∈participants : participant[i].alive)
; (∀k ∈participants : participant[k].decision ̸= undecided)
AbortImpliesNoVote
∆= 2( (∃i ∈participants : participant[i].decision = abort)
⇒(∃j ∈participants : participant[j].vote = no))
The following is the termination property that this SB algorithm doesn’t have
6

--- Page 7 ---
AC5
∆= 3∀i ∈participants : ∨participant[i].decision ∈{abort, commit}
∨participant[i].faulty
7
