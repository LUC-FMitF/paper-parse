
--- Page 1 ---
module BPConProof
This module speciﬁes a Byzantine Paxos algorithm–a version of Paxos in which failed acceptors
and leaders can be malicious. It is an abstraction and generalization of the Castro-Liskov algorithm
in
author = “Miguel Castro and Barbara Liskov”, title = “Practical byzantine fault tolerance
and proactive
recovery”,
journal = ACM Transactions on Computer Systems,
volume = 20,
number = 4, year = 2002, pages = “398–461”
extends Integers, FiniteSets, FiniteSetTheorems, TLAPS
The sets Value and Ballot are the same as in the Voting and PConProof specs.
constant Value
Ballot
∆= Nat
As in module PConProof , we deﬁne None to be an unspeciﬁed value that is not an element of
Value.
None
∆= choose v : v /∈Value
We pretend that which acceptors are good and which are malicious is speciﬁed in advance. Of
course, the algorithm executed by the good acceptors makes no use of which acceptors are which.
Hence, we can think of the sets of good and malicious acceptors as “prophecy constants” that are
used only for showing that the algorithm implements the PCon algorithm.
We can assume that a maximal set of acceptors are bad, since a bad acceptor is allowed to do
anything–including acting like a good one.
The basic idea is that the good acceptors try to execute the Paxos consensus algorithm, while the
bad acceptors may try to prevent them.
We do not distinguish between faulty and non-faulty leaders. Safety must be preserved even if
all leaders are malicious, so we allow any leader to send any syntactically correct message at any
time. (In an implementation, syntactically incorrect messages are simply ignored by non-faulty
acceptors and have no eﬀect.) Assumptions about leader behavior are required only for liveness.
constants Acceptor,
The set of good (non-faulty) acceptors.
FakeAcceptor,
The set of possibly malicious (faulty) acceptors.
ByzQuorum,
A Byzantine quorum is set of acceptors that includes a quorum of good ones. In
the case that there are 2f +1 good acceptors and f bad ones, a Byzantine quorum
is any set of 2f +1 acceptors.
WeakQuorum
A weak quorum is a set of acceptors that includes at least one good one. If there
are f bad acceptors, then a weak quorum is any set of f+1 acceptors.
We deﬁne ByzAcceptor to be the set of all real or fake acceptors.
ByzAcceptor
∆= Acceptor ∪FakeAcceptor
1

--- Page 2 ---
As in the Paxos consensus algorithm, we assume that the set of ballot numbers and −1 is disjoint
from the set of all (real and fake) acceptors.
assume BallotAssump
∆= (Ballot ∪{ −1}) ∩ByzAcceptor = {}
The following are the assumptions about acceptors and quorums that are needed to ensure safety
of our algorithm.
assume BQA
∆=
∧Acceptor ∩FakeAcceptor = {}
∧∀Q ∈ByzQuorum : Q ⊆ByzAcceptor
∧∀Q1, Q2 ∈ByzQuorum : Q1 ∩Q2 ∩Acceptor ̸= {}
∧∀Q ∈WeakQuorum : ∧Q ⊆ByzAcceptor
∧Q ∩Acceptor ̸= {}
The following assumption is not needed for safety, but it will be needed to ensure liveness.
assume BQLA
∆=
∧∃Q ∈ByzQuorum : Q ⊆Acceptor
∧∃Q ∈WeakQuorum : Q ⊆Acceptor
We now deﬁne the set BMessage of all possible messages.
1aMessage
∆= [type : {“1a”}, bal : Ballot]
Type 1a messages are the same as in module PConProof .
1bMessage
∆=
A 1b message serves the same function as a 1b message in ordinary Paxos, where the mbal
and mval components correspond to the mbal and mval components in the 1b messages of
PConProof . The m2av component is set containing all records with val and bal components
equal to the corresponding of components of a 2av message that the acceptor has sent, except
containing for each val only the record corresponding to the 2av message with the highest bal
component.
[type
: {“1b”}, bal : Ballot,
mbal : Ballot ∪{ −1}, mval : Value ∪{None},
m2av : subset [val : Value, bal : Ballot],
acc : ByzAcceptor]
1cMessage
∆=
Type 1c messages are the same as in PConProof .
[type : {“1c”}, bal : Ballot, val : Value]
2avMessage
∆=
When an acceptor receives a 1c message, it relays that message’s contents to the other acceptors
in a 2av message. It does this only for the ﬁrst 1c message it receives for that ballot; it can
receive a second 1c message only if the leader is malicious, in which case it ignores that second
1c message.
[type : {“2av”}, bal : Ballot, val : Value, acc : ByzAcceptor]
2bMessage
∆= [type : {“2b”}, acc : ByzAcceptor, bal : Ballot, val : Value]
2b messages are the same as in ordinary Paxos.
2

--- Page 3 ---
BMessage
∆=
1aMessage ∪1bMessage ∪1cMessage ∪2avMessage ∪2bMessage
We will need the following simple fact about these sets of messages.
lemma BMessageLemma
∆=
∀m ∈BMessage :
∧(m ∈1aMessage) ≡(m.type = “1a”)
∧(m ∈1bMessage) ≡(m.type = “1b”)
∧(m ∈1cMessage) ≡(m.type = “1c”)
∧(m ∈2avMessage) ≡(m.type = “2av”)
∧(m ∈2bMessage) ≡(m.type = “2b”)
⟨1⟩1. ∧∀m ∈1aMessage : m.type = “1a”
∧∀m ∈1bMessage : m.type = “1b”
∧∀m ∈1cMessage : m.type = “1c”
∧∀m ∈2avMessage : m.type = “2av”
∧∀m ∈2bMessage : m.type = “2b”
by def 1aMessage, 1bMessage, 1cMessage, 2avMessage, 2bMessage
⟨1⟩2. qed
by ⟨1⟩1 def BMessage
***************************************************************************
We now give the algorithm. The basic idea is that the set Acceptor of real acceptors emulate an
execution of the PCon algorithm with Acceptor as its set of acceptors. Of course, they must do
that without knowing which of the other processes in ByzAcceptor are real acceptors and which
are fake acceptors. In addition, they don’t know whether a leader is behaving according to the
PCon algorithm or if it is malicious.
The main idea of the algorithm is that, before performing an action of the PCon algorithm, a
good acceptor determines that this action is actually enabled in that algorithm. Since an action is
enabled by the receipt of one or more messages, the acceptor has to determine that the enabling
messages are legal PCon messages.
Because algorithm PCon allows a 1a message to be sent
at any time, the only acceptor action whose enabling messages must be checked is the Phase2b
action. It is enabled iﬀthe appropriate 1c message and 2a message are legal. The 1c message
is legal iﬀthe leader has received the necessary 1b messages. The acceptor therefore maintains a
set of 1b messages that it knows have been sent, and checks that those 1b messages enable the
sending of the 1c message.
A 2a message is legal in the PCon algorithm iﬀ(i) the corresponding 1c message is legal and (ii)
it is the only 2a message that the leader sends. In the BPCon algorithm, there are no explicit 2a
messages. They are implicitly sent by the acceptors when they send enough 2av messages.
We leave unspeciﬁed how an acceptor discovers what 1b messages have been sent. In the Castro-
Liskov algorithm, this is done by having acceptors relay messages sent by other acceptors. An
acceptor knows that a 1b message has been sent if it receives it directly or else receives a copy
from a weak Byzantine quorum of acceptors. A (non-malicious) leader must determine what 1b
messages acceptors know about so it chooses a value so that a quorum of acceptors will act on its
Phase1c message and cause that value to be chosen. However, this is necessary only for liveness,
so we ignore this for now.
3

--- Page 4 ---
In other implementations of our algorithm, the leader sends along with the 1c message a proof
that the necessary 1b messages have been sent. The easiest way to do this is to have acceptors
digitally sign their 1b messages, so a copy of the message proves that it has been sent (by the
acceptor indicated in the message’s acc ﬁeld). The necessary proofs can also be constructed using
only message authenticators (like the ones used in the Castro-Liskov algorithm); how this is done
is described elsewhere.
In the abstract algorithm presented here, which we call BPCon, we do not specify how acceptors
learn what 1b messages have been sent. We simply introduce a variable knowsSent such that
knowsSent[a] represents the set of 1b messages that (good) acceptor a knows have been sent, and
have an action that nondeterministically adds sent 1b messages to this set.
--algorithm BPCon{
*************************************************************************
The variables:
maxBal[a] = Highest ballot in which acceptor a has participated.
maxVBal[a] = Highest ballot in which acceptor a has cast a vote (sent a 2b message); or −1
if it hasn’t cast a vote.
maxVVal[a] = Value acceptor a has voted for in ballot maxVBal[a], or None if maxVBal[a] =
−1.
2avSent[a] = A set of records in [val : Value, bal : Ballot] describing the 2av messages that a
has sent. A record is added to this set, and any element with the same val ﬁeld
(and lower bal ﬁeld) removed when a sends a 2av message.
knownSent[a] = The set of 1b messages that acceptor a knows have been sent.
bmsgs = The set of all messages that have been sent. See the discussion of the msgs variable
in module PConProof to understand our modeling of message passing.
*************************************************************************
variables maxBal
= [a ∈Acceptor 7→−1],
maxVBal = [a ∈Acceptor 7→−1],
maxVVal = [a ∈Acceptor 7→None],
2avSent
= [a ∈Acceptor 7→{}],
knowsSent = [a ∈Acceptor 7→{}],
bmsgs = {}
deﬁne {
sentMsgs(type, bal)
∆= {m ∈bmsgs : m.type = type ∧m.bal = bal}
KnowsSafeAt(ac, b, v)
∆=
True for an acceptor ac, ballot b, and value v iﬀthe set of 1b messages in knowsSent[ac]
implies that value v is safe at ballot b in the PaxosConsensus algorithm being emulated
by the good acceptors. To understand the deﬁnition, see the deﬁnition of ShowsSafeAt in
module PConProof and recall (a) the meaning of the mCBal and mCVal ﬁelds of a 1b
message and (b) that the set of real acceptors in a ByzQuorum forms a quorum of the
PaxosConsensus algorithm.
let S
∆= {m ∈knowsSent[ac] : m.bal = b}
in
∨∃BQ ∈ByzQuorum :
∀a ∈BQ : ∃m ∈S : ∧m.acc = a
∧m.mbal = −1
4

--- Page 5 ---
∨∃c ∈0 . . (b −1) :
∧∃BQ ∈ByzQuorum :
∀a ∈BQ : ∃m ∈S : ∧m.acc = a
∧m.mbal ≤c
∧(m.mbal = c) ⇒(m.mval = v)
∧∃WQ ∈WeakQuorum :
∀a ∈WQ :
∃m ∈S : ∧m.acc = a
∧∃r ∈m.m2av : ∧r.bal ≥c
∧r.val = v
}
We now describe the processes’ actions as macros.
The following two macros send a message and a set of messages, respectively. These macros are
so simple that they’re hardly worth introducing, but they do make the processes a little easier
to read.
macro SendMessage(m){bmsgs := bmsgs ∪{m}}
macro SendSetOfMessages(S){bmsgs := bmsgs ∪S}
As in the Paxos consensus algorithm, a ballot self leader (good or malicious) can execute a
Phase1a ation at any time.
macro Phase1a(){SendMessage([type 7→“1a”, bal 7→self ])}
The acceptor’s Phase1b ation is similar to that of the PaxosConsensus algorithm.
macro Phase1b(b){
when (b > maxBal[self ]) ∧(sentMsgs(“1a”, b) ̸= {}) ;
maxBal[self ] := b ;
SendMessage([type 7→“1b”, bal 7→b, acc 7→self , m2av 7→2avSent[self ],
mbal 7→maxVBal[self ], mval 7→maxVVal[self ]])
}
A good ballot self leader can send a phase 1c message for value v if it knows that the messages
in knowsSent[a] for a Quorum of (good) acceptors imply that they know that v is safe at ballot
self , and that they can convince any other acceptor that the appropriate 1b messages have
been sent to that it will also know that v is safe at ballot self .
A malicious ballot self leader can send any phase 1c messages it wants (including one that
a good leader could send). We prove safety with a Phase1c ation that allows a leader to be
malicious. To prove liveness, we will have to assume a good leader that sends only correct 1c
messages.
As in the PaxosConsensus algorithm, we allow a Phase1c action to send a set of Phase1c
messages. (This is not done in the Castro-Liskov algorithm, but seems natural in light of the
PaxosConsensus algorithm.)
macro Phase1c(){
with (S ∈subset [type : {“1c”}, bal : {self }, val : Value]){
SendSetOfMessages(S)}
}
5

--- Page 6 ---
If acceptor self receives a ballot b phase 1c message with value v, it relays v in a phase 2av
message if
- it has not already sent a 2av message in this or a later ballot and
- the messages in knowsSent[self ] show it that v is safe at b in the non-Byzantine Paxos
consensus algorithm being emulated.
macro Phase2av(b){
when ∧maxBal[self ] ≤b
∧∀r ∈2avSent[self ] : r.bal < b ;
We could just as well have used r.bal ̸= b in this condition.
with (m ∈{ms ∈sentMsgs(“1c”, b) : KnowsSafeAt(self , b, ms.val)}){
SendMessage([type 7→“2av”, bal 7→b, val 7→m.val, acc 7→self ]) ;
2avSent[self ] := {r ∈2avSent[self ] : r.val ̸= m.val}
∪{[val 7→m.val, bal 7→b]}
} ;
maxBal[self ] := b ;
}
Acceptor self can send a phase 2b message with value v if it has received phase 2av messages
from a Byzantine quorum, which implies that a quorum of good acceptors assert that this is
the ﬁrst 1c message sent by the leader and that the leader was allowed to send that message.
It sets maxBal[self ], maxVBal[self ], and maxVVal[self ] as in the non-Byzantine algorithm.
macro Phase2b(b){
when maxBal[self ] ≤b ;
with (v ∈{vv ∈Value :
∃Q ∈ByzQuorum :
∀aa ∈Q :
∃m ∈sentMsgs(“2av”, b) : ∧m.val = vv
∧m.acc = aa}){
SendMessage([type 7→“2b”, acc 7→self , bal 7→b, val 7→v]) ;
maxVVal[self ] := v ;
} ;
maxBal[self ] := b ;
maxVBal[self ] := b
}
At any time, an acceptor can learn that some set of 1b messages were sent (but only if they
atually were sent).
macro LearnsSent(b){
with (S ∈subset sentMsgs(“1b”, b)){
knowsSent[self ] := knowsSent[self ] ∪S
}
}
A malicious acceptor self can send any acceptor message indicating that it is from itself. Since
a malicious acceptor could allow other malicious processes to forge its messages, this action
could represent the sending of the message by any malicious process.
6

--- Page 7 ---
macro FakingAcceptor(){
with (m ∈{mm ∈1bMessage ∪2avMessage ∪2bMessage :
mm.acc = self }){
SendMessage(m)
}
}
We combine these individual actions into a complete algorithm in the usual way, with separate
process declarations for the acceptor, leader, and fake acceptor processes.
process (acceptor ∈Acceptor){
acc: while (true){
with (b ∈Ballot){either Phase1b(b)or Phase2av(b)
or Phase2b(b)or LearnsSent(b)}
}
}
process (leader ∈Ballot){
ldr : while (true){
either Phase1a()or Phase1c()
}
}
process (facceptor ∈FakeAcceptor){
facc : while (true){FakingAcceptor()}
}
}
Below is the TLA+ translation, as produced by the translator.
(Some blank lines have been
removed.)
*************************************************************************
BEGIN TRANSLATION
variables maxBal, maxVBal, maxVVal, 2avSent, knowsSent, bmsgs
deﬁne statement
sentMsgs(type, bal)
∆= {m ∈bmsgs : m.type = type ∧m.bal = bal}
KnowsSafeAt(ac, b, v)
∆=
let S
∆= {m ∈knowsSent[ac] : m.bal = b}
in
∨∃BQ ∈ByzQuorum :
∀a ∈BQ : ∃m ∈S : ∧m.acc = a
∧m.mbal = −1
∨∃c ∈0 . . (b −1) :
∧∃BQ ∈ByzQuorum :
∀a ∈BQ : ∃m ∈S : ∧m.acc = a
∧m.mbal ≤c
∧(m.mbal = c) ⇒(m.mval = v)
∧∃WQ ∈WeakQuorum :
7

--- Page 8 ---
∀a ∈WQ :
∃m ∈S : ∧m.acc = a
∧∃r ∈m.m2av : ∧r.bal ≥c
∧r.val = v
vars
∆= ⟨maxBal, maxVBal, maxVVal, 2avSent, knowsSent, bmsgs⟩
ProcSet
∆= (Acceptor) ∪(Ballot) ∪(FakeAcceptor)
Init
∆=
Global variables
∧maxBal = [a ∈Acceptor 7→−1]
∧maxVBal = [a ∈Acceptor 7→−1]
∧maxVVal = [a ∈Acceptor 7→None]
∧2avSent
= [a ∈Acceptor 7→{}]
∧knowsSent = [a ∈Acceptor 7→{}]
∧bmsgs = {}
acceptor(self )
∆= ∃b ∈Ballot :
∨∧(b > maxBal[self ]) ∧(sentMsgs(“1a”, b) ̸= {})
∧maxBal′ = [maxBal except ![self ] = b]
∧bmsgs′ = (bmsgs ∪{([type 7→“1b”, bal 7→b, acc 7→self , m2av 7→2avSent[self ],
mbal 7→maxVBal[self ], mval 7→maxVVal[self ]])})
∧unchanged ⟨maxVBal, maxVVal, 2avSent, knowsSent⟩
∨∧∧maxBal[self ] ≤b
∧∀r ∈2avSent[self ] : r.bal < b
∧∃m ∈{ms ∈sentMsgs(“1c”, b) : KnowsSafeAt(self , b, ms.val)} :
∧bmsgs′ = (bmsgs ∪{([type 7→“2av”, bal 7→b, val 7→m.val, acc 7→self ])})
∧2avSent′ = [2avSent except ![self ] = {r ∈2avSent[self ] : r.val ̸= m.val}
∪{[val 7→m.val, bal 7→b]}]
∧maxBal′ = [maxBal except ![self ] = b]
∧unchanged ⟨maxVBal, maxVVal, knowsSent⟩
∨∧maxBal[self ] ≤b
∧∃v ∈{vv
∈Value :
∃Q ∈ByzQuorum :
∀aa ∈Q :
∃m ∈sentMsgs(“2av”, b) : ∧m.val = vv
∧m.acc = aa} :
∧bmsgs′ = (bmsgs ∪{([type 7→“2b”, acc 7→self , bal 7→b, val 7→v])})
∧maxVVal′ = [maxVVal except ![self ] = v]
∧maxBal′ = [maxBal except ![self ] = b]
∧maxVBal′ = [maxVBal except ![self ] = b]
∧unchanged ⟨2avSent, knowsSent⟩
∨∧∃S ∈subset sentMsgs(“1b”, b) :
knowsSent′ = [knowsSent except ![self ] = knowsSent[self ] ∪S]
∧unchanged ⟨maxBal, maxVBal, maxVVal, 2avSent, bmsgs⟩
8

--- Page 9 ---
leader(self )
∆= ∧∨∧bmsgs′ = (bmsgs ∪{([type 7→“1a”, bal 7→self ])})
∨∧∃S ∈subset [type : {“1c”}, bal : {self }, val : Value] :
bmsgs′ = (bmsgs ∪S)
∧unchanged ⟨maxBal, maxVBal, maxVVal, 2avSent, knowsSent⟩
facceptor(self )
∆= ∧∃m ∈{mm ∈1bMessage ∪2avMessage ∪2bMessage :
mm.acc = self } :
bmsgs′ = (bmsgs ∪{m})
∧unchanged ⟨maxBal, maxVBal, maxVVal, 2avSent,
knowsSent⟩
Next
∆= (∃self ∈Acceptor : acceptor(self ))
∨(∃self ∈Ballot : leader(self ))
∨(∃self ∈FakeAcceptor : facceptor(self ))
Spec
∆= Init ∧2[Next]vars
END TRANSLATION
As in module PConProof , we now rewrite the next-state relation in a form more convenient for
writing proofs.
Phase1b(self , b)
∆=
∧(b > maxBal[self ]) ∧(sentMsgs(“1a”, b) ̸= {})
∧maxBal′ = [maxBal except ![self ] = b]
∧bmsgs′ = bmsgs ∪{[type 7→“1b”, bal 7→b, acc 7→self ,
m2av 7→2avSent[self ],
mbal 7→maxVBal[self ], mval 7→maxVVal[self ]]}
∧unchanged ⟨maxVBal, maxVVal, 2avSent, knowsSent⟩
Phase2av(self , b)
∆=
∧maxBal[self ] ≤b
∧∀r
∈2avSent[self ] : r.bal < b
∧∃m ∈{ms ∈sentMsgs(“1c”, b) : KnowsSafeAt(self , b, ms.val)} :
∧bmsgs′ = bmsgs ∪
{[type 7→“2av”, bal 7→b, val 7→m.val, acc 7→self ]}
∧2avSent′ = [2avSent except
![self ] = {r ∈2avSent[self ] : r.val ̸= m.val}
∪{[val 7→m.val, bal 7→b]}]
∧maxBal′ = [maxBal except ![self ] = b]
∧unchanged ⟨maxVBal, maxVVal, knowsSent⟩
Phase2b(self , b)
∆=
∧maxBal[self ] ≤b
∧∃v ∈{vv
∈Value :
∃Q ∈ByzQuorum :
9

--- Page 10 ---
∀a ∈Q :
∃m ∈sentMsgs(“2av”, b) : ∧m.val = vv
∧m.acc = a} :
∧bmsgs′ = (bmsgs ∪
{[type 7→“2b”, acc 7→self , bal 7→b, val 7→v]})
∧maxVVal′ = [maxVVal except ![self ] = v]
∧maxBal′ = [maxBal except ![self ] = b]
∧maxVBal′ = [maxVBal except ![self ] = b]
∧unchanged ⟨2avSent, knowsSent⟩
LearnsSent(self , b)
∆=
∧∃S ∈subset sentMsgs(“1b”, b) :
knowsSent′ = [knowsSent except ![self ] = knowsSent[self ] ∪S]
∧unchanged ⟨maxBal, maxVBal, maxVVal, 2avSent, bmsgs⟩
Phase1a(self )
∆=
∧bmsgs′ = (bmsgs ∪{[type 7→“1a”, bal 7→self ]})
∧unchanged ⟨maxBal, maxVBal, maxVVal, 2avSent, knowsSent⟩
Phase1c(self )
∆=
∧∃S ∈subset [type : {“1c”}, bal : {self }, val : Value] :
bmsgs′ = (bmsgs ∪S)
∧unchanged ⟨maxBal, maxVBal, maxVVal, 2avSent, knowsSent⟩
FakingAcceptor(self )
∆=
∧∃m ∈{mm ∈1bMessage ∪2avMessage ∪2bMessage : mm.acc = self } :
bmsgs′ = (bmsgs ∪{m})
∧unchanged ⟨maxBal, maxVBal, maxVVal, 2avSent, knowsSent⟩
The following lemma describes how the next-state relation Next can be written in terms of the
actions deﬁned above.
lemma NextDef
∆=
Next ≡∨∃self ∈Acceptor :
∃b ∈Ballot : ∨Phase1b(self , b)
∨Phase2av(self , b)
∨Phase2b(self , b)
∨LearnsSent(self , b)
∨∃self ∈Ballot : ∨Phase1a(self )
∨Phase1c(self )
∨∃self ∈FakeAcceptor : FakingAcceptor(self )
⟨1⟩1. ∀self : acceptor(self ) ≡NextDef !2!1!(self )
by
def acceptor, Phase1b, Phase2av, Phase2b, LearnsSent
⟨1⟩2. ∀self : leader(self ) ≡NextDef !2!2!(self )
by def leader, Phase1a, Phase1c
⟨1⟩3. ∀self : facceptor(self ) ≡NextDef !2!3!(self )
by def facceptor, FakingAcceptor
10

--- Page 11 ---
⟨1⟩4. qed
by ⟨1⟩1, ⟨1⟩2, ⟨1⟩3, Zenon
def Next, acceptor, leader, facceptor
THE REFINEMENT MAPPING
We deﬁne a quorum to be the set of acceptors in a Byzantine quorum. The quorum assumption
QA of module PConProof , which we here call QuorumTheorem, follows easily from the deﬁnition
and assumption BQA.
Quorum
∆= {S ∩Acceptor : S ∈ByzQuorum}
theorem QuorumTheorem
∆=
∧∀Q1, Q2 ∈Quorum : Q1 ∩Q2 ̸= {}
∧∀Q ∈Quorum : Q ⊆Acceptor
by BQA def Quorum
We now deﬁne reﬁnement mapping under which our algorithm implements the algorithm of module
PConProof .
First, we deﬁne the set msgs that implements the variable of the same name in
PConProof . There are two non-obvious parts of the deﬁnition.
1. The 1c messages in msgs should just be the ones that are legal–that is, messages whose value
is safe at the indicated ballot. The obvious way to deﬁne legality is in terms of 1b messages that
have been sent. However, this has the eﬀect that sending a 1b message can add both that 1b
message and one or more 1c messages to msgs. Proving implementation under this reﬁnement
mapping would require adding a stuttering variable. Instead, we deﬁne the 1c message to be legal
if the set of 1b messages that some acceptor knows were sent conﬁrms its legality. Thus, those 1c
messages are added to msgs by the LearnsSent ation, which has no other eﬀect on the reﬁnement
mapping.
2. A 2a message is added to msgs when a quorum of acceptors have reacted to it by sending a
2av message.
msgsOfType(t)
∆= {m ∈bmsgs : m.type = t}
acceptorMsgsOfType(t)
∆= {m ∈msgsOfType(t) : m.acc ∈Acceptor}
1bRestrict(m)
∆= [type 7→“1b”, acc 7→m.acc, bal 7→m.bal,
mbal 7→m.mbal, mval 7→m.mval]
1bmsgs
∆= {1bRestrict(m) : m ∈acceptorMsgsOfType(“1b”)}
1cmsgs
∆= {m ∈msgsOfType(“1c”) :
∃a ∈Acceptor
: KnowsSafeAt(a, m.bal, m.val)}
2amsgs
∆= {m ∈[type : {“2a”}, bal : Ballot, val : Value] :
∃Q ∈Quorum :
∀a ∈Q :
∃m2av ∈acceptorMsgsOfType(“2av”) :
∧m2av.acc = a
∧m2av.bal = m.bal
∧m2av.val = m.val}
11

--- Page 12 ---
msgs
∆= msgsOfType(“1a”) ∪1bmsgs ∪1cmsgs ∪2amsgs
∪acceptorMsgsOfType(“2b”)
We now deﬁne PmaxBal, the state function with which we instantiate the variable maxBal of
PConProof . The reason we don’t just instantiate it with the variable maxBal is that maxBal[a]
can change when acceptor a performs a Phase2av ation, which does not correspond to any acceptor
action of the PCon algorithm. We want PmaxBal[a] to change only when a performs a Phase1b
or Phase2b ation–that is, when it sends a 1b or 2b message. Thus, we deﬁne PmaxBal[a] to be
the largest bal ﬁeld of all 1b and 2b messages sent by a .
To deﬁne PmaxBal, we need to deﬁne an operator MaxBallot so that MaxBallot(S) is the largest
element of S if S is non-empty a ﬁnite set consisting of ballot numbers and possibly the value −1.
MaxBallot(S)
∆=
if S = {} then −1
else choose mb ∈S : ∀x ∈S : mb ≥x
To prove that the choose
in this deﬁnition actually does choose a maximum of S when S is
nonempty, we need the following fact.
lemma FiniteSetHasMax
∆=
∀S ∈subset Int :
IsFiniteSet(S) ∧(S ̸= {}) ⇒∃max ∈S : ∀x ∈S : max ≥x
⟨1⟩.define P(S)
∆= S ⊆Int ∧S ̸= {} ⇒
∃max ∈S : ∀x ∈S : max ≥x
⟨1⟩1. P({})
obvious
⟨1⟩2. assume new T, new x, P(T)
prove
P(T ∪{x})
by ⟨1⟩2
⟨1⟩3. ∀S : IsFiniteSet(S) ⇒P(S)
⟨2⟩.hide def P
⟨2⟩.qed by ⟨1⟩1, ⟨1⟩2, FS Induction, IsaM (“blast”)
⟨1⟩.qed by ⟨1⟩3, Zenon
Our proofs use this property of MaxBallot.
theorem MaxBallotProp
∆=
assume new S ∈subset (Ballot ∪{ −1}),
IsFiniteSet(S)
prove
if S = {} then MaxBallot(S) = −1
else
∧MaxBallot(S) ∈S
∧∀x ∈S : MaxBallot(S) ≥x
⟨1⟩1.case S = {}
by ⟨1⟩1 def MaxBallot
⟨1⟩2.case S ̸= {}
⟨2⟩.pick mb ∈S : ∀x ∈S : mb ≥x
by ⟨1⟩2, FiniteSetHasMax def Ballot
⟨2⟩.qed by ⟨1⟩2 def MaxBallot
⟨1⟩.qed by ⟨1⟩1, ⟨1⟩2
12

--- Page 13 ---
We now prove a couple of lemmas about MaxBallot.
lemma MaxBallotLemma1
∆=
assume new S ∈subset (Ballot ∪{ −1}),
IsFiniteSet(S),
new y ∈S, ∀x ∈S : y ≥x
prove
y = MaxBallot(S)
⟨1⟩1. ∧MaxBallot(S) ∈S
∧MaxBallot(S) ≥y
by MaxBallotProp
⟨1⟩2 ∧y ∈Ballot ∪{ −1}
∧y ≥MaxBallot(S)
by MaxBallotProp
⟨1⟩3. MaxBallot(S) ∈Int ∧y ∈Int
by ⟨1⟩1, ⟨1⟩2, Isa def Ballot
⟨1⟩.qed by ⟨1⟩1, ⟨1⟩2, ⟨1⟩3
lemma MaxBallotLemma2
∆=
assume new S ∈subset (Ballot ∪{ −1}),
new T ∈subset (Ballot ∪{ −1}),
IsFiniteSet(S), IsFiniteSet(T)
prove
MaxBallot(S ∪T) = if MaxBallot(S) ≥MaxBallot(T)
then MaxBallot(S) else MaxBallot(T)
⟨1⟩1. ∧MaxBallot(S) ∈Ballot ∪{ −1}
∧MaxBallot(T) ∈Ballot ∪{ −1}
by MaxBallotProp
⟨1⟩.S ∪T ⊆Int
by def Ballot
⟨1⟩2.case MaxBallot(S) ≥MaxBallot(T)
⟨2⟩.suffices assume T ̸= {}
prove
MaxBallot(S ∪T) = MaxBallot(S)
by ⟨1⟩2, Zenon
⟨2⟩1. ∧MaxBallot(T) ∈T
∧∀x ∈T : MaxBallot(T) ≥x
by MaxBallotProp
⟨2⟩2.case S = {}
⟨3⟩1. MaxBallot(S) = −1
by ⟨2⟩2 def MaxBallot
⟨3⟩2. MaxBallot(T) = −1
by ⟨3⟩1, ⟨1⟩2, ⟨1⟩1 def Ballot
⟨3⟩.qed by ⟨2⟩2, ⟨3⟩1, ⟨3⟩2, ⟨2⟩1, MaxBallotLemma1, FS Union
⟨2⟩3.case S ̸= {}
⟨3⟩1. ∧MaxBallot(S) ∈S
∧∀x ∈S : MaxBallot(S) ≥x
by ⟨2⟩3, MaxBallotProp
⟨3⟩2. ∧MaxBallot(S) ∈S ∪T
13

--- Page 14 ---
∧∀x ∈S ∪T : MaxBallot(S) ≥x
by ⟨3⟩1, ⟨2⟩1, ⟨1⟩2
⟨3⟩.qed by ⟨3⟩2, MaxBallotLemma1, FS Union, Zenon
⟨2⟩.qed by ⟨2⟩2, ⟨2⟩3
⟨1⟩3.case ¬(MaxBallot(S) ≥MaxBallot(T))
⟨2⟩.suffices assume S ̸= {}
prove
MaxBallot(S ∪T) = MaxBallot(T)
by ⟨1⟩3
⟨2⟩1. ∧MaxBallot(S) ∈S
∧∀x ∈S : MaxBallot(S) ≥x
by MaxBallotProp
⟨2⟩2. ∧MaxBallot(S) < MaxBallot(T)
∧MaxBallot(T) ̸= −1
by ⟨1⟩3, ⟨1⟩1 def Ballot
⟨2⟩3. ∧MaxBallot(T) ∈T
∧∀x ∈T : MaxBallot(T) ≥x
by ⟨2⟩2, MaxBallotProp
⟨2⟩4. ∧MaxBallot(T) ∈S ∪T
∧∀x ∈S ∪T : MaxBallot(T) ≥x
by ⟨2⟩3, ⟨2⟩2, ⟨2⟩1
⟨2⟩.qed by ⟨2⟩4, MaxBallotLemma1, FS Union, Zenon
⟨1⟩.qed by ⟨1⟩2, ⟨1⟩3
We ﬁnally come to our deﬁnition of PmaxBal, the state function substituted for variable maxBal
of module PConProof by our reﬁnement mapping.
We also prove a couple of lemmas about
PmaxBal.
1bOr2bMsgs
∆= {m ∈bmsgs : m.type ∈{“1b”, “2b”}}
PmaxBal
∆= [a ∈Acceptor 7→
MaxBallot({m.bal : m ∈{ma ∈1bOr2bMsgs :
ma.acc = a}})]
lemma PmaxBalLemma1
∆=
assume new m,
bmsgs′ = bmsgs ∪{m},
m.type ̸= “1b” ∧m.type ̸= “2b”
prove
PmaxBal′ = PmaxBal
by Zenon def PmaxBal, 1bOr2bMsgs
lemma PmaxBalLemma2
∆=
assume new m,
bmsgs′ = bmsgs ∪{m},
new a ∈Acceptor,
m.acc ̸= a
prove
PmaxBal′[a] = PmaxBal[a]
14

--- Page 15 ---
by def PmaxBal, 1bOr2bMsgs
Finally, we deﬁne the reﬁnement mapping.
As before, for any operator op deﬁned in module
PConProof , the following instance statement deﬁnes P !op to be the operator obtained from op
by the indicated substitutions, along with the implicit substitutions
Acceptor ←Acceptor,
Quorum ←Quorum
Value ←Value
maxVBal ←maxVBal
maxVVal ←maxVVal
msgs
←msgs
P
∆= instance PConProof with maxBal ←PmaxBal
We now deﬁne the inductive invariant Inv used in our proof. It is deﬁned to be the conjunction of
a number of separate invariants that we deﬁne ﬁrst, starting with the ever-present type-correctness
invariant.
TypeOK
∆= ∧maxBal
∈[Acceptor →Ballot ∪{ −1}]
∧2avSent
∈[Acceptor →subset [val : Value, bal : Ballot]]
∧maxVBal ∈[Acceptor →Ballot ∪{ −1}]
∧maxVVal ∈[Acceptor →Value ∪{None}]
∧knowsSent ∈[Acceptor →subset 1bMessage]
∧bmsgs ⊆BMessage
To use the deﬁnition of PmaxBal, we need to know that the set of 1b and 2b messages in bmsgs
is ﬁnite. This is asserted by the following invariant. Note that the set bmsgs is not necessarily
ﬁnite because we allow a Phase1c action to send an inﬁnite number of 1c messages.
bmsgsFinite
∆= IsFiniteSet(1bOr2bMsgs)
The following lemma is used to prove the invariance of bmsgsFinite.
lemma FiniteMsgsLemma
∆=
assume new m, bmsgsFinite, bmsgs′ = bmsgs ∪{m}
prove
bmsgsFinite′
by FS AddElement def bmsgsFinite, 1bOr2bMsgs
Invariant 1bInv1 asserts that if (good) acceptor a has mCBal[a] ̸= −1, then there is a 1c message
for ballot mCBal[a] and value mCVal[a] in the emulated execution of algorithm PCon.
1bInv1
∆= ∀m ∈bmsgs :
∧m.type = “1b”
∧m.acc ∈Acceptor
⇒∀r ∈m.m2av :
[type 7→“1c”, bal 7→r.bal, val 7→r.val] ∈msgs
Invariant 1bInv2 asserts that an acceptor sends at most one 1b message for any ballot.
1bInv2
∆= ∀m1, m2 ∈bmsgs :
∧m1.type = “1b”
∧m2.type = “1b”
∧m1.acc ∈Acceptor
15

--- Page 16 ---
∧m1.acc = m2.acc
∧m1.bal = m2.bal
⇒m1 = m2
Invariant 2avInv1 asserts that an acceptor sends at most one 2av message in any ballot.
2avInv1
∆= ∀m1, m2 ∈bmsgs :
∧m1.type = “2av”
∧m2.type = “2av”
∧m1.acc ∈Acceptor
∧m1.acc = m2.acc
∧m1.bal = m2.bal
⇒m1 = m2
Invariant 2avInv2 follows easily from the meaning (and setting) of 2avSent.
2avInv2
∆= ∀m ∈bmsgs :
∧m.type = “2av”
∧m.acc ∈Acceptor
⇒∃r ∈2avSent[m.acc] : ∧r.val = m.val
∧r.bal ≥m.bal
Invariant 2avInv3 asserts that an acceptor sends a 2av message only if the required 1c message
exists in the emulated execution of algorithm PConf .
2avInv3
∆= ∀m ∈bmsgs :
∧m.type = “2av”
∧m.acc ∈Acceptor
⇒[type 7→“1c”, bal 7→m.bal, val 7→m.val] ∈msgs
Invariant maxBalInv is a simple consequence of the fact that an acceptor a sets maxBal[a] to b
whenever it sends a 1b, 2av, or 2b message in ballot b.
maxBalInv
∆= ∀m ∈bmsgs :
∧m.type ∈{“1b”, “2av”, “2b”}
∧m.acc ∈Acceptor
⇒m.bal ≤maxBal[m.acc]
Invariant accInv asserts some simple relations between the variables local to an acceptor, as well
as the fact that acceptor a sets maxCBal[a] to b and maxCVal[a] to v only if there is a ballot-b
1c message for value c in the simulated execution of the PCon algorithm.
accInv
∆= ∀a ∈Acceptor :
∀r ∈2avSent[a] :
∧r.bal ≤maxBal[a]
∧[type 7→“1c”, bal 7→r.bal, val 7→r.val] ∈msgs
Invariant knowsSentInv simply asserts that for any acceptor a , knowsSent[a] is a set of 1b
messages that have actually been sent.
knowsSentInv
∆= ∀a ∈Acceptor : knowsSent[a] ⊆msgsOfType(“1b”)
Inv
∆=
16

--- Page 17 ---
TypeOK ∧bmsgsFinite ∧1bInv1 ∧1bInv2 ∧maxBalInv ∧2avInv1 ∧2avInv2
∧2avInv3 ∧accInv ∧knowsSentInv
We now prove some simple lemmas that are useful for reasoning about PmaxBal.
lemma PMaxBalLemma3
∆=
assume TypeOK,
bmsgsFinite,
new a ∈Acceptor
prove
let S
∆= {m.bal : m ∈{ma ∈bmsgs :
∧ma.type ∈{“1b”, “2b”}
∧ma.acc = a}}
in
∧IsFiniteSet(S)
∧S ∈subset Ballot
⟨1⟩define T
∆= {ma ∈bmsgs : ∧ma.type ∈{“1b”, “2b”}
∧ma.acc = a}
S
∆= {m.bal : m ∈T}
⟨1⟩1. IsFiniteSet(S)
⟨2⟩1. IsFiniteSet(T)
by FS Subset def bmsgsFinite, 1bOr2bMsgs
⟨2⟩.qed
by ⟨2⟩1, FS Image, Isa
⟨1⟩.qed by ⟨1⟩1, BMessageLemma def 1bMessage, 2bMessage, TypeOK
lemma PmaxBalLemma4
∆=
assume TypeOK,
maxBalInv,
bmsgsFinite,
new a ∈Acceptor
prove
PmaxBal[a] ≤maxBal[a]
⟨1⟩define SM
∆= {ma ∈bmsgs : ∧ma.type ∈{“1b”, “2b”}
∧ma.acc = a}
S
∆= {ma.bal : ma ∈SM }
⟨1⟩1. PmaxBal[a] = MaxBallot(S)
by def PmaxBal, 1bOr2bMsgs
⟨1⟩2. ∧IsFiniteSet(S)
∧S ∈subset Ballot
by PMaxBalLemma3
⟨1⟩3. ∀b ∈S : b ≤maxBal[a]
by def maxBalInv
⟨1⟩4.case S = {}
⟨2⟩1. PmaxBal[a] = −1
by ⟨1⟩2, ⟨1⟩1, ⟨1⟩4, MaxBallotProp
⟨2⟩.qed
by ⟨2⟩1 def Ballot, TypeOK
⟨1⟩5.case S ̸= {}
17

--- Page 18 ---
⟨2⟩1. MaxBallot(S) ∈S
by ⟨1⟩2, ⟨1⟩5, MaxBallotProp, Zenon
⟨2⟩2. qed
by ⟨1⟩1, ⟨1⟩3, ⟨2⟩1
⟨1⟩6. qed
by ⟨1⟩4, ⟨1⟩5
lemma PmaxBalLemma5
∆=
assume TypeOK, bmsgsFinite, new a ∈Acceptor
prove
PmaxBal[a] ∈Ballot ∪{ −1}
by PMaxBalLemma3, MaxBallotProp def PmaxBal, 1bOr2bMsgs
Now comes a bunch of useful lemmas.
We ﬁrst prove that P !NextDef is a valid theorem and give it the name PNextDef . This requires
proving that the assumptions of module PConProof are satisﬁed by the reﬁnement mapping. Note
that P !NextDef ! : is an abbreviation for the statement of theorem P !NextDef – that is, for the
statement of theorem NextDef of module PConProof under the substitutions of the reﬁnement
mapping.
lemma PNextDef
∆= P !NextDef ! :
⟨1⟩1. P !QA
by QuorumTheorem
⟨1⟩2. P !BallotAssump
by BallotAssump def Ballot, P !Ballot, ByzAcceptor
⟨1⟩3. qed
by P !NextDef , ⟨1⟩1, ⟨1⟩2, NoSetContainsEverything
For convenience, we deﬁne operators corresponding to subexpressions that appear in the deﬁnition
of KnowsSafeAt.
KSet(a, b)
∆= {m ∈knowsSent[a] : m.bal = b}
KS1(S)
∆= ∃BQ ∈ByzQuorum : ∀a ∈BQ :
∃m ∈S : m.acc = a ∧m.mbal = −1
KS2(v, b, S)
∆= ∃c ∈0 . . (b −1) :
∧∃BQ ∈ByzQuorum : ∀a ∈BQ :
∃m ∈S : ∧m.acc = a
∧m.mbal ≤c
∧(m.mbal = c) ⇒(m.mval = v)
∧∃WQ ∈WeakQuorum : ∀a ∈WQ :
∃m ∈S : ∧m.acc = a
∧∃r ∈m.m2av : ∧r.bal ≥c
∧r.val = v
The following lemma asserts the obvious relation between KnowsSafeAt and the top-level deﬁni-
tions KS1, KS2, and KSet. The second conjunct is, of course, the primed version of the ﬁrst.
lemma KnowsSafeAtDef
∆=
18

--- Page 19 ---
∀a, b, v :
∧KnowsSafeAt(a, b, v) ≡KS1(KSet(a, b)) ∨KS2(v, b, KSet(a, b))
∧KnowsSafeAt(a, b, v)′ ≡KS1(KSet(a, b)′) ∨KS2(v, b, KSet(a, b)′)
by def KnowsSafeAt, KSet, KS1, KS2
lemma MsgsTypeLemma
∆=
∀m ∈msgs : ∧(m.type = “1a”) ≡(m ∈msgsOfType(“1a”))
∧(m.type = “1b”) ≡(m ∈1bmsgs)
∧(m.type = “1c”) ≡(m ∈1cmsgs)
∧(m.type = “2a”) ≡(m ∈2amsgs)
∧(m.type = “2b”) ≡(m ∈acceptorMsgsOfType(“2b”))
by def msgsOfType, 1bmsgs, 1bRestrict, 1cmsgs, 2amsgs, acceptorMsgsOfType, msgs
The following lemma is the primed version of MsgsTypeLemma. That is, its statement is just the
statement of MsgsTypeLemma primed. It follows from MsgsTypeLemma by the meta-theorem
that if we can prove a state-predicate F as a (top-level) theorem, then we can deduce F ′. This is
an instance of propositional temporal-logic reasoning. Alternatively the lemma could be proved
using the same reasoning used for the unprimed version of the theorem.
lemma MsgsTypeLemmaPrime
∆=
∀m ∈msgs′ : ∧(m.type = “1a”) ≡(m ∈msgsOfType(“1a”)′)
∧(m.type = “1b”) ≡(m ∈1bmsgs′)
∧(m.type = “1c”) ≡(m ∈1cmsgs′)
∧(m.type = “2a”) ≡(m ∈2amsgs′)
∧(m.type = “2b”) ≡(m ∈acceptorMsgsOfType(“2b”)′)
⟨1⟩1. MsgsTypeLemma′
by MsgsTypeLemma, PTL
⟨1⟩.qed
by ⟨1⟩1
The following lemma describes how msgs is changed by the actions of the algorithm.
lemma MsgsLemma
∆=
TypeOK ⇒
∧
∀self ∈Acceptor, b ∈Ballot :
Phase1b(self , b) ⇒
msgs′ = msgs ∪
{[type 7→“1b”, acc 7→self , bal 7→b,
mbal 7→maxVBal[self ], mval 7→maxVVal[self ]]}
∧
∀self ∈Acceptor, b ∈Ballot :
Phase2av(self , b) ⇒
∨msgs′ = msgs
∨∃v ∈Value :
∧[type 7→“1c”, bal 7→b, val 7→v] ∈msgs
∧msgs′ = msgs ∪{[type 7→“2a”, bal 7→b, val 7→v]}
∧
∀self ∈Acceptor, b ∈Ballot :
Phase2b(self , b) ⇒
∃v ∈Value :
19

--- Page 20 ---
∧∃Q ∈ByzQuorum :
∀a ∈Q :
∃m ∈sentMsgs(“2av”, b) : ∧m.val = v
∧m.acc = a
∧msgs′ = msgs ∪
{[type 7→“2b”, acc 7→self , bal 7→b, val 7→v]}
∧bmsgs′ = bmsgs ∪
{[type 7→“2b”, acc 7→self , bal 7→b, val 7→v]}
∧maxVVal′ = [maxVVal except ![self ] = v]
∧
∀self ∈Acceptor, b ∈Ballot :
LearnsSent(self , b) ⇒
∃S ∈subset {m ∈msgsOfType(“1c”) : m.bal = b} :
msgs′ = msgs ∪S
∧
∀self ∈Ballot :
Phase1a(self ) ⇒
msgs′ = msgs ∪{[type 7→“1a”, bal 7→self ]}
∧
∀self ∈Ballot :
Phase1c(self ) ⇒
∃S ∈subset [type : {“1c”}, bal : {self }, val : Value] :
∧∀m ∈S :
∃a ∈Acceptor : KnowsSafeAt(a, m.bal, m.val)
∧msgs′ = msgs ∪S
∧
∀self ∈FakeAcceptor : FakingAcceptor(self ) ⇒msgs′ = msgs
⟨1⟩have TypeOK
⟨1⟩1. assume new self ∈Acceptor, new b ∈Ballot, Phase1b(self , b)
prove
msgs′ = msgs ∪
{[type 7→“1b”, acc 7→self , bal 7→b,
mbal 7→maxVBal[self ], mval 7→maxVVal[self ]]}
⟨2⟩define m
∆= [type
7→“1b”, acc 7→self , bal 7→b,
m2av 7→2avSent[self ],
mbal 7→maxVBal[self ], mval 7→maxVVal[self ]]
⟨2⟩1. bmsgs′ = bmsgs ∪{m} ∧knowsSent′ = knowsSent
by ⟨1⟩1 def Phase1b
⟨2⟩a. ∧msgsOfType(“1a”)′ = msgsOfType(“1a”)
∧1bmsgs′ = 1bmsgs ∪{1bRestrict(m)}
∧1cmsgs′ = 1cmsgs
∧2amsgs′ = 2amsgs
∧acceptorMsgsOfType(“2b”)′ = acceptorMsgsOfType(“2b”)
by ⟨2⟩1 def msgsOfType, 1bmsgs, acceptorMsgsOfType, KnowsSafeAt, 1cmsgs, 2amsgs
⟨2⟩.qed
by ⟨2⟩a def msgs, 1bRestrict
⟨1⟩2. assume new self ∈Acceptor, new b ∈Ballot, Phase2av(self , b)
prove
∨msgs′ = msgs
20

--- Page 21 ---
∨∃v ∈Value :
∧[type 7→“1c”, bal 7→b, val 7→v] ∈msgs
∧msgs′ = msgs ∪{[type 7→“2a”, bal 7→b, val 7→v]}
⟨2⟩1. pick m ∈sentMsgs(“1c”, b) :
∧KnowsSafeAt(self , b, m.val)
∧bmsgs′ = bmsgs ∪
{[type 7→“2av”, bal 7→b, val 7→m.val, acc 7→self ]}
by ⟨1⟩2 def Phase2av
⟨2⟩2. m = [type 7→“1c”, bal 7→b, val 7→m.val]
by BMessageLemma def sentMsgs, TypeOK, 1cMessage
⟨2⟩define ma
∆= [type 7→“2a”, bal 7→b, val 7→m.val]
mb
∆= [type 7→“2av”, bal 7→b, val 7→m.val, acc 7→self ]
⟨2⟩3. suffices assume msgs′ ̸= msgs
prove
∧m ∈msgs
∧msgs′ = msgs ∪{ma}
by ⟨2⟩2, BMessageLemma def sentMsgs, TypeOK, 1cMessage
⟨2⟩4. m ∈msgs
by ⟨2⟩1, ⟨2⟩2 def sentMsgs, 1cmsgs, msgsOfType, msgs
⟨2⟩5. msgs′ = msgs ∪{ma}
⟨3⟩1. knowsSent′ = knowsSent
by ⟨1⟩2 def Phase2av
⟨3⟩2. ∧msgsOfType(“1a”)′ = msgsOfType(“1a”)
∧1bmsgs′ = 1bmsgs
∧1cmsgs′ = 1cmsgs
∧acceptorMsgsOfType(“2b”)′ = acceptorMsgsOfType(“2b”)
by ⟨2⟩1, ⟨3⟩1 def msgsOfType, 1bmsgs, 1bRestrict, acceptorMsgsOfType, KnowsSafeAt, 1cmsgs
⟨3⟩.qed
by ⟨3⟩1, ⟨3⟩2, ⟨2⟩1, ⟨2⟩3 def msgs, 2amsgs, msgsOfType, acceptorMsgsOfType
⟨2⟩6. qed
by ⟨2⟩4, ⟨2⟩5
⟨1⟩3. assume new self ∈Acceptor, new b ∈Ballot, Phase2b(self , b)
prove
∃v ∈Value :
∧∃Q ∈ByzQuorum :
∀a ∈Q :
∃m ∈sentMsgs(“2av”, b) : ∧m.val = v
∧m.acc = a
∧msgs′ = msgs ∪
{[type 7→“2b”, acc 7→self , bal 7→b, val 7→v]}
∧bmsgs′ = bmsgs ∪
{[type 7→“2b”, acc 7→self , bal 7→b, val 7→v]}
∧maxVVal′ = [maxVVal except ![self ] = v]
⟨2⟩1. pick v ∈Value :
∧∃Q ∈ByzQuorum :
∀a ∈Q :
21

--- Page 22 ---
∃m ∈sentMsgs(“2av”, b) : ∧m.val = v
∧m.acc = a
∧bmsgs′ = bmsgs ∪
{[type 7→“2b”, acc 7→self , bal 7→b, val 7→v]}
∧maxVVal′ = [maxVVal except ![self ] = v]
∧knowsSent′ = knowsSent
by ⟨1⟩3, Zenon def Phase2b
⟨2⟩define bm
∆= [type 7→“2b”, acc 7→self , bal 7→b, val 7→v]
⟨2⟩2. ∧msgsOfType(“1a”)′ = msgsOfType(“1a”)
∧1bmsgs′ = 1bmsgs
∧1cmsgs′ = 1cmsgs
∧2amsgs′ = 2amsgs
∧acceptorMsgsOfType(“2b”)′ = acceptorMsgsOfType(“2b”) ∪{bm}
by ⟨2⟩1 def msgsOfType, 1bmsgs, 1bRestrict, 1cmsgs, KnowsSafeAt, 2amsgs, acceptorMsgsOfType
⟨2⟩4. msgs′ = msgs ∪{bm}
by ⟨2⟩2 def msgs
⟨2⟩.qed
by ⟨2⟩1, ⟨2⟩4, Zenon
⟨1⟩4. assume new self ∈Acceptor, new b ∈Ballot, LearnsSent(self , b)
prove
∃S ∈subset {m ∈msgsOfType(“1c”) : m.bal = b} : msgs′ = msgs ∪S
⟨2⟩1. ∧msgsOfType(“1a”)′ = msgsOfType(“1a”)
∧1bmsgs′ = 1bmsgs
∧2amsgs′ = 2amsgs
∧acceptorMsgsOfType(“2b”)′ = acceptorMsgsOfType(“2b”)
by ⟨1⟩4 def LearnsSent, msgsOfType, 1bmsgs, 1bRestrict, 2amsgs, acceptorMsgsOfType
⟨2⟩. ∧1cmsgs ⊆1cmsgs′
∧1cmsgs′ \ 1cmsgs ∈subset {m ∈msgsOfType(“1c”) : m.bal = b}
⟨3⟩1. bmsgs′ = bmsgs
by ⟨1⟩4 def LearnsSent
⟨3⟩2. pick S ∈subset sentMsgs(“1b”, b) :
knowsSent′ = [knowsSent except ![self ] = knowsSent[self ] ∪S]
by ⟨1⟩4, Zenon def LearnsSent
⟨3⟩3. assume new m ∈1cmsgs
prove
m ∈1cmsgs′
by ⟨3⟩1, ⟨3⟩2 def TypeOK, KnowsSafeAt, 1cmsgs, msgsOfType
⟨3⟩4. assume new m ∈1cmsgs′, m /∈1cmsgs
prove
m ∈msgsOfType(“1c”) ∧m.bal = b
⟨4⟩1. m ∈msgsOfType(“1c”)
by ⟨3⟩1 def 1cmsgs, msgsOfType
⟨4⟩2. pick a ∈Acceptor : KnowsSafeAt(a, m.bal, m.val)′
by def 1cmsgs
⟨4⟩3. ¬KnowsSafeAt(a, m.bal, m.val)
by ⟨3⟩4, ⟨4⟩1 def 1cmsgs
⟨4⟩4. ∀aa ∈Acceptor, bb ∈Ballot :
22

--- Page 23 ---
∀mm ∈KSet(aa, bb)′ :
mm /∈KSet(aa, bb) ⇒bb = b
by ⟨1⟩4, ⟨3⟩2 def TypeOK, LearnsSent, TypeOK, sentMsgs, KSet
⟨4⟩5. m.bal ∈Ballot
by ⟨4⟩1, BMessageLemma def 1cMessage, msgsOfType, TypeOK
⟨4⟩6.case KS1(KSet(a, m.bal)′) ∧¬KS1(KSet(a, m.bal))
by ⟨4⟩6, ⟨4⟩1, ⟨4⟩4, ⟨4⟩5 def KS1
⟨4⟩7.case KS2(m.val, m.bal, KSet(a, m.bal)′) ∧¬KS2(m.val, m.bal, KSet(a, m.bal))
by ⟨4⟩7, ⟨4⟩1, ⟨4⟩4, ⟨4⟩5 def KS2
⟨4⟩qed
by ⟨4⟩6, ⟨4⟩7, ⟨4⟩2, ⟨4⟩3, KnowsSafeAtDef
⟨3⟩5. qed
by ⟨3⟩3, ⟨3⟩4
⟨2⟩.witness 1cmsgs′ \ 1cmsgs ∈subset {m ∈msgsOfType(“1c”) : m.bal = b}
⟨2⟩.qed
by ⟨2⟩1 def msgs
⟨1⟩5. assume new self ∈Ballot, Phase1a(self )
prove
msgs′ = msgs ∪{[type 7→“1a”, bal 7→self ]}
by ⟨1⟩5 def Phase1a, msgs, msgsOfType, 1bmsgs, 1bRestrict, 1cmsgs, KnowsSafeAt,
2amsgs, acceptorMsgsOfType
⟨1⟩6. assume new self ∈Ballot, Phase1c(self )
prove
∃S ∈subset [type : {“1c”}, bal : {self }, val : Value] :
∧∀m ∈S :
∃a ∈Acceptor : KnowsSafeAt(a, m.bal, m.val)
∧msgs′ = msgs ∪S
⟨2⟩1. pick S ∈subset [type : {“1c”}, bal : {self }, val : Value] :
∧bmsgs′ = bmsgs ∪S
∧knowsSent′ = knowsSent
by ⟨1⟩6 def Phase1c
⟨2⟩define SS
∆= {m ∈S : ∃a ∈Acceptor : KnowsSafeAt(a, m.bal, m.val)}
⟨2⟩suffices msgs′ = msgs ∪SS
by ⟨2⟩1, Zenon
⟨2⟩2. ∧msgsOfType(“1a”)′ = msgsOfType(“1a”)
∧1bmsgs′ = 1bmsgs
∧1cmsgs′ = 1cmsgs ∪SS
∧2amsgs′ = 2amsgs
∧acceptorMsgsOfType(“2b”)′ = acceptorMsgsOfType(“2b”)
by ⟨2⟩1 def msgsOfType, 1bmsgs, 1bRestrict, 1cmsgs, KnowsSafeAt, 2amsgs, acceptorMsgsOfType
⟨2⟩3. qed
by ⟨2⟩2 def msgs
⟨1⟩7. assume new self ∈FakeAcceptor, FakingAcceptor(self )
prove
msgs′ = msgs
by ⟨1⟩7, BQA def FakingAcceptor, msgs, 1bMessage, 2avMessage, 2bMessage,
23

--- Page 24 ---
msgsOfType, 1cmsgs, KnowsSafeAt, 1bmsgs, 2amsgs, acceptorMsgsOfType, msgsOfType
⟨1⟩9. qed
by ⟨1⟩1, ⟨1⟩2, ⟨1⟩3, ⟨1⟩4, ⟨1⟩5, ⟨1⟩6, ⟨1⟩7, Zenon
We now come to the proof of invariance of our inductive invariant Inv.
theorem Invariance
∆= Spec ⇒2Inv
⟨1⟩1. Init ⇒Inv
by FS EmptySet def Init, Inv, TypeOK, bmsgsFinite, 1bOr2bMsgs, 1bInv1, 1bInv2,
maxBalInv, 2avInv1, 2avInv2, 2avInv3, accInv, knowsSentInv
⟨1⟩2. Inv ∧[Next]vars ⇒Inv ′
⟨2⟩suffices assume Inv, [Next]vars
prove Inv ′
obvious
⟨2⟩1. assume new self ∈Acceptor,
new b ∈Ballot,
∨Phase1b(self , b)
∨Phase2av(self , b)
∨Phase2b(self , b)
∨LearnsSent(self , b)
prove
Inv ′
⟨3⟩1.case Phase1b(self , b)
⟨4⟩define mb
∆= [type 7→“1b”, bal 7→b, acc 7→self ,
m2av 7→2avSent[self ],
mbal 7→maxVBal[self ], mval 7→maxVVal[self ]]
mc
∆= [type
7→“1b”, acc 7→self , bal 7→b,
mbal 7→maxVBal[self ], mval 7→maxVVal[self ]]
⟨4⟩1. msgs′ = msgs ∪{mc}
by ⟨3⟩1, MsgsLemma def Inv
⟨4⟩2. TypeOK ′
by ⟨3⟩1 def Inv, TypeOK, BMessage, 1bMessage, ByzAcceptor, Phase1b
⟨4⟩3. bmsgsFinite′
by ⟨3⟩1, FiniteMsgsLemma, Zenon def Inv, bmsgsFinite, Phase1b
⟨4⟩4. 1bInv1′
by ⟨3⟩1, ⟨4⟩1, Isa def Phase1b, 1bInv1, Inv, accInv
⟨4⟩5. 1bInv2′
by ⟨3⟩1 def Phase1b, 1bInv2, Inv, maxBalInv, TypeOK, 1bMessage, Ballot
⟨4⟩6. maxBalInv ′
by ⟨3⟩1, BMessageLemma def Phase1b, maxBalInv, Ballot, Inv, TypeOK,
1bMessage, 2avMessage, 2bMessage
⟨4⟩7. 2avInv1′
by ⟨3⟩1 def Phase1b, Inv, 2avInv1
⟨4⟩8. 2avInv2′
by ⟨3⟩1 def Phase1b, Inv, 2avInv2
24

--- Page 25 ---
⟨4⟩9. 2avInv3′
by ⟨3⟩1, ⟨4⟩1 def Phase1b, Inv, 2avInv3
⟨4⟩10. accInv ′
⟨5⟩suffices assume new a ∈Acceptor,
new r ∈2avSent[a]
prove
∧r.bal ≤maxBal′[a]
∧[type 7→“1c”, bal 7→r.bal, val 7→r.val]
∈msgs′
by ⟨3⟩1, Zenon def accInv, Phase1b
⟨5⟩[type 7→“1c”, bal 7→r.bal, val 7→r.val] ∈msgs′
by ⟨3⟩1, MsgsLemma def Inv, accInv
⟨5⟩qed
by ⟨3⟩1 def Phase1b, Inv, Ballot, TypeOK, accInv
⟨4⟩11. knowsSentInv ′
by ⟨3⟩1 def Phase1b, Inv, knowsSentInv, msgsOfType
⟨4⟩12. qed
by ⟨4⟩2, ⟨4⟩3, ⟨4⟩4, ⟨4⟩5, ⟨4⟩6, ⟨4⟩7, ⟨4⟩8, ⟨4⟩9, ⟨4⟩10, ⟨4⟩11 def Inv
⟨3⟩2.case Phase2av(self , b)
⟨4⟩1. pick mc ∈sentMsgs(“1c”, b) :
∧KnowsSafeAt(self , b, mc.val)
∧bmsgs′ = bmsgs ∪
{[type 7→“2av”, bal 7→b,
val 7→mc.val, acc 7→self ]}
∧2avSent′ = [2avSent except
![self ] = {r ∈2avSent[self ] : r.val ̸= mc.val}
∪{[val 7→mc.val, bal 7→b]}]
by ⟨3⟩2, Zenon def Phase2av
⟨4⟩2. mc = [type 7→“1c”, bal 7→mc.bal, val 7→mc.val]
by ⟨4⟩1, BMessageLemma def sentMsgs, Inv, TypeOK, 1cMessage
⟨4⟩define mb
∆= [type 7→“2av”, bal 7→b,
val 7→mc.val, acc 7→self ]
mmc(v)
∆= [type 7→“1c”, bal 7→b, val 7→v]
ma(v)
∆= [type 7→“2a”, bal 7→b, val 7→v]
⟨4⟩3. ∨msgs′ = msgs
∨∃v ∈Value :
∧mmc(v) ∈msgs
∧msgs′ = msgs ∪{ma(v)}
by ⟨3⟩2, MsgsLemma, Zenon def Inv
⟨4⟩4. msgs ⊆msgs′
by ⟨4⟩3, Zenon
⟨4⟩5. TypeOK ′
by ⟨3⟩2, ⟨4⟩1, BMessageLemma
def sentMsgs, Inv, TypeOK, 1cMessage, Phase2av, 2avMessage, ByzAcceptor, BMessage
⟨4⟩6. bmsgsFinite′
by ⟨4⟩1, FiniteMsgsLemma, Zenon def Inv, bmsgsFinite
25

--- Page 26 ---
⟨4⟩7. 1bInv1′
by ⟨3⟩2, ⟨4⟩1, ⟨4⟩3, Isa def Phase2av, 1bInv1, Inv
⟨4⟩8. 1bInv2′
by ⟨4⟩1 def Inv, 1bInv2
⟨4⟩9. maxBalInv ′
by ⟨3⟩2, ⟨4⟩1, BMessageLemma
def Phase2av, maxBalInv, Ballot, Inv, TypeOK, 1bMessage, 2avMessage, 2bMessage
⟨4⟩10. 2avInv1′
by ⟨3⟩2, ⟨4⟩1 def Phase2av, Inv, 2avInv1, 2avInv2, TypeOK, 1bMessage, Ballot
⟨4⟩11. 2avInv2′
⟨5⟩1. suffices assume new m ∈bmsgs′,
2avInv2!(m)!1
prove
∃r ∈2avSent′[m.acc] : ∧r.val = m.val
∧r.bal ≥m.bal
by def 2avInv2
⟨5⟩2.case m.acc = self
⟨6⟩1.case m = mb
by ⟨4⟩1, ⟨6⟩1, Isa def Inv, TypeOK, Ballot
⟨6⟩2.case m ̸= mb
⟨7⟩1. m ∈bmsgs
by ⟨4⟩1, ⟨6⟩2
⟨7⟩2. pick r ∈2avSent[m.acc] : ∧r.val = m.val
∧r.bal ≥m.bal
by ⟨5⟩1, ⟨7⟩1 def Inv, 2avInv2
⟨7⟩3.case r.val = mc.val
⟨8⟩.define rr
∆= [val 7→mc.val, bal 7→b]
⟨8⟩.rr ∈2avSent′[m.acc]
by ⟨4⟩1, ⟨5⟩2 def Inv, TypeOK
⟨8⟩.witness rr ∈2avSent′[m.acc]
⟨8⟩.qed
by ⟨7⟩2, ⟨7⟩3, ⟨5⟩2, ⟨5⟩1, ⟨3⟩2, BMessageLemma
def Phase2av, Inv, TypeOK, accInv, Ballot, 2avMessage
⟨7⟩4.case r.val ̸= mc.val
by ⟨7⟩2, ⟨4⟩1, ⟨5⟩2, ⟨7⟩4 def Inv, TypeOK
⟨7⟩5. qed
by ⟨7⟩3, ⟨7⟩4
⟨6⟩3. qed
by ⟨6⟩1, ⟨6⟩2
⟨5⟩3.case m.acc ̸= self
by ⟨5⟩3, ⟨5⟩1, ⟨4⟩1, BMessageLemma def Inv, TypeOK, 2avInv2, 2avMessage
⟨5⟩4. qed
by ⟨5⟩2, ⟨5⟩3
⟨4⟩12. 2avInv3′
by ⟨4⟩1, ⟨4⟩2, ⟨4⟩4 def Inv, 2avInv3, sentMsgs, msgs, 1cmsgs, msgsOfType
⟨4⟩13. accInv ′
26

--- Page 27 ---
⟨5⟩1. suffices assume new a ∈Acceptor,
new r ∈2avSent′[a]
prove
∧r.bal ≤maxBal′[a]
∧[type 7→“1c”, bal 7→r.bal, val 7→r.val]
∈msgs′
by Zenon def accInv
⟨5⟩2.case r ∈2avSent[a]
by ⟨5⟩2, ⟨4⟩4, ⟨4⟩5, ⟨3⟩2 def Phase2av, Inv, TypeOK, accInv, Ballot
⟨5⟩3.case r /∈2avSent[a]
by ⟨5⟩3, ⟨3⟩2, ⟨4⟩1, ⟨4⟩2, ⟨4⟩4
def Phase2av, Inv, TypeOK, sentMsgs, msgsOfType, msgs, 1cmsgs, Ballot
⟨5⟩4. qed
by ⟨5⟩2, ⟨5⟩3
⟨4⟩14. knowsSentInv ′
by ⟨3⟩2, ⟨4⟩1 def Phase2av, Inv, knowsSentInv, msgsOfType
⟨4⟩15. qed
by ⟨4⟩5, ⟨4⟩6, ⟨4⟩7, ⟨4⟩8, ⟨4⟩9, ⟨4⟩10, ⟨4⟩11, ⟨4⟩12, ⟨4⟩13, ⟨4⟩14 def Inv
⟨3⟩3.case Phase2b(self , b)
⟨4⟩1. pick v ∈Value :
∧∃Q ∈ByzQuorum :
∀a ∈Q :
∃m ∈sentMsgs(“2av”, b) : ∧m.val = v
∧m.acc = a
∧msgs′ = msgs ∪
{[type 7→“2b”, acc 7→self , bal 7→b, val 7→v]}
∧bmsgs′ = (bmsgs ∪
{[type 7→“2b”, acc 7→self , bal 7→b, val 7→v]})
∧maxVVal′ = [maxVVal except ![self ] = v]
by ⟨3⟩3, MsgsLemma def Inv
⟨4⟩define mb
∆= [type 7→“2b”, acc 7→self , bal 7→b, val 7→v]
⟨4⟩2. TypeOK ′
by ⟨3⟩3, ⟨4⟩1 def Phase2b, Inv, TypeOK, BMessage, 2bMessage, ByzAcceptor
⟨4⟩3. bmsgsFinite′
by ⟨4⟩1, FiniteMsgsLemma, Zenon def Inv, bmsgsFinite
⟨4⟩4. 1bInv1′
by ⟨4⟩1, Isa def Inv, 1bInv1
⟨4⟩5. 1bInv2′
by ⟨4⟩1 def Inv, 1bInv2
⟨4⟩6. maxBalInv ′
by ⟨3⟩3, ⟨4⟩1, ⟨4⟩2, BMessageLemma
def Phase2b, Inv, maxBalInv, TypeOK, Ballot, 1bMessage, 2avMessage, 2bMessage
⟨4⟩7. 2avInv1′
by ⟨4⟩1 def Inv, 2avInv1
⟨4⟩8. 2avInv2′
by ⟨3⟩3, ⟨4⟩1 def Phase2b, Inv, TypeOK, 2avInv2
27

--- Page 28 ---
⟨4⟩9. 2avInv3′
by ⟨4⟩1 def Inv, 2avInv3
⟨4⟩10. accInv ′
⟨5⟩suffices assume new a ∈Acceptor,
new r ∈2avSent[a]
prove
∧r.bal ≤maxBal′[a]
∧[type 7→“1c”, bal 7→r.bal, val 7→r.val]
∈msgs′
by ⟨3⟩3, Zenon def accInv, Phase2b
⟨5⟩[type 7→“1c”, bal 7→r.bal, val 7→r.val] ∈msgs′
by ⟨3⟩3, MsgsLemma def Inv, accInv
⟨5⟩qed
by ⟨3⟩3 def Phase2b, Inv, Ballot, TypeOK, accInv
⟨4⟩11. knowsSentInv ′
by ⟨3⟩3, ⟨4⟩1 def Phase2b, Inv, knowsSentInv, msgsOfType
⟨4⟩12. qed
by ⟨4⟩2, ⟨4⟩3, ⟨4⟩4, ⟨4⟩5, ⟨4⟩6, ⟨4⟩7, ⟨4⟩8, ⟨4⟩9, ⟨4⟩10, ⟨4⟩11 def Inv
⟨3⟩4.case LearnsSent(self , b)
⟨4⟩1. pick MS : ∧MS ⊆{m ∈msgsOfType(“1c”) : m.bal = b}
∧msgs′ = msgs ∪MS
by ⟨3⟩4, MsgsLemma, Zenon def Inv
⟨4⟩2. pick S :
∧S ⊆sentMsgs(“1b”, b)
∧knowsSent′ =
[knowsSent except ![self ] = knowsSent[self ] ∪S]
by ⟨3⟩4, Zenon def LearnsSent
⟨4⟩3. TypeOK ′
by ⟨3⟩4, ⟨4⟩2, BMessageLemma def Inv, TypeOK, sentMsgs, LearnsSent
⟨4⟩4. bmsgsFinite′
by ⟨3⟩4 def LearnsSent, Inv, bmsgsFinite, 1bOr2bMsgs
⟨4⟩5. 1bInv1′
by ⟨3⟩4, ⟨4⟩1, Zenon def LearnsSent, Inv, 1bInv1
⟨4⟩6. 1bInv2′
by ⟨3⟩4 def LearnsSent, Inv, 1bInv2
⟨4⟩7. maxBalInv ′
by ⟨3⟩4 def LearnsSent, Inv, maxBalInv
⟨4⟩8. 2avInv1′
by ⟨3⟩4 def LearnsSent, Inv, 2avInv1
⟨4⟩9. 2avInv2′
by ⟨3⟩4 def LearnsSent, Inv, 2avInv2
⟨4⟩10. 2avInv3′
by ⟨3⟩4, ⟨4⟩1 def LearnsSent, Inv, 2avInv3
⟨4⟩11. accInv ′
by ⟨3⟩4, ⟨4⟩1, Zenon def LearnsSent, Inv, accInv
⟨4⟩12. knowsSentInv ′
28

--- Page 29 ---
by ⟨3⟩4, ⟨4⟩2 def LearnsSent, Inv, TypeOK, knowsSentInv, sentMsgs, msgsOfType
⟨4⟩13. qed
by ⟨4⟩3, ⟨4⟩4, ⟨4⟩5, ⟨4⟩6, ⟨4⟩7, ⟨4⟩8, ⟨4⟩9, ⟨4⟩10, ⟨4⟩11, ⟨4⟩12 def Inv
⟨3⟩5. qed
by ⟨2⟩1, ⟨3⟩1, ⟨3⟩2, ⟨3⟩3, ⟨3⟩4
⟨2⟩2. assume new self ∈Ballot,
∨Phase1a(self )
∨Phase1c(self )
prove
Inv ′
⟨3⟩1.case Phase1a(self )
⟨4⟩define ma
∆= [type 7→“1a”, bal 7→self ]
⟨4⟩1. msgs′ = msgs ∪{ma}
by ⟨3⟩1, MsgsLemma def Inv
⟨4⟩2. TypeOK ′
by ⟨3⟩1 def Phase1a, Inv, TypeOK, BMessage, 1aMessage
⟨4⟩3. bmsgsFinite′
by ⟨3⟩1, FiniteMsgsLemma, Zenon def Inv, bmsgsFinite, Phase1a
⟨4⟩4. 1bInv1′
by ⟨3⟩1, ⟨4⟩1, Isa def Phase1a, Inv, 1bInv1
⟨4⟩5. 1bInv2′
by ⟨3⟩1 def Phase1a, Inv, 1bInv2
⟨4⟩6. maxBalInv ′
by ⟨3⟩1 def Phase1a, Inv, maxBalInv
⟨4⟩7. 2avInv1′
by ⟨3⟩1 def Phase1a, Inv, 2avInv1
⟨4⟩8. 2avInv2′
by ⟨3⟩1 def Phase1a, Inv, 2avInv2
⟨4⟩9. 2avInv3′
by ⟨3⟩1, ⟨4⟩1 def Phase1a, Inv, 2avInv3
⟨4⟩10. accInv ′
by ⟨3⟩1, ⟨4⟩1, Zenon def Phase1a, Inv, accInv
⟨4⟩11. knowsSentInv ′
by ⟨3⟩1 def Inv, knowsSentInv, msgsOfType, Phase1a
⟨4⟩12. qed
by ⟨4⟩2, ⟨4⟩3, ⟨4⟩4, ⟨4⟩5, ⟨4⟩6, ⟨4⟩7, ⟨4⟩8, ⟨4⟩9, ⟨4⟩10, ⟨4⟩11 def Inv
⟨3⟩2.case Phase1c(self )
⟨4⟩1. pick S : ∧S ∈subset [type : {“1c”}, bal : {self }, val : Value]
∧bmsgs′ = bmsgs ∪S
by ⟨3⟩2 def Phase1c
⟨4⟩2. pick MS :
∧MS ∈subset [type : {“1c”}, bal : {self }, val : Value]
∧∀m ∈MS :
∃a ∈Acceptor : KnowsSafeAt(a, m.bal, m.val)
∧msgs′ = msgs ∪MS
by ⟨3⟩2, MsgsLemma def Inv
29

--- Page 30 ---
⟨4⟩3. TypeOK ′
by ⟨3⟩2, ⟨4⟩1 def Phase1c, Inv, TypeOK, BMessage, 1cMessage
⟨4⟩4. bmsgsFinite′
by ⟨4⟩1 def Inv, bmsgsFinite, 1bOr2bMsgs
⟨4⟩5. 1bInv1′
by ⟨3⟩2, ⟨4⟩2, Zenon def Phase1c, Inv, 1bInv1
⟨4⟩6. 1bInv2′
by ⟨4⟩1 def Inv, 1bInv2
⟨4⟩7. maxBalInv ′
by ⟨3⟩2 def Phase1c, Inv, maxBalInv
⟨4⟩8. 2avInv1′
by ⟨4⟩1 def Inv, 2avInv1
⟨4⟩9. 2avInv2′
by ⟨3⟩2 def Phase1c, Inv, 2avInv2
⟨4⟩10. 2avInv3′
by ⟨3⟩2, ⟨4⟩2 def Phase1c, Inv, 2avInv3
⟨4⟩11. accInv ′
by ⟨3⟩2, ⟨4⟩2, Zenon def Phase1c, Inv, accInv
⟨4⟩12. knowsSentInv ′
by ⟨3⟩2 def Inv, knowsSentInv, msgsOfType, Phase1c
⟨4⟩13. qed
by ⟨4⟩3, ⟨4⟩4, ⟨4⟩5, ⟨4⟩6, ⟨4⟩7, ⟨4⟩8, ⟨4⟩9, ⟨4⟩10, ⟨4⟩11, ⟨4⟩12 def Inv
⟨3⟩3. qed
by ⟨3⟩1, ⟨3⟩2, ⟨2⟩2
⟨2⟩3. assume new self ∈FakeAcceptor,
FakingAcceptor(self )
prove
Inv ′
⟨3⟩1. pick m ∈1bMessage ∪2avMessage ∪2bMessage :
∧m.acc /∈Acceptor
∧bmsgs′ = bmsgs ∪{m}
by ⟨2⟩3, BQA def FakingAcceptor
⟨3⟩2. msgs′ = msgs
by ⟨2⟩3, MsgsLemma def Inv
⟨3⟩3. TypeOK ′
by ⟨2⟩3, ⟨3⟩1 def Inv, TypeOK, BMessage, FakingAcceptor
⟨3⟩4. bmsgsFinite′
by ⟨3⟩1, FiniteMsgsLemma def Inv, TypeOK
⟨3⟩5. 1bInv1′
by ⟨3⟩1, ⟨3⟩2, Zenon def Inv, 1bInv1
⟨3⟩6. 1bInv2′
by ⟨3⟩1 def Inv, 1bInv2
⟨3⟩7. maxBalInv ′
by ⟨2⟩3, ⟨3⟩1 def Inv, maxBalInv, FakingAcceptor
⟨3⟩8. 2avInv1′
by ⟨3⟩1 def Inv, 2avInv1
30

--- Page 31 ---
⟨3⟩9. 2avInv2′
by ⟨2⟩3, ⟨3⟩1 def Inv, 2avInv2, FakingAcceptor
⟨3⟩10. 2avInv3′
by ⟨3⟩1, ⟨3⟩2 def Inv, 2avInv3
⟨3⟩11. accInv ′
by ⟨2⟩3, ⟨3⟩2, Zenon def Inv, accInv, FakingAcceptor
⟨3⟩12. knowsSentInv ′
by ⟨2⟩3, ⟨3⟩1 def Inv, knowsSentInv, msgsOfType, FakingAcceptor
⟨3⟩13. qed
by ⟨3⟩3, ⟨3⟩4, ⟨3⟩5, ⟨3⟩6, ⟨3⟩7, ⟨3⟩8, ⟨3⟩9, ⟨3⟩10, ⟨3⟩11, ⟨3⟩12 def Inv
⟨2⟩4. assume unchanged vars
prove
Inv ′
⟨3⟩use unchanged vars def Inv, vars
⟨3⟩msgs = msgs′
by def msgs, msgsOfType, 1bmsgs, 1bRestrict, acceptorMsgsOfType, 1cmsgs,
KnowsSafeAt, 2amsgs
⟨3⟩qed
by def TypeOK, bmsgsFinite, 1bOr2bMsgs, 1bInv1, 1bInv2,
maxBalInv, 2avInv1, 2avInv2, 2avInv3, accInv, knowsSentInv, msgsOfType
⟨2⟩5. qed
by ⟨2⟩1, ⟨2⟩2, ⟨2⟩3, ⟨2⟩4, NextDef
⟨1⟩3. qed
by ⟨1⟩1, ⟨1⟩2, PTL def Spec
We next use the invariance of Inv to prove that algorithm BPCon implements algorithm PCon
under the reﬁnement mapping deﬁned by the instance statement above.
theorem Spec ⇒P !Spec
⟨1⟩1. Init ⇒P !Init
⟨2⟩.have Init
⟨2⟩1. MaxBallot({}) = −1
by MaxBallotProp, FS EmptySet
⟨2⟩2. P !Init !1 ∧P !Init !2 ∧P !Init !3
by ⟨2⟩1 def Init, PmaxBal, 1bOr2bMsgs, None, P !None
⟨2⟩3. msgs = {}
by BQA def Init, msgsOfType, acceptorMsgsOfType, 1bmsgs, 1cmsgs, 2amsgs, Quorum, msgs
⟨2⟩4. qed
by ⟨2⟩2, ⟨2⟩3 def P !Init
⟨1⟩2. Inv ∧Inv ′ ∧[Next]vars ⇒[P !Next]P !vars
⟨2⟩InvP
∆= Inv ′
⟨2⟩suffices assume Inv, InvP, Next
prove
P !TLANext ∨P !vars′ = P !vars
⟨3⟩unchanged vars ⇒unchanged P !vars
by def vars, P !vars, PmaxBal, 1bOr2bMsgs, msgs, msgsOfType, acceptorMsgsOfType,
31

--- Page 32 ---
1bmsgs, 2amsgs, 1cmsgs, KnowsSafeAt
⟨3⟩qed
by PNextDef def Inv, P !ProcSet, P !Init, Ballot, P !Ballot
⟨2⟩hide def InvP
⟨2⟩2. ∀a ∈Acceptor : PmaxBal[a] ∈Ballot ∪{ −1}
by PMaxBalLemma3, MaxBallotProp def Inv, PmaxBal, 1bOr2bMsgs
⟨2⟩3. assume new self ∈Acceptor, new b ∈Ballot,
Phase1b(self , b)
prove
P !TLANext ∨P !vars′ = P !vars
⟨3⟩1. msgs′ = msgs ∪{[type 7→“1b”, acc 7→self , bal 7→b,
mbal 7→maxVBal[self ], mval 7→maxVVal[self ]]}
by ⟨2⟩3, MsgsLemma def Inv
⟨3⟩2. P !sentMsgs(“1a”, b) ̸= {}
by ⟨2⟩3 def Phase1b, sentMsgs, msgsOfType, msgs, P !sentMsgs
⟨3⟩3. unchanged ⟨maxVBal, maxVVal⟩
by ⟨2⟩3 def Phase1b
⟨3⟩4. b > PmaxBal[self ]
by ⟨2⟩2, ⟨2⟩3, PmaxBalLemma4 def Phase1b, Inv, TypeOK, Ballot
⟨3⟩5. PmaxBal′ = [PmaxBal except ![self ] = b]
⟨4⟩define m
∆= [type 7→“1b”, bal 7→b, acc 7→self ,
m2av 7→2avSent[self ],
mbal 7→maxVBal[self ], mval 7→maxVVal[self ]]
mA(a)
∆= {ma ∈bmsgs : ∧ma.type ∈{“1b”, “2b”}
∧ma.acc = a}
S(a)
∆= {ma.bal : ma ∈mA(a)}
⟨4⟩1. bmsgs′ = bmsgs ∪{m}
by ⟨2⟩3 def Phase1b
⟨4⟩2. mA(self )′ = mA(self ) ∪{m}
by ⟨4⟩1
⟨4⟩3. ∧PmaxBal = [a ∈Acceptor 7→MaxBallot(S(a))]
∧PmaxBal′ = [a ∈Acceptor 7→MaxBallot(S(a))′]
by def PmaxBal, 1bOr2bMsgs
⟨4⟩hide def mA
⟨4⟩4. S(self )′ = S(self ) ∪{b}
by ⟨4⟩2, Isa
⟨4⟩5. MaxBallot(S(self ) ∪{b}) = b
⟨5⟩define SS
∆= S(self ) ∪{b}
⟨5⟩1. IsFiniteSet(S(self ))
⟨6⟩.IsFiniteSet(mA(self ))
by FS Subset def Inv, bmsgsFinite, mA, 1bOr2bMsgs
⟨6⟩.qed
by FS Image, Isa
⟨5⟩2. IsFiniteSet(SS)
by ⟨5⟩1, FS AddElement
⟨5⟩3. S(self ) ⊆Ballot ∪{ −1}
32

--- Page 33 ---
by BMessageLemma def mA, Inv, TypeOK, 1bMessage, 2bMessage
⟨5⟩4. ∀x ∈SS : b ≥x
by ⟨3⟩4, ⟨4⟩3, ⟨5⟩1, ⟨5⟩3, MaxBallotProp, Z3T(10) def Ballot
⟨5⟩5. qed
by ⟨5⟩2, ⟨5⟩3, ⟨5⟩4, MaxBallotLemma1
⟨4⟩6. ∀a ∈Acceptor : a ̸= self ⇒S(a)′ = S(a)
by ⟨4⟩1 def mA
⟨4⟩7. qed
by ⟨4⟩3, ⟨4⟩4, ⟨4⟩5, ⟨4⟩6, Zenon def PmaxBal, 1bOr2bMsgs
⟨3⟩6. qed
by ⟨3⟩1, ⟨3⟩2, ⟨3⟩3, ⟨3⟩4, ⟨3⟩5, Zenon def P !TLANext, P !Ballot, Ballot, P !Phase1b
⟨2⟩4. assume new self ∈Acceptor, new b ∈Ballot,
Phase2av(self , b)
prove
P !TLANext ∨P !vars′ = P !vars
⟨3⟩1. PmaxBal′ = PmaxBal
⟨4⟩define mm(m)
∆= [type 7→“2av”, bal 7→b,
val 7→m.val, acc 7→self ]
⟨4⟩1. pick m : bmsgs′ = bmsgs ∪{mm(m)}
by ⟨2⟩4
def Phase2av
⟨4⟩2. mm(m).type = “2av”
obvious
⟨4⟩qed
by ⟨4⟩1, ⟨4⟩2, PmaxBalLemma1, Zenon
⟨3⟩2.case msgs′ = msgs
by ⟨3⟩1, ⟨3⟩2, ⟨2⟩4 def Phase2av, P !vars
⟨3⟩3.case ∧msgs′ ̸= msgs
∧∃v ∈Value :
∧[type 7→“1c”, bal 7→b, val 7→v] ∈msgs
∧msgs′ = msgs ∪{[type 7→“2a”, bal 7→b, val 7→v]}
⟨4⟩1. pick v ∈Value :
∧[type 7→“1c”, bal 7→b, val 7→v] ∈msgs
∧msgs′ = msgs ∪{[type 7→“2a”, bal 7→b, val 7→v]}
by ⟨3⟩3
⟨4⟩2. P !sentMsgs(“2a”, b) = {}
⟨5⟩1. suffices assume new m ∈P !sentMsgs(“2a”, b)
prove
m = [type 7→“2a”, bal 7→b, val 7→v]
by ⟨3⟩3, ⟨4⟩1 def P !sentMsgs
⟨5⟩2. ∧m ∈2amsgs
∧m.type = “2a”
∧m.bal = b
by MsgsTypeLemma def P !sentMsgs
⟨5⟩3. pick Q ∈Quorum :
∀a ∈Q
:
∃mav ∈acceptorMsgsOfType(“2av”) :
∧mav.acc = a
33

--- Page 34 ---
∧mav.bal = b
∧mav.val = m.val
by ⟨5⟩2 def 2amsgs
⟨5⟩4. pick Q2 ∈Quorum :
∀a ∈Q2
:
∃m2av ∈acceptorMsgsOfType(“2av”)′ :
∧m2av.acc = a
∧m2av.bal = b
∧m2av.val = v
by ⟨4⟩1, MsgsTypeLemmaPrime, Isa def 2amsgs
⟨5⟩5. pick a ∈Q ∩Q2 : a ∈Acceptor
by QuorumTheorem
⟨5⟩6. pick mav ∈acceptorMsgsOfType(“2av”) :
∧mav.acc = a
∧mav.bal = b
∧mav.val = m.val
by ⟨5⟩3, ⟨5⟩5
⟨5⟩7. pick m2av ∈acceptorMsgsOfType(“2av”)′ :
∧m2av.acc = a
∧m2av.bal = b
∧m2av.val = v
by ⟨5⟩4, ⟨5⟩5
⟨5⟩8. mav ∈acceptorMsgsOfType(“2av”)′
by ⟨2⟩4 def acceptorMsgsOfType, msgsOfType, Phase2av
⟨5⟩9. m.val = v
by ⟨5⟩5, ⟨5⟩6, ⟨5⟩7, ⟨5⟩8 def 2avInv1, InvP, Inv, acceptorMsgsOfType, msgsOfType
⟨5⟩10. qed
by ⟨5⟩2, ⟨5⟩9 def 2amsgs
⟨4⟩4. qed
by ⟨2⟩4, ⟨3⟩1, ⟨4⟩1, ⟨4⟩2 def P !TLANext, P !Phase2a, Phase2av, Ballot, P !Ballot
⟨3⟩4. ∨msgs′ = msgs
∨( ∧msgs′ ̸= msgs
∧∃v ∈Value :
∧[type 7→“1c”, bal 7→b, val 7→v] ∈msgs
∧msgs′ = msgs ∪{[type 7→“2a”, bal 7→b, val 7→v]})
by MsgsLemma, ⟨2⟩4, Zenon def Inv
⟨3⟩5. qed
by ⟨3⟩2, ⟨3⟩3, ⟨3⟩4
⟨2⟩5. assume new self ∈Acceptor, new b ∈Ballot,
Phase2b(self , b)
prove
P !TLANext ∨P !vars′ = P !vars
⟨3⟩1. PmaxBal[self ] ≤b
⟨4⟩1. PmaxBal[self ] ≤maxBal[self ]
by PmaxBalLemma4 def Inv
⟨4⟩2. maxBal[self ] ≤b
34

--- Page 35 ---
by ⟨2⟩5 def Phase2b
⟨4⟩3. qed
by ⟨4⟩1, ⟨4⟩2, PmaxBalLemma5 def Inv, TypeOK, Ballot
⟨3⟩2. pick v ∈Value :
∧∃Q ∈ByzQuorum :
∀a ∈Q :
∃m ∈sentMsgs(“2av”, b) : ∧m.val = v
∧m.acc = a
∧msgs′ = msgs ∪
{[type 7→“2b”, acc 7→self , bal 7→b, val 7→v]}
∧bmsgs′ = bmsgs ∪
{[type 7→“2b”, acc 7→self , bal 7→b, val 7→v]}
∧maxVVal′ = [maxVVal except ![self ] = v]
by ⟨2⟩5, MsgsLemma def Inv
⟨3⟩define m
∆= [type 7→“2a”, bal 7→b, val 7→v]
m2b
∆= [type 7→“2b”, acc 7→self , bal 7→b, val 7→v]
⟨3⟩3. m ∈P !sentMsgs(“2a”, b)
⟨4⟩1. pick Q ∈Quorum :
∀a ∈Q
:
∃mm ∈sentMsgs(“2av”, b) : ∧mm.val = v
∧mm.acc = a
by ⟨3⟩2, Isa def Quorum
⟨4⟩2. m ∈2amsgs
by ⟨4⟩1 def sentMsgs, Quorum, acceptorMsgsOfType, msgsOfType, 2amsgs
⟨4⟩3. qed
by ⟨4⟩2 def P !sentMsgs, msgs
⟨3⟩4. PmaxBal′ = [PmaxBal except ![self ] = b]
⟨4⟩1. assume new a ∈Acceptor,
a ̸= self
prove
PmaxBal′[a] = PmaxBal[a]
by ⟨3⟩2, ⟨4⟩1, PmaxBalLemma2, m2b.acc = self , Zenon
⟨4⟩2. PmaxBal′[self ] = b
⟨5⟩define S
∆= {mm.bal : mm ∈{ma ∈bmsgs :
∧ma.type ∈{“1b”, “2b”}
∧ma.acc = self }}
T
∆= S ∪{m2b.bal}
⟨5⟩1. IsFiniteSet(S) ∧(S ∈subset Ballot)
by PMaxBalLemma3 def Inv
⟨5⟩2. IsFiniteSet(T) ∧(T ∈subset Ballot)
by ⟨5⟩1, FS AddElement
⟨5⟩3. PmaxBal[self ] = MaxBallot(S)
by def PmaxBal, 1bOr2bMsgs
⟨5⟩4. PmaxBal′[self ] = MaxBallot(T)
by ⟨3⟩2, Zenon def PmaxBal, 1bOr2bMsgs
⟨5⟩hide def S
35

--- Page 36 ---
⟨5⟩5.case S = {}
⟨6⟩MaxBallot({b}) = b
by FS Singleton, MaxBallotLemma1, Isa def Ballot
⟨6⟩qed
by ⟨5⟩4, ⟨5⟩5
⟨5⟩6.case S ̸= {}
⟨6⟩∀bb ∈T : b ≥bb
by ⟨3⟩1, ⟨5⟩1, ⟨5⟩3, MaxBallotProp, PmaxBalLemma5 def Inv, Ballot
⟨6⟩qed
by ⟨5⟩2, ⟨5⟩4, MaxBallotLemma1
⟨5⟩7. qed
by ⟨5⟩5, ⟨5⟩6
⟨4⟩3. qed
by ⟨4⟩1, ⟨4⟩2, Zenon def PmaxBal, 1bOr2bMsgs
⟨3⟩5. ∧maxVBal′ = [maxVBal except ![self ] = b]
∧maxVVal′ = [maxVVal except ![self ] = m.val]
by ⟨2⟩5, ⟨3⟩2, Zenon def Phase2b
⟨3⟩6. qed
by ⟨3⟩1, ⟨3⟩2, ⟨3⟩3, ⟨3⟩4, ⟨3⟩5, Zenon
def P !TLANext, P !Phase2b, Ballot, P !Ballot
⟨2⟩6. assume new self ∈Acceptor, new b ∈Ballot,
LearnsSent(self , b)
prove
P !TLANext ∨P !vars′ = P !vars
⟨3⟩1. pick SM ∈subset {m ∈msgsOfType(“1c”) : m.bal = b} :
msgs′ = msgs ∪SM
by ⟨2⟩6, MsgsLemma def Inv
⟨3⟩define S
∆= {m.val : m ∈SM }
⟨3⟩2. S ∈subset Value
by BMessageLemma def Inv, TypeOK, msgsOfType, 1cMessage
⟨3⟩3. msgs′ = msgs ∪{[type 7→“1c”, bal 7→b, val 7→v] : v ∈S}
by ⟨3⟩1, BMessageLemma def Inv, TypeOK, msgsOfType, 1cMessage
⟨3⟩4. assume new v ∈S
prove
∃Q ∈Quorum : P !ShowsSafeAt(Q, b, v)
⟨4⟩1. pick ac ∈Acceptor
: KnowsSafeAt(ac, b, v)′
by ⟨3⟩1, MsgsTypeLemmaPrime def msgsOfType, 1cmsgs
⟨4⟩2. bmsgs′ = bmsgs
by ⟨2⟩6 def LearnsSent
⟨4⟩define Q(BQ)
∆= BQ ∩Acceptor
SS
∆= {m ∈knowsSent′[ac] : m.bal = b}
SQ(BQ)
∆= {1bRestrict(mm) :
mm ∈{m ∈SS : m.acc ∈Q(BQ)}}
Q1b(BQ)
∆= {m ∈P !sentMsgs(“1b”, b) : m.acc ∈Q(BQ)}
⟨4⟩3. assume new BQ ∈ByzQuorum,
∀a ∈BQ : ∃m ∈SS : m.acc = a
prove
SQ(BQ) = Q1b(BQ)
36

--- Page 37 ---
⟨5⟩1. assume new m ∈P !sentMsgs(“1b”, b),
m.acc ∈Q(BQ)
prove m ∈SQ(BQ)
by ⟨4⟩2, ⟨4⟩3, ⟨5⟩1, MsgsTypeLemma
def P !sentMsgs, msgs, 1bmsgs, acceptorMsgsOfType, msgsOfType,
1bRestrict, InvP, Inv, knowsSentInv, 1bInv2
⟨5⟩2. assume new m ∈SS,
m.acc
∈Q(BQ)
prove
1bRestrict(m) ∈Q1b(BQ)
by ⟨4⟩2, ⟨5⟩2
def InvP, Inv, knowsSentInv, msgsOfType, acceptorMsgsOfType, msgs,
1bmsgs, P !sentMsgs, 1bRestrict
⟨5⟩3. qed
by ⟨5⟩1, ⟨5⟩2 def Q1b, SQ
⟨4⟩4.case KnowsSafeAt(ac, b, v)!1!1′
⟨5⟩1. pick BQ ∈ByzQuorum : KnowsSafeAt(ac, b, v)!1!1!(BQ)′
by ⟨4⟩4
⟨5⟩2. ∀a ∈Q(BQ) : ∃m ∈SQ(BQ) : ∧m.acc = a
∧m.mbal = −1
by ⟨5⟩1, Isa def 1bRestrict
⟨5⟩3. ∀m ∈SQ(BQ) : m.mbal = −1
by ⟨4⟩2, ⟨5⟩2
def InvP, Inv, knowsSentInv, msgsOfType, 1bRestrict, 1bInv2
⟨5⟩4. SQ(BQ) = Q1b(BQ)
by ⟨4⟩3, ⟨5⟩1
⟨5⟩5. Q(BQ) ∈Quorum
by def Quorum
⟨5⟩hide def SS, Q, SQ
⟨5⟩witness Q(BQ) ∈Quorum
⟨5⟩6. qed
by ⟨5⟩2, ⟨5⟩3, ⟨5⟩4 def P !ShowsSafeAt
⟨4⟩5.case KnowsSafeAt(ac, b, v)!1!2′
⟨5⟩1. pick c ∈0 . . (b −1) : KnowsSafeAt(ac, b, v)!1!2!(c)′
by ⟨4⟩5
⟨5⟩2. pick BQ ∈ByzQuorum :
∀a ∈BQ : ∃m ∈SS : ∧m.acc = a
∧m.mbal ≤c
∧(m.mbal = c) ⇒(m.mval = v)
by ⟨5⟩1
⟨5⟩3. SQ(BQ) = Q1b(BQ)
by ⟨5⟩2, ⟨4⟩3
⟨5⟩4. P !ShowsSafeAt(Q(BQ), b, v)!1!1
⟨6⟩1. suffices assume new a ∈Q(BQ)
prove ∃m ∈Q1b(BQ) : m.acc = a
obvious
37

--- Page 38 ---
⟨6⟩2. pick m ∈SS : m.acc = a
by ⟨5⟩2
⟨6⟩3. ∧1bRestrict(m) ∈SQ(BQ)
∧1bRestrict(m).acc = a
by ⟨6⟩2 def 1bRestrict
⟨6⟩.qed
by ⟨6⟩3, ⟨5⟩3
⟨5⟩5. pick m1c ∈msgs :
∧m1c = [type 7→“1c”, bal 7→m1c.bal, val 7→v]
∧m1c.bal ≥c
∧m1c.bal ∈Ballot
⟨6⟩1. pick WQ ∈WeakQuorum :
∀a ∈WQ : ∃m ∈SS : ∧m.acc = a
∧∃r ∈m.m2av :
∧r.bal ≥c
∧r.val = v
by ⟨5⟩1
⟨6⟩2. pick a ∈WQ, m ∈SS :
∧a ∈Acceptor
∧m.acc = a
∧∃r ∈m.m2av : ∧r.bal ≥c
∧r.val = v
by ⟨6⟩1, BQA
⟨6⟩4. pick r ∈m.m2av : ∧r.bal ≥c
∧r.val = v
by ⟨6⟩2
⟨6⟩5. ∧m.bal = b
∧m ∈bmsgs
∧m.type = “1b”
∧r.bal ∈Ballot
by ⟨4⟩2, ⟨6⟩2, BMessageLemma
def Inv, InvP, TypeOK, 1bMessage, knowsSentInv, msgsOfType
⟨6⟩.qed
by ⟨6⟩2, ⟨6⟩4, ⟨6⟩5, Zenon def Inv, 1bInv1
⟨5⟩6. assume new m ∈Q1b(BQ)
prove
∧m1c.bal ≥m.mbal
∧(m1c.bal = m.mbal) ⇒(m.mval = v)
⟨6⟩1. pick mm ∈SS : ∧mm.acc = m.acc
∧mm.mbal ≤c
∧(mm.mbal = c) ⇒(mm.mval = v)
by ⟨5⟩2
⟨6⟩2. pick mm2 ∈SS : ∧mm2.acc = m.acc
∧m = 1bRestrict(mm2)
by ⟨5⟩3 def 1bRestrict
⟨6⟩3. ∧mm = mm2
38

--- Page 39 ---
∧mm2.mbal ∈Ballot ∪{ −1}
by ⟨4⟩2, ⟨6⟩1, ⟨6⟩2, BMessageLemma
def Inv, InvP, TypeOK, knowsSentInv, 1bInv2, msgsOfType, 1bMessage
⟨6⟩.qed
⟨7⟩∀m1cbal, mmbal ∈Ballot ∪{ −1} :
mmbal ≤c ∧m1cbal ≥c ⇒∧m1cbal ≥mmbal
∧mmbal = m1cbal ⇒mmbal = c
by def Ballot
⟨7⟩qed
by ⟨5⟩5, ⟨6⟩1, ⟨6⟩2, ⟨6⟩3 def 1bRestrict
⟨5⟩7. P !ShowsSafeAt(Q(BQ), b, v)!1!2!2!(m1c)
by ⟨5⟩5, ⟨5⟩6
⟨5⟩.qed
by ⟨5⟩4, ⟨5⟩7, Isa def P !ShowsSafeAt, Quorum
⟨4⟩6. qed
by ⟨3⟩1, ⟨4⟩1, ⟨4⟩4, ⟨4⟩5 def KnowsSafeAt
⟨3⟩6. qed
by ⟨2⟩6, ⟨3⟩1, ⟨3⟩2, ⟨3⟩3, ⟨3⟩4, Zenon
def LearnsSent, P !Phase1c, P !TLANext, Ballot, P !Ballot, PmaxBal, 1bOr2bMsgs
⟨2⟩7. assume new self ∈Ballot,
Phase1a(self )
prove
P !TLANext ∨P !vars′ = P !vars
⟨3⟩1. msgs′ = msgs ∪{[type 7→“1a”, bal 7→self ]}
by ⟨2⟩7, MsgsLemma def Inv
⟨3⟩2. unchanged ⟨PmaxBal, maxVBal, maxVVal⟩
by ⟨2⟩7, Isa def Phase1a, PmaxBal, 1bOr2bMsgs
⟨3⟩.qed
by ⟨3⟩1, ⟨3⟩2 def P !Phase1a, P !TLANext, Ballot, P !Ballot
⟨2⟩8. assume new self ∈Ballot,
Phase1c(self )
prove
P !TLANext ∨P !vars′ = P !vars
⟨3⟩1. pick SS ∈subset [type : {“1c”}, bal : {self }, val : Value] :
∧∀m ∈SS : ∃a ∈Acceptor : KnowsSafeAt(a, m.bal, m.val)
∧msgs′ = msgs ∪SS
by ⟨2⟩8, MsgsLemma def Inv
⟨3⟩define S
∆= {m.val : m ∈SS}
⟨3⟩2. SS = {[type 7→“1c”, bal 7→self , val 7→v] : v ∈S}
obvious
⟨3⟩3. assume new v ∈S
prove
∃Q ∈Quorum : P !ShowsSafeAt(Q, self , v)
⟨4⟩define m
∆= [type 7→“1c”, bal 7→self , val 7→v]
⟨4⟩1. pick a ∈Acceptor : KnowsSafeAt(a, self , v)
by ⟨3⟩1
⟨4⟩define SK
∆= {mm ∈knowsSent[a] : mm.bal = self }
⟨4⟩2. assume new BQ ∈ByzQuorum,
39

--- Page 40 ---
∀ac ∈BQ : ∃mm ∈SK : mm.acc = ac
prove
P !ShowsSafeAt(BQ ∩Acceptor, self , v)!1!1
⟨5⟩define Q
∆= BQ ∩Acceptor
Q1b
∆= {mm ∈P !sentMsgs(“1b”, self ) : mm.acc ∈Q}
⟨5⟩suffices assume new ac ∈BQ ∩Acceptor
prove
∃mm ∈Q1b : mm.acc = ac
obvious
⟨5⟩1. pick mm ∈SK : mm.acc = ac
by ⟨4⟩2
⟨5⟩2. ∧1bRestrict(mm) ∈P !sentMsgs(“1b”, self )
∧1bRestrict(mm).acc = ac
by ⟨5⟩1 def acceptorMsgsOfType, msgsOfType, 1bmsgs, msgs, Inv, knowsSentInv,
1bRestrict, P !sentMsgs
⟨5⟩.qed
by ⟨5⟩2
⟨4⟩3.case KnowsSafeAt(a, self , v)!1!1
⟨5⟩1. pick BQ ∈ByzQuorum :
∀ac ∈BQ : ∃mm ∈SK : ∧mm.acc = ac
∧mm.mbal = −1
by ⟨4⟩3
⟨5⟩define Q
∆= BQ ∩Acceptor
Q1b
∆= {mm ∈P !sentMsgs(“1b”, self ) : mm.acc ∈Q}
⟨5⟩2. P !ShowsSafeAt(Q, self , v)!1!1
by ⟨5⟩1, ⟨4⟩2
⟨5⟩3. assume new mm ∈Q1b
prove
mm.mbal = −1
by ⟨5⟩1, MsgsTypeLemma
def P !sentMsgs, 1bmsgs, acceptorMsgsOfType, msgsOfType, 1bRestrict,
Inv, knowsSentInv, 1bInv2, 1bRestrict
⟨5⟩.qed
by ⟨5⟩2, ⟨5⟩3, Zenon def P !ShowsSafeAt, Quorum
⟨4⟩4.case KnowsSafeAt(a, self , v)!1!2
⟨5⟩1. pick c ∈0 . . (self −1) : KnowsSafeAt(a, self , v)!1!2!(c)
by ⟨4⟩4
⟨5⟩2. pick BQ ∈ByzQuorum : KnowsSafeAt(a, self , v)!1!2!(c)!1!(BQ)
by ⟨5⟩1
⟨5⟩define Q
∆= BQ ∩Acceptor
Q1b
∆= {mm ∈P !sentMsgs(“1b”, self ) : mm.acc ∈Q}
⟨5⟩3. P !ShowsSafeAt(Q, self , v)!1!1
by ⟨5⟩2, ⟨4⟩2
⟨5⟩4. pick WQ ∈WeakQuorum : KnowsSafeAt(a, self , v)!1!2!(c)!2!(WQ)
by ⟨5⟩1
⟨5⟩5. pick ac ∈WQ ∩Acceptor :
KnowsSafeAt(a, self , v)!1!2!(c)!2!(WQ)!(ac)
by ⟨5⟩4, BQA
40

--- Page 41 ---
⟨5⟩6. pick mk ∈SK : ∧mk.acc = ac
∧∃r ∈mk.m2av : ∧r.bal ≥c
∧r.val = v
by ⟨5⟩5
⟨5⟩7. pick r ∈mk.m2av : ∧r.bal ≥c
∧r.val = v
by ⟨5⟩6
⟨5⟩define mc
∆= [type 7→“1c”, bal 7→r.bal, val 7→v]
⟨5⟩9. mc ∈msgs
by ⟨5⟩6, ⟨5⟩7 def Inv, 1bInv1, knowsSentInv, msgsOfType
⟨5⟩10. assume new mq ∈Q1b
prove
∧mc.bal ≥mq.mbal
∧(mc.bal = mq.mbal) ⇒(mq.mval = v)
by ⟨5⟩2, ⟨5⟩7, MsgsTypeLemma, BMessageLemma
def P !sentMsgs, 1bmsgs, acceptorMsgsOfType, msgsOfType, 1bRestrict,
Inv, TypeOK, 1bInv2, knowsSentInv, 1bMessage, Ballot
⟨5⟩11. qed
⟨6⟩Q ∈Quorum
by def Quorum
⟨6⟩witness Q ∈Quorum
⟨6⟩qed
by ⟨5⟩3, ⟨5⟩9, ⟨5⟩10 def P !ShowsSafeAt
⟨4⟩5. qed
by ⟨4⟩1, ⟨4⟩3, ⟨4⟩4 def KnowsSafeAt
⟨3⟩.qed
by ⟨2⟩8, ⟨3⟩1, ⟨3⟩2, ⟨3⟩3, Zenon
def P !Phase1c, Phase1c, PmaxBal, 1bOr2bMsgs, P !TLANext, Ballot, P !Ballot
⟨2⟩9. assume new self ∈FakeAcceptor,
FakingAcceptor(self )
prove
P !TLANext ∨P !vars′ = P !vars
⟨3⟩1. msgs′ = msgs
by ⟨2⟩9, MsgsLemma def Inv
⟨3⟩2. PmaxBal′ = PmaxBal
by ⟨2⟩9, BQA, Zenon def FakingAcceptor, PmaxBal, 1bOr2bMsgs
⟨3⟩.qed
by ⟨2⟩9, ⟨3⟩1, ⟨3⟩2 def P !vars, FakingAcceptor
⟨2⟩10. qed
by ⟨2⟩3, ⟨2⟩4, ⟨2⟩5, ⟨2⟩6, ⟨2⟩7, ⟨2⟩8, ⟨2⟩9, NextDef
⟨1⟩3. qed
by ⟨1⟩1, ⟨1⟩2, Invariance, PTL def Spec, P !Spec
To see how learning is implemented, we must describe how to determine that a value has been
chosen. This is done by the following deﬁnition of chosen to be the set of chosen values.
41

--- Page 42 ---
chosen
∆= {v ∈Value : ∃BQ ∈ByzQuorum, b ∈Ballot :
∀a ∈BQ : ∃m ∈msgs : ∧m.type = “2b”
∧m.acc = a
∧m.bal
= b
∧m.val
= v}
The correctness of our deﬁnition of chosen is expressed by the following theorem, which asserts
that if a value is in chosen , then it is also in the set chosen of the emulated execution of the
PCon algorithm.
The state function chosen does not necessarily equal the corresponding state function of the PCon
algorithm. It requires every (real or fake) acceptor in a ByzQuorum to vote for (send 2b messages)
for a value v in the same ballot for v to be in chosen for the BPCon algorithm, but it requires
only that every (real) acceptor in a Quorum vote for v in the same ballot for v to be in the set
chosen of the emulated execution of algorithm PCon.
Liveness for BPCon requires that, under suitable assumptions, some value is eventually in chosen
. Since we can’t assume that a fake acceptor does anything useful, liveness requires the assumption
that there is a ByzQuorum composed entirely of real acceptors (the ﬁrst conjunct of assumption
BQLA).
theorem chosen ⊆P !chosen
by Isa def chosen, P !chosen, Quorum, Ballot, P !Ballot
\ * Modiﬁcation History
\ * Last modiﬁed Fri Jul 24 17:51:34 CEST 2020 by merz
\ * Last modiﬁed Wed Apr 15 15:16:26 CEST 2020 by doligez
\ * Last modiﬁed Mon Aug 18 14:57:27 CEST 2014 by tomer
\ * Last modiﬁed Mon Mar 04 17:24:05 CET 2013 by doligez
\ * Last modiﬁed Wed Nov 30 15:47:26 PST 2011 by lamport
\ * Last modiﬁed Wed Dec 01 11:35:29 PST 2010 by lamport
42
