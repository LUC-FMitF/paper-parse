
--- Page 1 ---
module Consensus
The consensus problem requires a set of processes to choose a single value. This module speciﬁes
the problem by specifying exactly what the requirements are for choosing a value.
extends Naturals, FiniteSets, FiniteSetTheorems, TLAPS
We let the constant parameter Value be the set of all values that can be chosen.
constant Value
***************************************************************************
We now specify the safety property of consensus as a trivial algorithm that describes the allowed
behaviors of a consensus algorithm. It uses the variable chosen to represent the set of all chosen
values. The algorithm is trivial; it allows only behaviors that contain a single state-change in
which the variable chosen is changed from its initial value {} to the value {v} for an arbitrary
value v in Value. The algorithm itself does not specify any fairness properties, so it also allows a
behavior in which chosen is not changed. We could use a translator option to have the translation
include a fairness requirement, but we don’t bother because it is easy enough to add it by hand
to the safety speciﬁcation that the translator produces.
A real speciﬁcation of consensus would also include additional variables and actions. In particular,
it would have Propose actions in which clients propose values and Learn actions in which clients
learn what value has been chosen. It would allow only a proposed value to be chosen. However,
the interesting part of a consensus algorithm is the choosing of a single value. We therefore restrict
our attention to that aspect of consensus algorithms. In practice, given the algorithm for choosing
a value, it is obvious how to implement the Propose and Learn actions.
For convenience, we deﬁne the macro Choose() that describes the action of changing the value of
chosen from {} to {v}, for a nondeterministically chosen v in the set Value. (There is little reason
to encapsulate such a simple action in a macro; however our other specs are easier to read when
written with such macros, so we start using them now.) The when statement can be executed only
when its condition, chosen = {}, is true. Hence, at most one Choose() action can be performed
in any execution. The with statement executes its body for a nondeterministically chosen v in
Value. Execution of this statement is enabled only if Value is non-empty–something we do not
assume at this point because it is not required for the safety part of consensus, which is satisﬁed
if no value is chosen.
We put the Choose() action inside a while statement that loops forever. Of course, only a single
Choose() action can be executed. The algorithm stops after executing a Choose() action. Techni-
cally, the algorithm deadlocks after executing a Choose() action because control is at a statement
whose execution is never enabled. Formally, termination is simply deadlock that we want to hap-
pen. We could just as well have omitted the while and let the algorithm terminate. However,
adding the while loop makes the TLA+ representation of the algorithm a tiny bit simpler.
--algorithm Consensus{
variable chosen = {} ;
macro Choose( ) { when chosen = {} ;
with ( v ∈Value ) { chosen := {v} } }
{ lbl : while ( true ) { Choose() }
}
}
The PlusCal translator writes the TLA+ translation of this algorithm below. The formula Spec is
the TLA+ speciﬁcation described by the algorithm’s code. For now, you should just understand
its two subformulas Init and Next. Formula Init is the initial predicate and describes all possible
initial states of an execution. Formula Next is the next-state relation; it describes the possible
state changes (changes of the values of variables), where unprimed variables represent their values
in the old state and primed variables represent their values in the new state.
1

--- Page 2 ---
****************************************************************************
**** BEGIN TRANSLATION
variable chosen
vars
∆= ⟨chosen⟩
Init
∆=
Global variables
∧chosen = {}
Next
∆= ∧chosen = {}
∧∃v ∈Value :
chosen′ = {v}
Spec
∆= Init ∧2[Next]vars
**** END TRANSLATION
We now prove the safety property that at most one value is chosen. We ﬁrst deﬁne the type-
correctness invariant TypeOK, and then deﬁne Inv to be the inductive invariant that asserts
TypeOK and that the cardinality of the set chosen is at most 1. We then prove that, in any
behavior satisfying the safety speciﬁcation Spec, the invariant Inv is true in all states. This means
that at most one value is chosen in any behavior.
TypeOK
∆= ∧chosen ⊆Value
∧IsFiniteSet(chosen)
Inv
∆= ∧TypeOK
∧Cardinality(chosen) ≤1
We now prove that Inv is an invariant, meaning that it is true in every state in every behavior.
Before trying to prove it, we should ﬁrst use TLC to check that it is true. It’s hardly worth
bothering to either check or prove the obvious fact that Inv is an invariant, but it’s a nice tiny
exercise. Model checking is instantaneous when Value is set to any small ﬁnite set.
To understand the following proof, you need to understand the formula Spec , which equals
Init ∧2[Next] vars
where vars is the tuple ⟨chosen, pc⟩of all variables.
It is a temporal formula satisﬁed by a
behavior iﬀthe behavior starts in a state satisfying Init and such that each step (sequence of
states) satisﬁes [Next] vars, which equals
Next ∨(vars′ = vars)
Thus, each step satisﬁes either Next (so it is a step allowed by the next-state relation) or it is
a “stuttering step” that leaves all the variables unchanged. The reason why a spec must allow
stuttering steps will become apparent when we prove that a consensus algorithm satisﬁes this
speciﬁcation of consensus.
The following lemma asserts that Inv is an inductive invariant of the next-state action Next. It is
the key step in proving that Inv is an invariant of (true in every behavior allowed by) speciﬁcation
Spec.
lemma InductiveInvariance
∆=
Inv ∧[Next]vars ⇒Inv ′
2

--- Page 3 ---
⟨1⟩.suffices assume Inv, [Next]vars
prove
Inv ′
obvious
⟨1⟩1.case Next
In the following by proof, ⟨1⟩1 denotes the case assumption Next
by ⟨1⟩1, FS EmptySet, FS AddElement def Inv, TypeOK, Next
⟨1⟩2.case vars′ = vars
by ⟨1⟩2 def Inv, TypeOK, vars
⟨1⟩3. qed
by ⟨1⟩1, ⟨1⟩2 def Next
theorem Invariance
∆= Spec ⇒2Inv
⟨1⟩1. Init ⇒Inv
by FS EmptySet def Init, Inv, TypeOK
⟨1⟩2. qed
by PTL, ⟨1⟩1, InductiveInvariance def Spec
We now deﬁne LiveSpec to be the algorithm’s speciﬁcation with the added fairness condition of
weak fairness of the next-state relation, which asserts that execution does not stop if some action
is enabled. The temporal formula Success asserts that some value is eventually chosen. Below,
we prove that LiveSpec implies Success This means that, in every behavior satisfying LiveSpec,
some value is chosen.
LiveSpec
∆= Spec ∧WFvars(Next)
Success
∆= 3(chosen ̸= {})
For liveness, we need to assume that there exists at least one value.
assume ValueNonempty
∆= Value ̸= {}
TLAPS does not yet reason about enabled . Therefore, we must omit all proofs that involve
enabled formulas. To perform as much of the proof as possible, as much as possible we restrict
the use of an enabled expression to a step asserting that it equals its deﬁnition. enabled A is
true of a state s iﬀthere is a state t such that the step s →t satisﬁes A. It follows from this
semantic deﬁnition that ENABLED A equals the formula obtained by
1. Expanding all deﬁnitions of deﬁned symbols in A until all primes are priming variables.
2. For each primed variable, replacing every instance of that primed variable by a new symbol
(the same symbol for each primed variable).
3. Existentially quantifying over those new symbols.
lemma EnabledDef
∆=
TypeOK ⇒
((enabled ⟨Next⟩vars) ≡(chosen = {}))
⟨1⟩define E
∆=
∃chosenp :
∧∧chosen = {}
∧∃v ∈Value : chosenp = {v}
∧¬(⟨chosenp⟩= ⟨chosen⟩)
3

--- Page 4 ---
⟨1⟩1. E = enabled ⟨Next⟩vars
by
def Next, vars
proof omitted
⟨1⟩2. suffices assume TypeOK
prove
E = (chosen = {})
by ⟨1⟩1, Zenon
⟨1⟩3. E = ∃chosenp : E !(chosenp)!1
by ⟨1⟩2, Isa
def TypeOK
⟨1⟩4. @ = (chosen = {})
by ⟨1⟩2, ValueNonempty, Zenon def TypeOK
⟨1⟩5. qed
by ⟨1⟩3, ⟨1⟩4, Zenon
Here is our proof that Livespec implies Success.
It uses the standard TLA proof rules.
For
example RuleWF1 is deﬁned in the TLAPS module to be the rule WF1 discussed in
AUTHOR
= "Leslie Lamport",
TITLE
= "The Temporal Logic of Actions",
JOURNAL = toplas,
volume
= 16,
number
= 3,
YEAR
= 1994,
month
= may,
PAGES
= "872--923"
PTL stands for propositional temporal logic reasoning. We expect that, when TLAPS handles
temporal reasoning, it will use a decision procedure for PTL.
theorem LiveSpec ⇒Success
⟨1⟩1.2Inv ∧2[Next]vars ∧WFvars(Next) ⇒(chosen = {} ; chosen ̸= {})
⟨2⟩.define P
∆= chosen = {}
Q
∆= chosen ̸= {}
⟨2⟩1. suffices 2[Next]vars ∧WFvars(Next) ⇒((Inv ∧P) ; Q)
by PTL
⟨2⟩2. (Inv ∧P) ∧[Next]vars ⇒((Inv ′ ∧P′) ∨Q′)
by InductiveInvariance
⟨2⟩3. (Inv ∧P) ∧⟨Next⟩vars ⇒Q′
by def Inv, Next, vars
⟨2⟩4. (Inv ∧P) ⇒enabled ⟨Next⟩vars
by EnabledDef def Inv
⟨2⟩.hide def P, Q
⟨2⟩.qed
by ⟨2⟩2, ⟨2⟩3, ⟨2⟩4, PTL
⟨1⟩2. (chosen = {} ; chosen ̸= {}) ⇒((chosen = {}) ⇒3(chosen ̸= {}))
by PTL
⟨1⟩3. qed
by Invariance, ⟨1⟩1, ⟨1⟩2, PTL def LiveSpec, Spec, Init, Success
The following theorem is used in the reﬁnement proof in module VoteProof .
4

--- Page 5 ---
theorem LiveSpecEquals
∆=
LiveSpec ≡Spec ∧(23⟨Next⟩vars ∨23(chosen ̸= {}))
⟨1⟩1. ∧Spec ≡Spec ∧2TypeOK
∧LiveSpec ≡LiveSpec ∧2TypeOK
by Invariance, PTL def LiveSpec, Inv
⟨1⟩2. (chosen ̸= {}) ≡¬(chosen = {})
obvious
⟨1⟩3.2TypeOK ⇒((23¬enabled ⟨Next⟩vars) ≡23(chosen ̸= {}))
by ⟨1⟩2, EnabledDef , PTL
⟨1⟩4. qed
by ⟨1⟩1, ⟨1⟩3, PTL def LiveSpec
\ * Modiﬁcation History
\ * Last modiﬁed Mon May 11 18:36:27 CEST 2020 by merz
\ * Last modiﬁed Mon Aug 18 15:00:45 CEST 2014 by tomer
\ * Last modiﬁed Mon Aug 18 14:58:57 CEST 2014 by tomer
\ * Last modiﬁed Tue Feb 14 13:35:49 PST 2012 by lamport
\ * Last modiﬁed Mon Feb 07 14:46:59 PST 2011 by lamport
5
