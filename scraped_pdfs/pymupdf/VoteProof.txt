
--- Page 1 ---
module VoteProof
This is a high-level consensus algorithm in which a set of processes called acceptors cooperatively
choose a value. The algorithm uses numbered ballots, where a ballot is a round of voting. Ac-
ceptors cast votes in ballots, casting at most one vote per ballot. A value is chosen when a large
enough set of acceptors, called a quorum , have all voted for the same value in the same ballot.
Ballots are not executed in order. Diﬀerent acceptors may be concurrently performing actions for
diﬀerent ballots.
extends Integers, NaturalsInduction, FiniteSets, FiniteSetTheorems,
WellFoundedInduction, TLC, TLAPS
constant Value,
As in module Consensus, the set of choosable values.
Acceptor,
The set of all acceptors.
Quorum
The set of all quorums.
The following assumption asserts that a quorum is a set of acceptors, and the fundamental as-
sumption we make about quorums: any two quorums have a non-empty intersection.
assume QA
∆= ∧∀Q ∈Quorum : Q ⊆Acceptor
∧∀Q1, Q2 ∈Quorum : Q1 ∩Q2 ̸= {}
theorem QuorumNonEmpty
∆= ∀Q ∈Quorum : Q ̸= {}
proof by QA
Ballot is the set of all ballot numbers. For simplicity, we let it be the set of natural numbers.
However, we write Ballot for that set to make it clear what the function of those natural numbers
are.
The algorithm and its reﬁnements work with Ballot any set with minimal element 0, −1 not an
element of Ballot, and a well-founded total order < on Ballot ∪{−1} with minimal element −1,
and 0 < b for all non-zero b in Ballot. In the proof, any set of the form i . . j must be replaced
by the set of all elements b in Ballot ∪{ −1} with i ≤b ≤j, and i . . (j −1) by the set of such b
with i ≤b < j.
Ballot
∆= Nat
In the algorithm, each acceptor can cast one or more votes, where each vote cast by an acceptor
has the form ⟨b, v⟩indicating that the acceptor has voted for value v in ballot b. A value is chosen
if a quorum of acceptors have voted for it in the same ballot.
The algorithm uses two variables, votes and maxBal , both arrays indexed by acceptor. Their
meanings are:
votes[a] −The set of votes cast by acceptor a .
maxBal[a] −The number of the highest-numbered ballot in which a has cast a vote, or −1 if
it has not yet voted.
The algorithm does not let acceptor a vote in any ballot less than maxBal[a].
1

--- Page 2 ---
We specify our algorithm by the following PlusCal algorithm. The speciﬁcation Spec deﬁned by
this algorithm describes only the safety properties of the algorithm. In other words, it speciﬁes
what steps the algorithm may take. It does not require that any (non-stuttering) steps be taken.
We prove that this speciﬁcation Spec implements the speciﬁcation Spec of module Consensus under
a reﬁnement mapping deﬁned below. This shows that the safety properties of the voting algorithm
(and hence the algorithm with additional liveness requirements) imply the safety properties of the
Consensus speciﬁcation. Liveness is discussed later.
**************************
--algorithm Voting{
variables votes = [a ∈Acceptor 7→{}],
maxBal = [a ∈Acceptor 7→−1] ;
deﬁne {
We now deﬁne the operator SafeAt so SafeAt(b, v) is function of the state that equals true if
no value other than v has been chosen or can ever be chosen in the future (because the values
of the variables votes and maxBal are such that the algorithm does not allow enough acceptors
to vote for it). We say that value v is safe at ballot number b iﬀSafe(b, v) is true. We deﬁne
Safe in terms of the following two operators.
Note: This deﬁnition is weaker than would be necessary to allow a reﬁnement of ordinary
Paxos consensus, since it allows diﬀerent quorums to “cooperate” in determining safety at b.
This is used in algorithms like Vertical Paxos that are designed to allow reconﬁguration within
a single consensus instance, but not in ordinary Paxos. See
AUTHOR = “Leslie Lamport and Dahlia Malkhi and Lidong Zhou ”,
TITLE
= “Vertical Paxos and Primary-Backup Replication”,
Journal = “ACM SIGACT News (Distributed Computing Column)”,
editor = {Srikanta Tirthapura and Lorenzo Alvisi},
booktitle = {PODC},
publisher = {ACM }, YEAR = 2009, PAGES = “312–313”
VotedFor(a, b, v)
∆= ⟨b, v⟩∈votes[a]
True iﬀacceptor a has voted for v in ballot b.
DidNotVoteIn(a, b)
∆= ∀v ∈Value : ¬VotedFor(a, b, v)
We now deﬁne SafeAt. We deﬁne it recursively. The nicest deﬁnition is
recursive SafeAt( ,
)
SafeAt(b, v)
∆=
∨b = 0
∨∃Q ∈Quorum :
∧∀a ∈Q : maxBal[a] ≥b
∧∃c ∈−1 . . (b −1) :
∧(c ̸= −1) ⇒∧SafeAt(c, v)
∧∀a ∈Q : ∀w ∈Value :
VotedFor(a, c, w) ⇒(w = v)
∧∀d ∈(c + 1) . . (b −1), a ∈Q : DidNotVoteIn(a, d)
However, TLAPS does not currently support recursive operator deﬁnitions.
We therefore
deﬁne it as follows using a recursive function deﬁnition.
SafeAt(b, v)
∆=
let SA[bb ∈Ballot]
∆=
2

--- Page 3 ---
This recursively deﬁnes SA[bb] to equal SafeAt(bb, v).
∨bb = 0
∨∃Q ∈Quorum :
∧∀a ∈Q
: maxBal[a] ≥bb
∧∃c ∈−1 . . (bb −1) :
∧(c ̸= −1) ⇒∧SA[c]
∧∀a ∈Q :
∀w ∈Value :
VotedFor(a, c, w) ⇒(w = v)
∧∀d ∈(c + 1) . . (bb −1), a ∈Q : DidNotVoteIn(a, d)
in
SA[b]
}
There are two possible actions that an acceptor can perform, each deﬁned by a macro. In these
macros, self is the acceptor that is to perform the action. The ﬁrst action, IncreaseMaxBal(b)
allows acceptor self to set maxBal[self ] to b if b is greater than the current value of maxBal[self ].
macro IncreaseMaxBal( b ) {
when b > maxBal[self ] ;
maxBal[self ] := b
}
Action VoteFor(b, v) allows acceptor self to vote for value v in ballot b if its when condition
is satisﬁed.
macro VoteFor( b, v ) {
when ∧maxBal[self ] ≤b
∧DidNotVoteIn(self , b)
∧∀p ∈Acceptor \ {self } :
∀w ∈Value : VotedFor(p, b, w) ⇒(w = v)
∧SafeAt(b, v) ;
votes[self ]
:= votes[self ] ∪{⟨b, v⟩} ;
maxBal[self ] := b
}
The following process declaration asserts that every process self in the set Acceptor exe-
cutes its body, which loops forever nondeterministically choosing a Ballot b and executing
either an IncreaseMaxBal(b) action or nondeterministically choosing a value v and executing
a VoteFor(b, v) action. The single label indicates that an entire execution of the body of the
while loop is performed as a single atomic action.
From this intuitive description of the process declaration, one might think that a process could
be deadlocked by choosing a ballot b in which neither an IncreaseMaxBal(b) action nor any
VoteFor(b, v) action is enabled. An examination of the TLA+ translation (and an elementary
knowledge of the meaning of existential quantiﬁcation) shows that this is not the case. You can
think of all possible choices of b and of v being examined simultaneously, and one of the choices
for which a step is possible being made.
process ( acceptor ∈Acceptor ) {
acc :
while ( true ) {
with ( b ∈Ballot ) {
3

--- Page 4 ---
either IncreaseMaxBal(b)
or
with ( v ∈Value ) { VoteFor(b, v) }
}
}
}
}
The following is the TLA+ speciﬁcation produced by the translation. Blank lines, produced by
the translation because of the comments, have been deleted.
***************************
BEGIN TRANSLATION
variables votes, maxBal
deﬁne statement
VotedFor(a, b, v)
∆= ⟨b, v⟩∈votes[a]
DidNotVoteIn(a, b)
∆= ∀v ∈Value : ¬VotedFor(a, b, v)
SafeAt(b, v)
∆=
let SA[bb ∈Ballot]
∆=
∨bb = 0
∨∃Q ∈Quorum :
∧∀a ∈Q
: maxBal[a] ≥bb
∧∃c ∈−1 . . (bb −1) :
∧(c ̸= −1) ⇒∧SA[c]
∧∀a ∈Q :
∀w ∈Value :
VotedFor(a, c, w) ⇒(w = v)
∧∀d ∈(c + 1) . . (bb −1), a ∈Q : DidNotVoteIn(a, d)
in
SA[b]
vars
∆= ⟨votes, maxBal⟩
ProcSet
∆= (Acceptor)
Init
∆=
Global variables
∧votes = [a ∈Acceptor 7→{}]
∧maxBal = [a ∈Acceptor 7→−1]
acceptor(self )
∆= ∃b
∈Ballot :
∨∧b > maxBal[self ]
∧maxBal′ = [maxBal except ![self ] = b]
∧unchanged votes
∨∧∃v ∈Value :
∧∧maxBal[self ] ≤b
∧DidNotVoteIn(self , b)
∧∀p ∈Acceptor \ {self } :
∀w ∈Value : VotedFor(p, b, w) ⇒(w = v)
4

--- Page 5 ---
∧SafeAt(b, v)
∧votes′ = [votes except ![self ] = votes[self ] ∪{⟨b, v⟩}]
∧maxBal′ = [maxBal except ![self ] = b]
Next
∆= (∃self ∈Acceptor : acceptor(self ))
Spec
∆= Init ∧2[Next]vars
END TRANSLATION
To reason about a recursively-deﬁned operator, one must prove a theorem about it. In particular,
to reason about SafeAt, we need to prove that SafeAt(b, v) equals the right-hand side of its
deﬁnition, for b ∈Ballot and v ∈Value. This is not automatically true for a recursive deﬁnition.
For example, from the recursive deﬁnition
Silly[n ∈Nat]
∆= choose v : v ̸= Silly[n]
we cannot deduce that
Silly[42] = choose v : v ̸= Silly[42]
(From that, we could easily deduce Silly[42] ̸= Silly[42].)
Here is the theorem that essentially asserts that SafeAt(b, v) equals the right-hand side of its
deﬁnition.
theorem SafeAtProp
∆=
∀b ∈Ballot, v ∈Value :
SafeAt(b, v) ≡
∨b = 0
∨∃Q ∈Quorum :
∧∀a ∈Q
: maxBal[a] ≥b
∧∃c ∈−1 . . (b −1) :
∧(c ̸= −1) ⇒∧SafeAt(c, v)
∧∀a ∈Q :
∀w ∈Value :
VotedFor(a, c, w) ⇒(w = v)
∧∀d ∈(c + 1) . . (b −1), a ∈Q : DidNotVoteIn(a, d)
⟨1⟩1. suffices assume new v ∈Value
prove
∀b ∈Ballot : SafeAtProp !(b, v)
by Zenon
⟨1⟩use def Ballot
⟨1⟩define Def (SA, bb)
∆=
∨
bb = 0
∨
∃Q ∈Quorum :
∧∀a ∈Q
: maxBal[a] ≥bb
∧∃c ∈−1 . . (bb −1) :
∧(c ̸= −1) ⇒∧SA[c]
∧∀a ∈Q :
∀w ∈Value :
5

--- Page 6 ---
VotedFor(a, c, w) ⇒(w = v)
∧∀d ∈(c + 1) . . (bb −1), a ∈Q : DidNotVoteIn(a, d)
SA[bb ∈Ballot]
∆= Def (SA, bb)
⟨1⟩2. ∀b : SafeAt(b, v) = SA[b]
by def SafeAt
⟨1⟩3. assume new n ∈Nat, new g, new h,
∀i ∈0 . . (n −1) : g[i] = h[i]
prove
Def (g, n) = Def (h, n)
by ⟨1⟩3
⟨1⟩4. SA = [b ∈Ballot 7→Def (SA, b)]
⟨2⟩hide def Def
⟨2⟩qed
by ⟨1⟩3, RecursiveFcnOfNat, Isa
⟨1⟩5. ∀b ∈Ballot : SA[b] = Def (SA, b)
⟨2⟩hide def Def
⟨2⟩qed
by ⟨1⟩4, Zenon
⟨1⟩6. qed
by ⟨1⟩2, ⟨1⟩5, Zenon def SafeAt
We now deﬁne TypeOK to be the type-correctness invariant.
TypeOK
∆= ∧votes ∈[Acceptor →subset (Ballot × Value)]
∧maxBal ∈[Acceptor →Ballot ∪{ −1}]
We now deﬁne chosen to be the state function so that the algorithm speciﬁed by formula Spec
conjoined with the liveness requirements described below implements the algorithm of module
Consensus (satisﬁes the speciﬁcation LiveSpec of that module) under a reﬁnement mapping that
substitutes this state function chosen for the variable chosen of module Consensus. The deﬁnition
uses the following one, which deﬁnes ChosenIn(b, v) to be true iﬀa quorum of acceptors have all
voted for v in ballot b.
ChosenIn(b, v)
∆= ∃Q ∈Quorum : ∀a ∈Q : VotedFor(a, b, v)
chosen
∆= {v ∈Value : ∃b ∈Ballot : ChosenIn(b, v)}
The following lemma is used for reasoning about the operator SafeAt. It is proved from SafeAtProp
by induction.
lemma SafeLemma
∆=
TypeOK ⇒
∀b ∈Ballot :
∀v ∈Value :
SafeAt(b, v) ⇒
∀c ∈0 . . (b −1) :
∃Q ∈Quorum :
∀a ∈Q : ∧maxBal[a] ≥c
∧∨DidNotVoteIn(a, c)
6

--- Page 7 ---
∨VotedFor(a, c, v)
⟨1⟩suffices assume TypeOK
prove
SafeLemma !2
obvious
⟨1⟩define P(b)
∆= ∀c ∈0 . . b : SafeLemma !2!(c)
⟨1⟩use def Ballot
⟨1⟩1. P(0)
obvious
⟨1⟩2. assume new b ∈Ballot, P(b)
prove
P(b + 1)
⟨2⟩1. ∧b + 1 ∈Ballot \ {0}
∧(b + 1) −1 = b
obvious
⟨2⟩2. 0 . . (b + 1) = (0 . . b) ∪{b + 1}
obvious
⟨2⟩3. suffices assume new v ∈Value,
SafeAt(b + 1, v),
new c ∈0 . . b
prove
∃Q ∈Quorum :
∀a ∈Q : ∧maxBal[a] ≥c
∧∨DidNotVoteIn(a, c)
∨VotedFor(a, c, v)
by ⟨1⟩2
⟨2⟩4. pick Q ∈Quorum :
∧∀a ∈Q : maxBal[a] ≥(b + 1)
∧∃cc ∈−1 . . b :
∧(cc ̸= −1) ⇒∧SafeAt(cc, v)
∧∀a ∈Q :
∀w ∈Value :
VotedFor(a, cc, w) ⇒(w = v)
∧∀d ∈(cc + 1) . . b, a ∈Q : DidNotVoteIn(a, d)
by SafeAtProp, ⟨2⟩3, ⟨2⟩1, Zenon
⟨2⟩5. pick cc ∈−1 . . b :
∧(cc ̸= −1) ⇒∧SafeAt(cc, v)
∧∀a ∈Q :
∀w ∈Value :
VotedFor(a, cc, w) ⇒(w = v)
∧∀d ∈(cc + 1) . . b, a ∈Q : DidNotVoteIn(a, d)
by ⟨2⟩4
⟨2⟩6.case c > cc
by ⟨2⟩4, ⟨2⟩5, ⟨2⟩6, QA def TypeOK
⟨2⟩7.case c = cc
⟨3⟩2. ∀a
∈Q : maxBal[a] ∈Ballot ∪{ −1}
by QA def TypeOK
⟨3⟩3. ∀a ∈Q : maxBal[a] ≥c
7

--- Page 8 ---
by ⟨2⟩4, ⟨2⟩7, ⟨3⟩2
⟨3⟩4. ∀a ∈Q : ∨DidNotVoteIn(a, c)
∨VotedFor(a, c, v)
by ⟨2⟩7, ⟨2⟩5 def DidNotVoteIn
⟨3⟩5. qed
by ⟨3⟩3, ⟨3⟩4
⟨2⟩8.case c < cc
by ⟨2⟩8, ⟨1⟩2, ⟨2⟩5
⟨2⟩9. qed
by ⟨2⟩6, ⟨2⟩7, ⟨2⟩8
⟨1⟩3. ∀b ∈Ballot : P(b)
by ⟨1⟩1, ⟨1⟩2, NatInduction, Isa
⟨1⟩4. qed
by ⟨1⟩3
We now deﬁne the invariant that is used to prove the correctness of our algorithm–meaning
that speciﬁcation Spec implements speciﬁcation Spec of module Consensus under our reﬁnement
mapping. Correctness of the voting algorithm follows from the the following three invariants:
VInv1: In any ballot, an acceptor can vote for at most one value.
VInv2: An acceptor can vote for a value v in ballot b iﬀv is safe at b.
VInv3: Two diﬀerent acceptors cannot vote for diﬀerent values in the same ballot.
Their precise deﬁnitions are as follows.
VInv1
∆= ∀a ∈Acceptor, b ∈Ballot, v, w ∈Value :
VotedFor(a, b, v) ∧VotedFor(a, b, w) ⇒(v = w)
VInv2
∆= ∀a ∈Acceptor, b ∈Ballot, v ∈Value :
VotedFor(a, b, v) ⇒SafeAt(b, v)
VInv3
∆=
∀a1, a2 ∈Acceptor, b ∈Ballot, v1, v2 ∈Value :
VotedFor(a1, b, v1) ∧VotedFor(a2, b, v2) ⇒(v1 = v2)
It is obvious, that VInv3 implies VInv1–a fact that we now let TLAPS prove as a little check that
we haven’t made a mistake in our deﬁnitions. (Actually, we used TLC to check everything before
attempting any proofs.) We deﬁne VInv1 separately because VInv3 is not needed for proving
safety, only for liveness.
theorem VInv3 ⇒VInv1
by def VInv1, VInv3
The following lemma proves that SafeAt(b, v) implies that no value other than v can have been
chosen in any ballot numbered less than b. The fact that it also implies that no value other than v
can ever be chosen in the future follows from this and the fact that SafeAt(b, v) is stable–meaning
that once it becomes true, it remains true forever. The stability of SafeAt(b, v) is proved as step
⟨1⟩6 of theorem InductiveInvariance below.
This lemma is used only in the proof of theorem VT1 below.
lemma VT0
∆= ∧TypeOK
8

--- Page 9 ---
∧VInv1
∧VInv2
⇒∀v, w ∈Value, b, c ∈Ballot :
(b > c) ∧SafeAt(b, v) ∧ChosenIn(c, w) ⇒(v = w)
⟨1⟩suffices assume TypeOK, VInv1, VInv2,
new v ∈Value, new w ∈Value
prove
∀b, c ∈Ballot :
(b > c) ∧SafeAt(b, v) ∧ChosenIn(c, w) ⇒(v = w)
obvious
⟨1⟩P(b)
∆= ∀c ∈Ballot :
(b > c) ∧SafeAt(b, v) ∧ChosenIn(c, w) ⇒(v = w)
⟨1⟩use def Ballot
⟨1⟩1. P(0)
obvious
⟨1⟩2. assume new b ∈Ballot, ∀i ∈0 . . (b −1) : P(i)
prove
P(b)
⟨2⟩1.case b = 0
by ⟨2⟩1
⟨2⟩2.case b ̸= 0
⟨3⟩1. suffices assume new c ∈Ballot, b > c, SafeAt(b, v), ChosenIn(c, w)
prove
v = w
obvious
⟨3⟩2. pick Q ∈Quorum : ∀a ∈Q : VotedFor(a, c, w)
by ⟨3⟩1 def ChosenIn
⟨3⟩3. pick QQ ∈Quorum,
d
∈−1 . . (b −1) :
∧(d ̸= −1) ⇒∧SafeAt(d, v)
∧∀a ∈QQ :
∀x ∈Value :
VotedFor(a, d, x) ⇒(x = v)
∧∀e ∈(d + 1) . . (b −1), a ∈QQ : DidNotVoteIn(a, e)
by ⟨2⟩2, ⟨3⟩1, SafeAtProp, Zenon
⟨3⟩pick aa ∈QQ ∩Q : true
by QA
⟨3⟩4. c ≤d
by ⟨3⟩1, ⟨3⟩2, ⟨3⟩3 def DidNotVoteIn
⟨3⟩5.case c = d
by ⟨3⟩2, ⟨3⟩3, ⟨3⟩4, ⟨3⟩5
⟨3⟩6.case d > c
by ⟨1⟩2, ⟨3⟩1, ⟨3⟩3, ⟨3⟩4, ⟨3⟩6
⟨3⟩7. qed
by ⟨3⟩4, ⟨3⟩5, ⟨3⟩6
⟨2⟩.qed by ⟨2⟩1, ⟨2⟩2
⟨1⟩3. ∀b ∈Ballot : P(b)
9

--- Page 10 ---
⟨2⟩.hide def P
⟨2⟩.qed by ⟨1⟩2, GeneralNatInduction, Isa
⟨1⟩4. qed
by ⟨1⟩3
The following theorem asserts that the invariance of TypeOK, VInv1, and VInv2 implies that the
algorithm satisﬁes the basic consensus property that at most one value is chosen (at any time).
If you can prove it, then you understand why the Paxos consensus algorithm allows only a single
value to be chosen. Note that VInv3 is not needed to prove this property.
theorem VT1
∆= ∧TypeOK
∧VInv1
∧VInv2
⇒∀v, w :
(v ∈chosen) ∧(w ∈chosen) ⇒(v = w)
⟨1⟩1. suffices assume TypeOK, VInv1, VInv2,
new v, new w,
v ∈chosen, w ∈chosen
prove
v = w
obvious
⟨1⟩2. v ∈Value ∧w ∈Value
by ⟨1⟩1 def chosen
⟨1⟩3. pick b ∈Ballot, c ∈Ballot : ChosenIn(b, v) ∧ChosenIn(c, w)
by ⟨1⟩1 def chosen
⟨1⟩4. pick Q ∈Quorum, R ∈Quorum :
∧∀a ∈Q : VotedFor(a, b, v)
∧∀a ∈R : VotedFor(a, c, w)
by ⟨1⟩3 def ChosenIn
⟨1⟩5. pick av ∈Q, aw ∈R : ∧VotedFor(av, b, v)
∧VotedFor(aw, c, w)
by ⟨1⟩4, QuorumNonEmpty
⟨1⟩6. SafeAt(b, v) ∧SafeAt(c, w)
by ⟨1⟩1, ⟨1⟩2, ⟨1⟩5, QA def VInv2
⟨1⟩7.case b = c
⟨2⟩pick a ∈Q ∩R : true
by QA
⟨2⟩1. ∧VotedFor(a, b, v)
∧VotedFor(a, c, w)
by ⟨1⟩4
⟨2⟩2. qed
by ⟨1⟩1, ⟨1⟩2, ⟨1⟩7, ⟨2⟩1, QA def VInv1
⟨1⟩8.case b > c
by ⟨1⟩1, ⟨1⟩6, ⟨1⟩3, ⟨1⟩8, VT0, ⟨1⟩2
⟨1⟩9.case c > b
by ⟨1⟩1, ⟨1⟩6, ⟨1⟩3, ⟨1⟩9, VT0, ⟨1⟩2
⟨1⟩10. qed
by ⟨1⟩7, ⟨1⟩8, ⟨1⟩9 def Ballot
10

--- Page 11 ---
The rest of the proof uses only the primed version of VT1–that is, the theorem whose statement is
VT1′. (Remember that VT1 names the formula being asserted by the theorem we call VT1.) The
formula VT1′ asserts that VT1 is true in the second state of any transition (pair of states). We
derive that theorem from VT1 by simple temporal logic, and similarly for VT0 and SafeAtProp.
theorem SafeAtPropPrime
∆=
∀b ∈Ballot, v ∈Value :
SafeAt(b, v)′ ≡
∨b = 0
∨∃Q ∈Quorum :
∧∀a ∈Q
: maxBal′[a] ≥b
∧∃c ∈−1 . . (b −1) :
∧(c ̸= −1) ⇒∧SafeAt(c, v)′
∧∀a ∈Q :
∀w ∈Value :
VotedFor(a, c, w)′ ⇒(w = v)
∧∀d ∈(c + 1) . . (b −1), a ∈Q : DidNotVoteIn(a, d)′
⟨1⟩1. SafeAtProp′
by SafeAtProp, PTL
⟨1⟩.qed
by ⟨1⟩1
lemma VT0Prime
∆=
∧TypeOK ′
∧VInv1′
∧VInv2′
⇒∀v, w ∈Value, b, c ∈Ballot :
(b > c) ∧SafeAt(b, v)′ ∧ChosenIn(c, w)′ ⇒(v = w)
⟨1⟩1. VT0′
by VT0, PTL
⟨1⟩.qed
by ⟨1⟩1
theorem VT1Prime
∆=
∧TypeOK ′
∧VInv1′
∧VInv2′
⇒∀v, w :
(v ∈chosen′) ∧(w ∈chosen′) ⇒(v = w)
⟨1⟩1. VT1′
by VT1, PTL
⟨1⟩.qed
by ⟨1⟩1
The invariance of VInv2 depends on SafeAt(b, v) being stable, meaning that once it becomes true
it remains true forever. Stability of SafeAt(b, v) depends on the following invariant.
VInv4
∆= ∀a ∈Acceptor, b ∈Ballot :
maxBal[a] < b ⇒DidNotVoteIn(a, b)
The inductive invariant that we use to prove correctness of this algorithm is VInv, deﬁned as
follows.
VInv
∆= TypeOK ∧VInv2 ∧VInv3 ∧VInv4
11

--- Page 12 ---
To simplify reasoning about the next-state action Next, we want to express it in a more convenient
form. This is done by lemma NextDef below, which shows that Next equals an action deﬁned in
terms of the following subactions.
IncreaseMaxBal(self , b)
∆=
∧b > maxBal[self ]
∧maxBal′ = [maxBal except ![self ] = b]
∧unchanged votes
VoteFor(self , b, v)
∆=
∧maxBal[self ] ≤b
∧DidNotVoteIn(self , b)
∧∀p ∈Acceptor \ {self } :
∀w ∈Value : VotedFor(p, b, w) ⇒(w = v)
∧SafeAt(b, v)
∧votes′ = [votes except ![self ] = votes[self ] ∪{⟨b, v⟩}]
∧maxBal′ = [maxBal except ![self ] = b]
BallotAction(self , b)
∆=
∨IncreaseMaxBal(self , b)
∨∃v ∈Value : VoteFor(self , b, v)
When proving lemma NextDef , we were surprised to discover that it required the assumption that
the set of acceptors is non-empty. This assumption isn’t necessary for safety, since if there are no
acceptors there can be no quorums (see theorem QuorumNonEmpty above) so no value is ever
chosen and the Consensus speciﬁcation is trivially implemented under our reﬁnement mapping.
However, the assumption is necessary for liveness and it allows us to lemma NextDef for the safety
proof as well, so we assert it now.
assume AcceptorNonempty
∆= Acceptor ̸= {}
The proof of the lemma itself is quite simple.
lemma NextDef
∆=
TypeOK ⇒
(Next = ∃self ∈Acceptor :
∃b ∈Ballot
: BallotAction(self , b))
⟨1⟩have TypeOK
⟨1⟩2. Next = ∃self ∈Acceptor : acceptor(self )
by AcceptorNonempty def Next, ProcSet
⟨1⟩3. @ = NextDef !2!2
by def Next, BallotAction, IncreaseMaxBal, VoteFor, ProcSet, acceptor
⟨1⟩4. qed
by ⟨1⟩2, ⟨1⟩3
We now come to the proof that VInv is an invariant of the speciﬁcation. This follows from the
following result, which asserts that it is an inductive invariant of the next-state action. This fact
is used in the liveness proof as well.
theorem InductiveInvariance
∆= VInv ∧[Next]vars ⇒VInv ′
⟨1⟩1. VInv ∧(vars′ = vars) ⇒VInv ′
12

--- Page 13 ---
by Isa
def VInv, vars, TypeOK, VInv2, VotedFor, SafeAt, DidNotVoteIn, VInv3, VInv4
⟨1⟩suffices assume VInv,
new self ∈Acceptor,
new b ∈Ballot,
BallotAction(self , b)
prove
VInv ′
by ⟨1⟩1, NextDef def VInv
⟨1⟩2. TypeOK ′
⟨2⟩1.case IncreaseMaxBal(self , b)
by ⟨2⟩1 def IncreaseMaxBal, VInv, TypeOK
⟨2⟩2.case ∃v ∈Value : VoteFor(self , b, v)
by ⟨2⟩2 def VInv, TypeOK, VoteFor
⟨2⟩3. qed
by ⟨2⟩1, ⟨2⟩2 def BallotAction
⟨1⟩3. assume new a ∈Acceptor, new c ∈Ballot, new w ∈Value,
VotedFor(a, c, w)
prove
VotedFor(a, c, w)′
⟨2⟩1.case IncreaseMaxBal(self , b)
by ⟨2⟩1, ⟨1⟩3 def IncreaseMaxBal, VotedFor
⟨2⟩2.case ∃v ∈Value : VoteFor(self , b, v)
⟨3⟩1. pick v ∈Value : VoteFor(self , b, v)
by ⟨2⟩2
⟨3⟩2.case a = self
⟨4⟩1. votes′[a] = votes[a] ∪{⟨b, v⟩}
by ⟨3⟩1, ⟨3⟩2 def VoteFor, VInv, TypeOK
⟨4⟩2. qed
by ⟨1⟩3, ⟨4⟩1 def VotedFor
⟨3⟩3.case a ̸= self
⟨4⟩1. votes[a] = votes′[a]
by ⟨3⟩1, ⟨3⟩3 def VoteFor, VInv, TypeOK
⟨4⟩2. qed
by ⟨1⟩3, ⟨4⟩1 def VotedFor
⟨3⟩4. qed
by ⟨3⟩2, ⟨3⟩3 def VoteFor
⟨2⟩3. qed
by ⟨2⟩1, ⟨2⟩2 def BallotAction
⟨1⟩4. assume new a ∈Acceptor, new c ∈Ballot, new w ∈Value,
¬VotedFor(a, c, w), VotedFor(a, c, w)′
prove
(a = self ) ∧(c = b) ∧VoteFor(self , b, w)
⟨2⟩1.case IncreaseMaxBal(self , b)
by ⟨2⟩1, ⟨1⟩4 def IncreaseMaxBal, VInv, TypeOK, VotedFor
⟨2⟩2.case ∃v ∈Value : VoteFor(self , b, v)
13

--- Page 14 ---
⟨3⟩1. pick v ∈Value : VoteFor(self , b, v)
by ⟨2⟩2
⟨3⟩2. a = self
by ⟨3⟩1, ⟨1⟩4 def VoteFor, VInv, TypeOK, VotedFor
⟨3⟩3. votes′[a] = votes[a] ∪{⟨b, v⟩}
by ⟨3⟩1, ⟨3⟩2 def VoteFor, VInv, TypeOK
⟨3⟩4. c = b ∧v = w
by ⟨1⟩4, ⟨3⟩3 def VotedFor
⟨3⟩5. qed
by ⟨3⟩1, ⟨3⟩2, ⟨3⟩4
⟨2⟩3. qed
by ⟨2⟩1, ⟨2⟩2 def BallotAction
⟨1⟩5. assume new a ∈Acceptor
prove
∧maxBal[a] ∈Ballot ∪{ −1}
∧maxBal′[a] ∈Ballot ∪{ −1}
∧maxBal′[a] ≥maxBal[a]
by def VInv, TypeOK, IncreaseMaxBal, VInv, VoteFor, BallotAction, DidNotVoteIn,
VotedFor, Ballot
⟨1⟩6. assume new c ∈Ballot, new w ∈Value,
SafeAt(c, w)
prove
SafeAt(c, w)′
⟨2⟩use def Ballot
⟨2⟩define P(i)
∆= ∀j ∈0 . . i : SafeAt(j, w) ⇒SafeAt(j, w)′
⟨2⟩1. P(0)
by SafeAtPropPrime, 0 . . 0 = {0}, Zenon
⟨2⟩2. assume new d ∈Ballot, P(d)
prove
P(d + 1)
⟨3⟩1. suffices assume new e ∈0 . . (d + 1), SafeAt(e, w)
prove
SafeAt(e, w)′
obvious
⟨3⟩2.case e ∈0 . . d
by ⟨2⟩2, ⟨3⟩1, ⟨3⟩2
⟨3⟩3.case e = d + 1
⟨4⟩.e ∈Ballot \ {0}
by ⟨3⟩3
⟨4⟩1. pick Q ∈Quorum : SafeAtProp !(e, w)!2!2!(Q)
by ⟨3⟩1, SafeAtProp, Zenon
⟨4⟩2. ∀aa ∈Q : maxBal′[aa] ≥e
by ⟨1⟩5, ⟨4⟩1, QA
⟨4⟩3. ∃cc ∈−1 . . (e −1) :
∧(cc ̸= −1) ⇒∧SafeAt(cc, w)′
∧∀ax ∈Q :
∀z ∈Value :
14

--- Page 15 ---
VotedFor(ax, cc, z)′ ⇒(z = w)
∧∀dd ∈(cc + 1) . . (e −1), ax ∈Q : DidNotVoteIn(ax, dd)′
⟨5⟩1. assume new cc ∈0 . . (e −1),
new ax ∈Q, new z ∈Value,
VotedFor(ax, cc, z)′, ¬VotedFor(ax, cc, z)
prove
false
⟨6⟩1. (ax = self ) ∧(cc = b) ∧VoteFor(self , b, z)
by ⟨5⟩1, ⟨1⟩4, QA
⟨6⟩2. ∧maxBal[ax] ≥e
∧maxBal[self ] ≤b
by ⟨4⟩1, ⟨6⟩1 def VoteFor
⟨6⟩.qed by ⟨3⟩3, ⟨6⟩1, ⟨6⟩2 def VInv, TypeOK
⟨5⟩2. pick cc ∈−1 . . (e −1) : SafeAtProp !(e, w)!2!2!(Q)!2!(cc)
by ⟨4⟩1
⟨5⟩3. assume cc ̸= −1
prove
∧SafeAt(cc, w)′
∧∀ax ∈Q : ∀z ∈Value :
VotedFor(ax, cc, z)′ ⇒(z = w)
⟨6⟩1. ∧SafeAt(cc, w)
∧∀ax ∈Q :
∀z ∈Value : VotedFor(ax, cc, z) ⇒(z = w)
by ⟨5⟩2, ⟨5⟩3
⟨6⟩2. SafeAt(cc, w)′
by ⟨6⟩1, ⟨5⟩3, ⟨3⟩3, ⟨2⟩2
⟨6⟩3. assume new ax ∈Q, new z ∈Value, VotedFor(ax, cc, z)′
prove
z = w
⟨7⟩1.case VotedFor(ax, cc, z)
by ⟨6⟩1, ⟨7⟩1
⟨7⟩2.case ¬VotedFor(ax, cc, z)
by ⟨7⟩2, ⟨6⟩3, ⟨5⟩1, ⟨5⟩3
⟨7⟩3. qed
by ⟨7⟩1, ⟨7⟩2
⟨6⟩4. qed
by ⟨6⟩2, ⟨6⟩3
⟨5⟩4. assume new dd ∈(cc + 1) . . (e −1), new ax ∈Q,
¬DidNotVoteIn(ax, dd)′
prove
false
by ⟨5⟩2, ⟨5⟩1, ⟨5⟩4 def DidNotVoteIn
⟨5⟩5. qed
by ⟨5⟩3, ⟨5⟩4
⟨4⟩4. ∨e = 0
∨∃Q 1 ∈Quorum :
∧∀aa ∈Q 1 : maxBal′[aa] ≥e
∧∃c 1 ∈−1 . . e −1 :
∧c 1 ̸= −1
15

--- Page 16 ---
⇒( ∧SafeAt(c 1, w)′
∧∀aa ∈Q 1 :
∀w 1 ∈Value :
VotedFor(aa, c 1, w 1)′ ⇒w 1 = w)
∧∀d 1 ∈c 1 + 1 . . e −1, aa ∈Q 1 :
DidNotVoteIn(aa, d 1)′
by ⟨4⟩2, ⟨4⟩3, ⟨3⟩3
⟨4⟩6. SafeAt(e, w)′ ≡⟨4⟩4
by SafeAtPropPrime, ⟨3⟩3, Zenon
⟨4⟩7. qed
by ⟨4⟩2, ⟨4⟩3, ⟨4⟩6
⟨3⟩4. qed
by ⟨3⟩2, ⟨3⟩3
⟨2⟩3. ∀d ∈Ballot : P(d)
by ⟨2⟩1, ⟨2⟩2, NatInduction, Isa
⟨2⟩4. qed
by ⟨2⟩3, ⟨1⟩6
⟨1⟩7. VInv2′
⟨2⟩1. suffices assume new a ∈Acceptor, new c ∈Ballot, new v ∈Value,
VotedFor(a, c, v)′
prove
SafeAt(c, v)′
by def VInv2
⟨2⟩2.case VotedFor(a, c, v)
by ⟨1⟩6, ⟨2⟩2 def VInv, VInv2
⟨2⟩3.case ¬VotedFor(a, c, v)
by ⟨1⟩6, ⟨2⟩1, ⟨2⟩3, ⟨1⟩4 def VoteFor
⟨2⟩4. qed
by ⟨2⟩2, ⟨2⟩3
⟨1⟩8. VInv3′
⟨2⟩1. assume new a1 ∈Acceptor, new a2 ∈Acceptor,
new c ∈Ballot,
new v1 ∈Value, new v2 ∈Value,
VotedFor(a1, c, v1)′,
VotedFor(a2, c, v2)′,
VotedFor(a1, c, v1),
VotedFor(a2, c, v2)
prove v1 = v2
by ⟨2⟩1 def VInv, VInv3
⟨2⟩2. assume new a1 ∈Acceptor, new a2 ∈Acceptor,
new c ∈Ballot,
new v1 ∈Value, new v2 ∈Value,
VotedFor(a1, c, v1)′,
VotedFor(a2, c, v2)′,
¬VotedFor(a1, c, v1)
prove v1 = v2
16

--- Page 17 ---
⟨3⟩1. (a1 = self ) ∧(c = b) ∧VoteFor(self , b, v1)
by ⟨2⟩2, ⟨1⟩4
⟨3⟩2.case a2 = self
⟨4⟩1. ¬VotedFor(self , b, v2)
by ⟨3⟩1 def VoteFor, DidNotVoteIn
⟨4⟩2. VoteFor(self , b, v2)
by ⟨2⟩2, ⟨3⟩1, ⟨3⟩2, ⟨4⟩1, ⟨1⟩4
⟨4⟩.qed by ⟨3⟩1, ⟨4⟩2, ⟨2⟩2 def VotedFor, VoteFor, VInv, TypeOK
⟨3⟩3.case a2 ̸= self
by ⟨3⟩1, ⟨3⟩3, ⟨2⟩2 def VotedFor, VoteFor, VInv, TypeOK
⟨3⟩4. qed
by ⟨3⟩2, ⟨3⟩3
⟨2⟩3. qed
by ⟨2⟩1, ⟨2⟩2 def VInv3
⟨1⟩9. VInv4′
⟨2⟩1. suffices assume new a ∈Acceptor, new c ∈Ballot,
maxBal′[a] < c,
¬DidNotVoteIn(a, c)′
prove
false
by def VInv4
⟨2⟩2. maxBal[a] < c
by ⟨1⟩5, ⟨2⟩1 def Ballot
⟨2⟩3. DidNotVoteIn(a, c)
by ⟨2⟩2 def VInv, VInv4
⟨2⟩4. pick v ∈Value : VotedFor(a, c, v)′
by ⟨2⟩1 def DidNotVoteIn
⟨2⟩5. (a = self ) ∧(c = b) ∧VoteFor(self , b, v)
by ⟨1⟩4, ⟨2⟩1, ⟨2⟩3, ⟨2⟩4 def DidNotVoteIn
⟨2⟩6. maxBal′[a] = c
by ⟨2⟩5 def VoteFor, VInv, TypeOK
⟨2⟩7. qed
by ⟨2⟩1, ⟨2⟩6 def Ballot
⟨1⟩10. qed
by ⟨1⟩2, ⟨1⟩7, ⟨1⟩8, ⟨1⟩9 def VInv
The invariance of VInv follows easily from theorem InductiveInvariance and the following result,
which is easy to prove with TLAPS.
theorem InitImpliesInv
∆= Init ⇒VInv
by def Init, VInv, TypeOK, ProcSet, VInv2, VInv3, VInv4, VotedFor, DidNotVoteIn
The following theorem asserts that VInv is an invariant of Spec.
theorem VT2
∆= Spec ⇒2VInv
by InitImpliesInv, InductiveInvariance, PTL def Spec
17

--- Page 18 ---
The following instance statement instantiates module Consensus with the following expressions
substituted for the parameters (the constants and variables ) of that module:
Parameter of Consensus Expression (of this module)
Value
Value chosen
chosen
(Note that if no substitution is speciﬁed for a parameter, the default is to substitute the parameter
or deﬁned operator of the same name.) More precisely, for each deﬁned identiﬁer id of module
Consensus, this statement deﬁnes C !id to equal the value of id under these substitutions.
C
∆= instance Consensus
The following theorem asserts that the safety properties of the voting algorithm (speciﬁed by for-
mula Spec) of this module implement the consensus safety speciﬁcation Spec of module Consensus
under the substitution (reﬁnement mapping) of the instance statement.
theorem VT3
∆= Spec ⇒C !Spec
⟨1⟩1. Init ⇒C !Init
⟨2⟩suffices assume Init
prove
C !Init
obvious
⟨2⟩1. suffices assume new v ∈chosen
prove
false
by def C !Init
⟨2⟩2. pick b ∈Ballot, Q ∈Quorum : ∀a ∈Q : VotedFor(a, b, v)
by ⟨2⟩1 def chosen, ChosenIn
⟨2⟩3. pick a ∈Q : ⟨b, v⟩∈votes[a]
by QuorumNonEmpty, ⟨2⟩2 def VotedFor
⟨2⟩4. qed
by ⟨2⟩3, QA def Init
⟨1⟩2. VInv ∧VInv ′ ∧[Next]vars ⇒[C !Next]C !vars
⟨2⟩.suffices assume VInv, VInv ′, [Next]vars
prove
[C !Next]C !vars
obvious
⟨2⟩1.case vars′ = vars
by ⟨2⟩1 def vars, C !vars, chosen, ChosenIn, VotedFor
⟨2⟩2. suffices assume new self ∈Acceptor,
new b ∈Ballot,
BallotAction(self , b)
prove
[C !Next]C !vars
by ⟨2⟩1, NextDef def VInv
⟨2⟩3. assume IncreaseMaxBal(self , b)
prove
C !vars′ = C !vars
by ⟨2⟩3 def IncreaseMaxBal, C !vars, chosen, ChosenIn, VotedFor
⟨2⟩4. assume new v ∈Value,
VoteFor(self , b, v)
prove
[C !Next]C !vars
18

--- Page 19 ---
⟨3⟩3. assume new w ∈chosen
prove
w ∈chosen′
⟨4⟩1. pick c
∈Ballot, Q ∈Quorum : ∀a ∈Q : ⟨c, w⟩∈votes[a]
by ⟨3⟩3 def chosen, ChosenIn, VotedFor
⟨4⟩2. suffices assume new a ∈Q
prove
⟨c, w⟩∈votes′[a]
by def chosen, ChosenIn, VotedFor
⟨4⟩3.case a = self
by ⟨2⟩4, ⟨4⟩1, ⟨4⟩3 def VoteFor, VInv, TypeOK
⟨4⟩4.case a ̸= self
by ⟨2⟩4, ⟨4⟩1, ⟨4⟩4, QA def VoteFor, VInv, TypeOK
⟨4⟩5. qed
by ⟨4⟩3, ⟨4⟩4
⟨3⟩1. assume new w ∈chosen,
v ∈chosen′
prove
w = v
by ⟨3⟩3, ⟨3⟩1, VT1Prime def VInv, VInv1, VInv3
⟨3⟩2. assume new w, w /∈chosen, w ∈chosen′
prove
w = v
⟨4⟩2. pick c
∈Ballot, Q ∈Quorum : ∀a ∈Q : ⟨c, w⟩∈votes′[a]
by ⟨3⟩2 def chosen, ChosenIn, VotedFor
⟨4⟩3. pick a ∈Q : ⟨c, w⟩/∈votes[a]
by ⟨3⟩2 def chosen, ChosenIn, VotedFor
⟨4⟩4.case a = self
by ⟨2⟩4, ⟨4⟩4, ⟨4⟩2, ⟨4⟩3 def VoteFor, VInv, TypeOK
⟨4⟩5.case a ̸= self
by ⟨2⟩4, ⟨4⟩2, ⟨4⟩3, ⟨4⟩5, QA def VoteFor, VInv, TypeOK
⟨4⟩6. qed
by ⟨4⟩4, ⟨4⟩5
⟨3⟩.qed
by ⟨3⟩3, ⟨3⟩1, ⟨3⟩2 def C !Next, C !vars
⟨2⟩5. qed
by ⟨2⟩2, ⟨2⟩3, ⟨2⟩4 def BallotAction
⟨1⟩3. qed
by ⟨1⟩1, ⟨1⟩2, VT2, PTL def Spec, C !Spec
Liveness
We now state the liveness property required of our voting algorithm and prove that it and the
safety property imply speciﬁcation LiveSpec of module Consensus under our reﬁnement mapping.
We begin by stating two additional assumptions that are necessary for liveness. Liveness requires
that some value eventually be chosen. This cannot hold with an inﬁnite set of acceptors. More
precisely, liveness requires the existence of a ﬁnite quorum. (Otherwise, it would be impossible for
all acceptors of any quorum ever to have voted, so no value could ever be chosen.) Moreover, it is
impossible to choose a value if there are no values. Hence, we make the following two assumptions.
19

--- Page 20 ---
assume AcceptorFinite
∆= IsFiniteSet(Acceptor)
assume ValueNonempty
∆= Value ̸= {}
lemma FiniteSetHasMax
∆=
assume new S ∈subset Int, IsFiniteSet(S), S ̸= {}
prove
∃max ∈S : ∀x ∈S : max ≥x
⟨1⟩.define P(T)
∆= T ∈subset Int ∧T ̸= {} ⇒∃max ∈T : ∀x ∈T : max ≥x
⟨1⟩1. P({})
obvious
⟨1⟩2. assume new T, new x, P(T), x /∈T
prove
P(T ∪{x})
by ⟨1⟩2
⟨1⟩3. ∀T : IsFiniteSet(T) ⇒P(T)
⟨2⟩.hide def P
⟨2⟩.qed by ⟨1⟩1, ⟨1⟩2, FS Induction, IsaM (“blast”)
⟨1⟩.qed by ⟨1⟩3, Zenon
The following theorem implies that it is always possible to ﬁnd a ballot number b and a value v safe
at b by choosing b large enough and then having a quorum of acceptors perform IncreaseMaxBal(b)
actions.
It will be used in the liveness proof.
Observe that it is for liveness, not safety, that
invariant VInv3 is required.
theorem VT4
∆= TypeOK ∧VInv2 ∧VInv3 ⇒
∀Q ∈Quorum, b ∈Ballot :
(∀a ∈Q : (maxBal[a] ≥b)) ⇒∃v ∈Value : SafeAt(b, v)
Checked as an invariant by TLC with 3 acceptors, 3 ballots, 2 values
⟨1⟩.use def Ballot
⟨1⟩1. suffices assume TypeOK, VInv2, VInv3,
new Q ∈Quorum, new b ∈Ballot,
(∀a
∈Q : (maxBal[a] ≥b))
prove
∃v ∈Value : SafeAt(b, v)
obvious
⟨1⟩2.case b = 0
by ValueNonempty, ⟨1⟩1, SafeAtProp, ⟨1⟩2, Zenon
⟨1⟩4. suffices assume b ̸= 0
prove
∃v ∈Value :
∃c ∈−1 . . (b −1) :
∧(c ̸= −1) ⇒∧SafeAt(c, v)
∧∀a ∈Q :
∀w ∈Value :
VotedFor(a, c, w) ⇒(w = v)
∧∀d ∈(c + 1) . . (b −1), a ∈Q : DidNotVoteIn(a, d)
by ⟨1⟩1, ⟨1⟩2, SafeAtProp
⟨1⟩5.case ∀a ∈Q, c ∈0 . . (b −1) : DidNotVoteIn(a, c)
20

--- Page 21 ---
by ⟨1⟩5, ValueNonempty
⟨1⟩6.case ∃a ∈Q, c ∈0 . . (b −1) : ¬DidNotVoteIn(a, c)
⟨2⟩1. pick c ∈0 . . (b −1) :
∧∃a
∈Q : ¬DidNotVoteIn(a, c)
∧∀d
∈(c + 1) . . (b −1), a ∈Q : DidNotVoteIn(a, d)
⟨3⟩define S
∆= {c ∈0 . . (b −1) : ∃a
∈Q : ¬DidNotVoteIn(a, c)}
⟨3⟩1. S ̸= {}
by ⟨1⟩6
⟨3⟩2. pick c ∈S : ∀d ∈S : c ≥d
⟨4⟩2. IsFiniteSet(S)
by FS Interval, FS Subset, 0 ∈Int, b −1 ∈Int, Zenon
⟨4⟩3. qed
by ⟨3⟩1, ⟨4⟩2, FiniteSetHasMax
⟨3⟩.qed
by ⟨3⟩2 def Ballot
⟨2⟩4. pick a0 ∈Q, v ∈Value : VotedFor(a0, c, v)
by ⟨2⟩1 def DidNotVoteIn
⟨2⟩5. ∀a ∈Q : ∀w ∈Value :
VotedFor(a, c, w) ⇒(w = v)
by ⟨2⟩4, QA, ⟨1⟩1 def VInv3
⟨2⟩6. SafeAt(c, v)
by ⟨1⟩1, ⟨2⟩4, QA def VInv2
⟨2⟩7. qed
by ⟨2⟩1, ⟨2⟩5, ⟨2⟩6
⟨1⟩7. qed
by ⟨1⟩5, ⟨1⟩6
The progress property we require of the algorithm is that a quorum of acceptors, by themselves,
can eventually choose a value v. This means that, for some quorum Q and ballot b, the acceptors
a of Q must make SafeAt(b, v) true by executing IncreaseMaxBal(a, b) and then must execute
VoteFor(a, b, v) to choose v. In order to be able to execute VoteFor(a, b, v), acceptor a must
not execute a Ballot(a, c) action for any c > b.
These considerations lead to the following liveness requirement LiveAssumption. The WF condi-
tion ensures that the acceptors a in Q eventually execute the necessary BallotAction(a, b) actions
if they are enabled, and the 2[ . . . ] vars condition ensures that they never perform
BallotAction actions for higher-numbered ballots, so the necessary
BallotAction(a, b) actions are enabled.
LiveAssumption
∆=
∃Q ∈Quorum, b ∈Ballot :
∧∀self ∈Q : WFvars(BallotAction(self , b))
∧2[∀self ∈Q : ∀c ∈Ballot :
(c > b) ⇒¬BallotAction(self , c)]vars
LiveSpec
∆= Spec ∧LiveAssumption
21

--- Page 22 ---
LiveAssumption is stronger than necessary.
Instead of requiring that an acceptor in Q never
executes an action of a higher-numbered ballot than b, it suﬃces that it doesn’t execute such an
action until unless it has voted in ballot b. However, the natural liveness requirement for a Paxos
consensus algorithm implies condition LiveAssumption.
Condition LiveAssumption is a liveness property, constraining only what eventually happens. It
is straightforward to replace “eventually happens” by “happens within some length of time” and
convert LiveAssumption into a real-time condition. We have not done that for three reasons:
1. The real-time requirement and, we believe, the real-time reasoning will be more complicated,
since temporal logic was developed to abstract away much of the complexity of reasoning about
explicit times.
2. TLAPS does not yet support reasoning about real numbers.
3. Reasoning about real-time speciﬁcations consists entirely of safety reasoning, which is almost
entirely action reasoning. We want to see how the TLA+ proof language and TLAPS do on
temporal logic reasoning.
Here are two temporal-logic proof rules. Their validity is obvious when you understand what they
mean.
theorem AlwaysForall
∆=
assume new constant S, new temporal P( )
prove
(∀s ∈S : 2P(s)) ≡2(∀s ∈S : P(s))
obvious
lemma EventuallyAlwaysForall
∆=
assume new constant S, IsFiniteSet(S),
new temporal P( )
prove
(∀s ∈S : 32P(s)) ⇒32(∀s ∈S : P(s))
⟨1⟩.define A(x)
∆= 32P(x)
L(T)
∆= ∀s ∈T : A(s)
R(T)
∆= ∀s ∈T : P(s)
Q(T)
∆= L(T) ⇒32R(T)
⟨1⟩1. Q({})
⟨2⟩1. R({})
obvious
⟨2⟩2. 32R({})
by ⟨2⟩1, PTL
⟨2⟩.qed
by ⟨2⟩2
⟨1⟩2. assume new T, new x
prove
Q(T) ⇒Q(T ∪{x})
⟨2⟩1. L(T ∪{x}) ⇒A(x)
⟨3⟩.hide def A
⟨3⟩.qed obvious
⟨2⟩2. L(T ∪{x}) ∧Q(T) ⇒32R(T)
obvious
⟨2⟩3. 32R(T) ∧A(x) ⇒32(R(T) ∧P(x))
by PTL
⟨2⟩4. R(T) ∧P(x) ⇒R(T ∪{x})
obvious
⟨2⟩5. 32(R(T) ∧P(x)) ⇒32R(T ∪{x})
22

--- Page 23 ---
by ⟨2⟩4, PTL
⟨2⟩.qed
by ⟨2⟩1, ⟨2⟩2, ⟨2⟩3, ⟨2⟩5
⟨1⟩.hide def Q
⟨1⟩3. ∀T : IsFiniteSet(T) ⇒Q(T)
by ⟨1⟩1, ⟨1⟩2, FS Induction, IsaM (“blast”)
⟨1⟩4. Q(S)
by ⟨1⟩3
⟨1⟩.qed
by ⟨1⟩4 def Q
Here is our proof that LiveSpec implements the speciﬁcation LiveSpec of module Consensus under
our reﬁnement mapping.
theorem Liveness
∆= LiveSpec ⇒C !LiveSpec
⟨1⟩suffices assume new Q ∈Quorum, new b ∈Ballot
prove
Spec ∧LiveAssumption !(Q, b) ⇒C !LiveSpec
by Isa def LiveSpec, LiveAssumption
⟨1⟩a. IsFiniteSet(Q)
by QA, AcceptorFinite, FS Subset
⟨1⟩1. C !LiveSpec ≡C !Spec ∧(23⟨C !Next⟩C !vars ∨23(chosen ̸= {}))
by ValueNonempty, C !LiveSpecEquals
⟨1⟩define LNext
∆= ∃self ∈Acceptor, c ∈Ballot :
∧BallotAction(self , c)
∧(self ∈Q) ⇒(c ≤b)
⟨1⟩2. Spec ∧LiveAssumption !(Q, b) ⇒2[LNext]vars
⟨2⟩1. ∧TypeOK
∧[Next]vars
∧[∀self ∈Q : ∀c ∈Ballot : (c > b) ⇒¬BallotAction(self , c)]vars
⇒[LNext]vars
by NextDef def LNext, Ballot
⟨2⟩2. ∧2TypeOK
∧2[Next]vars
∧2[∀self ∈Q : ∀c ∈Ballot : (c > b) ⇒¬BallotAction(self , c)]vars
⇒2[LNext]vars
by ⟨2⟩1, PTL
⟨2⟩3. qed
by ⟨2⟩2, VT2, Isa def Spec, VInv
⟨1⟩define LNInv1
∆= ∀a ∈Q : maxBal[a] ≤b
LInv1
∆= VInv ∧LNInv1
⟨1⟩3. LInv1 ∧[LNext]vars ⇒LInv1′
⟨2⟩1. suffices assume LInv1, [LNext]vars
23

--- Page 24 ---
prove
LInv1′
obvious
⟨2⟩2. VInv ′
by ⟨2⟩1, NextDef , InductiveInvariance def LInv1, VInv
⟨2⟩3. LNInv1′
by ⟨2⟩1, QA def BallotAction, IncreaseMaxBal, VoteFor, VInv, TypeOK, vars
⟨2⟩.qed
by ⟨2⟩2, ⟨2⟩3
⟨1⟩4. ∀a ∈Q :
VInv ∧(maxBal[a] = b) ∧[LNext]vars ⇒VInv ′ ∧(maxBal′[a] = b)
⟨2⟩1. suffices assume new a ∈Q,
VInv, maxBal[a] = b, [LNext]vars
prove
VInv ′ ∧(maxBal′[a] = b)
obvious
⟨2⟩2. VInv ′
by ⟨2⟩1, NextDef , InductiveInvariance def VInv
⟨2⟩3. maxBal′[a] = b
by ⟨2⟩1, QA def BallotAction, IncreaseMaxBal, VoteFor, VInv, TypeOK, Ballot, vars
⟨2⟩.qed
by ⟨2⟩2, ⟨2⟩3
⟨1⟩5. Spec ∧LiveAssumption !(Q, b) ⇒
32(∀self ∈Q : maxBal[self ] = b)
⟨2⟩1. suffices assume new self ∈Q
prove
Spec ∧LiveAssumption !(Q, b) ⇒32(maxBal[self ] = b)
by ⟨1⟩a, EventuallyAlwaysForall \ * doesn’t check, even when introducing deﬁnitions
proof omitted
⟨2⟩define P
∆=
LInv1 ∧¬(maxBal[self ] = b)
QQ
∆= LInv1 ∧(maxBal[self ] = b)
A
∆= BallotAction(self , b)
⟨2⟩2.2[LNext]vars ∧WFvars(A) ⇒(LInv1 ; QQ)
⟨3⟩1. P ∧[LNext]vars ⇒(P′ ∨QQ′)
by ⟨1⟩3
⟨3⟩2. P ∧⟨LNext ∧A⟩vars ⇒QQ′
⟨4⟩1. suffices assume LInv1, LNext, A
prove
QQ′
obvious
⟨4⟩2. LInv1′
by ⟨4⟩1, ⟨1⟩3
⟨4⟩3.case IncreaseMaxBal(self , b)
by ⟨4⟩1, ⟨4⟩2, ⟨4⟩3, QA def IncreaseMaxBal, VInv, TypeOK
⟨4⟩4.case ∃v ∈Value : VoteFor(self , b, v)
by ⟨4⟩1, ⟨4⟩2, ⟨4⟩4, QA def VoteFor, VInv, TypeOK
⟨4⟩5. qed
24

--- Page 25 ---
by ⟨4⟩1, ⟨4⟩3, ⟨4⟩4 def BallotAction
⟨3⟩3. P ⇒enabled ⟨A⟩vars
⟨4⟩1. (enabled ⟨A⟩vars) ≡
∃votesp, maxBalp :
∧∨∧b > maxBal[self ]
∧maxBalp = [maxBal except ![self ] = b]
∧votesp = votes
∨∃v ∈Value :
∧maxBal[self ] ≤b
∧DidNotVoteIn(self , b)
∧∀p ∈Acceptor \ {self } :
∀w ∈Value : VotedFor(p, b, w) ⇒(w = v)
∧SafeAt(b, v)
∧votesp = [votes except ![self ] = votes[self ]
∪{⟨b, v⟩}]
∧maxBalp = [maxBal except ![self ] = b]
∧⟨votesp, maxBalp⟩̸= ⟨votes, maxBal⟩
by
def BallotAction, IncreaseMaxBal, VoteFor, vars, SafeAt,
DidNotVoteIn, VotedFor
proof omitted
⟨4⟩.suffices assume P
prove ∃votesp, maxBalp :
∧b > maxBal[self ]
∧maxBalp = [maxBal except ![self ] = b]
∧votesp = votes
∧⟨votesp, maxBalp⟩̸= ⟨votes, maxBal⟩
by ⟨4⟩1
⟨4⟩witness votes, [maxBal except ![self ] = b]
⟨4⟩.qed by QA def VInv, TypeOK, Ballot
⟨3⟩.qed by ⟨3⟩1, ⟨3⟩2, ⟨3⟩3, PTL
⟨2⟩3. QQ ∧2[LNext]vars ⇒2QQ
⟨3⟩1. QQ ∧[LNext]vars ⇒QQ′
by ⟨1⟩3, ⟨1⟩4
⟨3⟩.qed by ⟨3⟩1, PTL
⟨2⟩4.2QQ ⇒2(maxBal[self ] = b)
by PTL
⟨2⟩5. LiveAssumption !(Q, b) ⇒WFvars(A)
by Isa
⟨2⟩6. Spec ⇒LInv1
⟨3⟩1. Init ⇒VInv
by InitImpliesInv
⟨3⟩2. Init ⇒LNInv1
by QA def Init, Ballot
⟨3⟩.qed by ⟨3⟩1, ⟨3⟩2 def Spec
⟨2⟩.qed
25

--- Page 26 ---
by ⟨2⟩2, ⟨2⟩3, ⟨2⟩4, ⟨2⟩5, ⟨2⟩6, ⟨1⟩2, PTL
⟨1⟩define LNInv2
∆= ∀a ∈Q : maxBal[a] = b
LInv2
∆= VInv ∧LNInv2
⟨1⟩6. LInv2 ∧[LNext]vars ⇒LInv2′
by ⟨1⟩4, QuorumNonEmpty
⟨1⟩7. Spec ∧LiveAssumption !(Q, b) ⇒32(chosen ̸= {})
⟨2⟩define Voted(a)
∆= ∃v ∈Value : VotedFor(a, b, v)
⟨2⟩1. Spec ∧LiveAssumption !(Q, b) ⇒32LInv2
⟨3⟩1. Spec ∧LiveAssumption !(Q, b) ⇒32LNInv2
by ⟨1⟩5 \ * doesn’t check
proof omitted
⟨3⟩.qed by ⟨3⟩1, VT2, PTL
⟨2⟩2. LInv2 ∧(∀a ∈Q : Voted(a)) ⇒(chosen ̸= {})
⟨3⟩1. suffices assume LInv2,
∀a ∈Q : Voted(a)
prove
chosen ̸= {}
obvious
⟨3⟩2. ∃v ∈Value : ∀a ∈Q : VotedFor(a, b, v)
⟨4⟩2. pick a0 ∈Q, v ∈Value : VotedFor(a0, b, v)
by ⟨3⟩1, QuorumNonEmpty
⟨4⟩3. assume new a ∈Q
prove
VotedFor(a, b, v)
by ⟨3⟩1, ⟨4⟩2, QA def VInv, VInv3
⟨4⟩4. qed
by ⟨4⟩3
⟨3⟩3. qed
by ⟨3⟩2 def chosen, ChosenIn
⟨2⟩3. Spec ∧LiveAssumption !(Q, b) ⇒(∀a ∈Q : 32Voted(a))
⟨3⟩1. suffices assume new self ∈Q
prove
Spec ∧LiveAssumption !(Q, b) ⇒32Voted(self )
obvious \ * doesn’t check?!
proof omitted
⟨3⟩2. Spec ∧LiveAssumption !(Q, b) ⇒3Voted(self )
⟨4⟩2.2[LNext]vars ∧WFvars(BallotAction(self , b))
⇒((LInv2 ∧¬Voted(self )) ; LInv2 ∧Voted(self ))
⟨5⟩define P
∆= LInv2 ∧¬Voted(self )
QQ
∆= LInv2 ∧Voted(self )
A
∆= BallotAction(self , b)
⟨5⟩1. P ∧[LNext]vars ⇒(P′ ∨QQ′)
by ⟨1⟩6
⟨5⟩2. P ∧⟨LNext ∧A⟩vars ⇒QQ′
⟨6⟩1. suffices assume P,
LNext,
26

--- Page 27 ---
A
prove QQ′
obvious
⟨6⟩2.case ∃v ∈Value : VoteFor(self , b, v)
by ⟨6⟩1, ⟨6⟩2, ⟨5⟩1, QA, Zenon def VoteFor, Voted, VotedFor, LInv2, VInv, TypeOK
⟨6⟩3.case IncreaseMaxBal(self , b)
by ⟨6⟩1, ⟨6⟩3 def IncreaseMaxBal, Ballot
⟨6⟩4. qed
by ⟨6⟩1, ⟨6⟩2, ⟨6⟩3 def BallotAction
⟨5⟩3. P ⇒enabled ⟨A⟩vars
⟨6⟩1. suffices assume P
prove
enabled ⟨A⟩vars
obvious
⟨6⟩2. (enabled ⟨A⟩vars) ≡
∃votesp, maxBalp :
∧∨∧b > maxBal[self ]
∧maxBalp = [maxBal except ![self ] = b]
∧votesp = votes
∨∃v ∈Value :
∧maxBal[self ] ≤b
∧DidNotVoteIn(self , b)
∧∀p ∈Acceptor \ {self } :
∀w ∈Value : VotedFor(p, b, w) ⇒(w = v)
∧SafeAt(b, v)
∧votesp = [votes except ![self ] = votes[self ]
∪{⟨b, v⟩}]
∧maxBalp = [maxBal except ![self ] = b]
∧⟨votesp, maxBalp⟩̸= ⟨votes, maxBal⟩
by
def BallotAction, IncreaseMaxBal, VoteFor, vars, SafeAt,
DidNotVoteIn, VotedFor
proof omitted
⟨6⟩suffices
∃votesp, maxBalp :
∧∃v ∈Value :
∧maxBal[self ] ≤b
∧DidNotVoteIn(self , b)
∧∀p ∈Acceptor \ {self } :
∀w ∈Value : VotedFor(p, b, w) ⇒(w = v)
∧SafeAt(b, v)
∧votesp = [votes except ![self ] = votes[self ]
∪{⟨b, v⟩}]
∧maxBalp = [maxBal except ![self ] = b]
∧⟨votesp, maxBalp⟩̸= ⟨votes, maxBal⟩
by ⟨6⟩2
⟨6⟩define someVoted
∆= ∃p ∈Acceptor \ {self } :
27

--- Page 28 ---
∃w ∈Value : VotedFor(p, b, w)
vp
∆= choose p ∈Acceptor \ {self } :
∃w ∈Value : VotedFor(p, b, w)
vpval
∆= choose w ∈Value : VotedFor(vp, b, w)
⟨6⟩3. someVoted ⇒∧vp ∈Acceptor
∧vpval ∈Value
∧VotedFor(vp, b, vpval)
by Zenon
⟨6⟩define v
∆= if someVoted then vpval
else choose v ∈Value : SafeAt(b, v)
⟨6⟩4. (v ∈Value) ∧SafeAt(b, v)
by ⟨6⟩1, ⟨6⟩3, VT4 def VInv, VInv2, Ballot
⟨6⟩define votesp
∆= [votes except ![self ] = votes[self ] ∪{⟨b, v⟩}]
maxBalp
∆= [maxBal except ![self ] = b]
⟨6⟩witness votesp, maxBalp
⟨6⟩suffices ∧maxBal[self ] ≤b
∧DidNotVoteIn(self , b)
∧∀p ∈Acceptor \ {self } :
∀w ∈Value : VotedFor(p, b, w) ⇒(w = v)
∧votesp ̸= votes
by ⟨6⟩4, Zenon
⟨6⟩5. maxBal[self ] ≤b
by ⟨6⟩1 def Ballot
⟨6⟩6. DidNotVoteIn(self , b)
by ⟨6⟩1 def Voted, DidNotVoteIn
⟨6⟩7. assume new p ∈Acceptor \ {self },
new w ∈Value,
VotedFor(p, b, w)
prove
w = v
by ⟨6⟩7, ⟨6⟩3, ⟨6⟩1 def VInv, VInv3
⟨6⟩8. votesp ̸= votes
⟨7⟩1. votesp[self ] = votes[self ] ∪{⟨b, v⟩}
by ⟨6⟩1, QA def LInv2, VInv, TypeOK
⟨7⟩2. ∀w ∈Value : ⟨b, w⟩/∈votes[self ]
by ⟨6⟩6 def DidNotVoteIn, VotedFor
⟨7⟩3. qed
by ⟨7⟩1, ⟨7⟩2, ⟨6⟩4, Zenon
⟨6⟩9. qed
by ⟨6⟩5, ⟨6⟩6, ⟨6⟩7, ⟨6⟩8, Zenon
⟨5⟩4. qed
by ⟨5⟩1, ⟨5⟩2, ⟨5⟩3, PTL
⟨4⟩3.2LInv2 ∧((LInv2 ∧¬Voted(self )) ; LInv2 ∧Voted(self ))
⇒3Voted(self )
by PTL
⟨4⟩4. LiveAssumption !(Q, b) ⇒WFvars(BallotAction(self , b))
28

--- Page 29 ---
by Isa
⟨4⟩.qed
by ⟨1⟩2, ⟨2⟩1, ⟨4⟩2, ⟨4⟩3, ⟨4⟩4, PTL
⟨3⟩3. Spec ⇒2(Voted(self ) ⇒2Voted(self ))
⟨4⟩1. (VInv ∧Voted(self )) ∧[Next]vars ⇒(VInv ∧Voted(self ))′
⟨5⟩suffices assume VInv, Voted(self ), [Next]vars
prove
VInv ′ ∧Voted(self )′
obvious
⟨5⟩1. VInv ′
by InductiveInvariance
⟨5⟩2. Voted(self )′
⟨6⟩case vars′ = vars
by def vars, Voted, VotedFor
⟨6⟩case Next
⟨7⟩2. pick a ∈Acceptor, c ∈Ballot : BallotAction(a, c)
by NextDef def VInv
⟨7⟩3.case IncreaseMaxBal(a, c)
by ⟨7⟩3 def IncreaseMaxBal, Voted, VotedFor
⟨7⟩4.case ∃v ∈Value : VoteFor(a, c, v)
by ⟨7⟩4, QA def VInv, TypeOK, VoteFor, Voted, VotedFor
⟨7⟩5. qed
by ⟨7⟩2, ⟨7⟩3, ⟨7⟩4 def BallotAction
⟨6⟩qed
obvious
⟨5⟩3. qed
by ⟨5⟩1, ⟨5⟩2
⟨4⟩3. qed
by ⟨4⟩1, VT2, PTL def Spec
⟨3⟩4. qed
by ⟨3⟩2, ⟨3⟩3, PTL
⟨2⟩4. (∀a ∈Q : 32Voted(a)) ⇒32(∀a ∈Q : Voted(a))
by ⟨1⟩a, EventuallyAlwaysForall \ * doesn’t check
proof omitted
⟨2⟩.qed
by ⟨2⟩1, VT2, ⟨2⟩2, ⟨2⟩3, ⟨2⟩4, PTL
⟨1⟩.qed
⟨2⟩1. Spec ∧LiveAssumption !(Q, b) ⇒C !Spec ∧32(chosen ̸= {})
by VT3, ⟨1⟩7, Isa
⟨2⟩2. Spec ∧LiveAssumption !(Q, b) ⇒C !Spec ∧23(chosen ̸= {})
by ⟨2⟩1, PTL
⟨2⟩.qed
by ⟨2⟩2, ⟨1⟩1, Isa
29

--- Page 30 ---
\ * Modiﬁcation History
\ * Last modiﬁed Fri Jul 24 18:20:31 CEST 2020 by merz
\ * Last modiﬁed Wed Apr 29 12:24:23 CEST 2020 by merz
\ * Last modiﬁed Mon May 28 08:53:38 PDT 2012 by lamport
30
