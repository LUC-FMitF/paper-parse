
--- Page 1 ---
module SlidingPuzzles
extends Integers
variable board
W
∆= 4H
∆= 5
Pos
∆= (0 . . W −1) × (0 . . H −1)
Piece
∆= subset Pos
Klotski
∆= {{⟨0, 0⟩, ⟨0, 1⟩},
{⟨1, 0⟩, ⟨2, 0⟩, ⟨1, 1⟩, ⟨2, 1⟩},
{⟨3, 0⟩, ⟨3, 1⟩}, {⟨0, 2⟩, ⟨0, 3⟩},
{⟨1, 2⟩, ⟨2, 2⟩}, {⟨3, 2⟩, ⟨3, 3⟩},
{⟨1, 3⟩}, {⟨2, 3⟩}, {⟨0, 4⟩}, {⟨3, 4⟩}}
KlotskiGoal
∆= {⟨1, 3⟩, ⟨1, 4⟩, ⟨2, 3⟩, ⟨2, 4⟩} ∈board
ChooseOne(S, P( ))
∆= choose x ∈S : P(x) ∧∀y ∈S : P(y) ⇒y = x
TypeOK
∆= board ∈subset Piece
Given a position and a set of empty positions return a set of appropriately ﬁltered von Neumann
neighborhood points
dir(p, es)
∆= let dir
∆= {⟨1, 0⟩, ⟨0, 1⟩, ⟨−1, 0⟩, ⟨0, −1⟩}
in
{d ∈dir : ∧⟨p[1] + d[1], p[2] + d[2]⟩∈Pos
∧⟨p[1] + d[1], p[2] + d[2]⟩/∈es}
Given a position and a unit translation vector return a pair of pieces, before and after translation
in opposite this vector direction
move(p, d)
∆= let s
∆= ⟨p[1] + d[1], p[2] + d[2]⟩
pc
∆= ChooseOne(board, lambda pc : s ∈pc)
in
⟨pc, {⟨q[1] −d[1], q[2] −d[2]⟩: q ∈pc}⟩
Given speciﬁc free position and a set of all free positions return a set of boards updated by moving
appropriate pieces to that free position
update(e, es)
∆= let dirs
∆= dir(e, es)
moved
∆= {move(e, d) : d ∈dirs}
free
∆= {⟨pc, m⟩∈moved :
∧m ∩(union (board \ {pc})) = {}
∧∀p ∈m : p ∈Pos}
in
{(board \ {pc}) ∪{m} : ⟨pc, m⟩∈free}
Init
∆= board = Klotski
Next
∆= let empty
∆= Pos \ union board
in
∃e ∈empty : board′ ∈update(e, empty)
1
