
--- Page 1 ---
1
module MultiPaxos
An abstract speciﬁcation of the MultiPaxos algorithm. We do not model the network nor leaders
explicitely. Instead, we keep the history of all votes cast and use this history to describe how new
votes are cast. Note that, in some way, receiving a message corresponds to reading a past state of
the sender. We produce the eﬀect of having the leader by requiring that not two diﬀerent values
can be voted for in the same ballot.
This speciﬁcation is inspired from the abstract speciﬁcation of Generalized Paxos presented in
the Generalized Paxos paper by Lamport.
17 extends MultiConsensus
The variable ballot maps an acceptor to its current ballot.
Given an acceptor a, an instance i, and a ballot b, vote[a][i][b] records the vote that a casted in
ballot b of instance i.
25 variables
26
ballot, vote, propCmds
28 Init
∆=
29
∧ballot = [a ∈Acceptors 7→−1]
30
∧vote = [a ∈Acceptors 7→
31
[i ∈Instances 7→
32
[b ∈Ballots 7→None]]]
33
∧propCmds = {}
35 TypeInv
∆=
36
∧
ballot ∈[Acceptors →{ −1} ∪Ballots]
37
∧
vote ∈[Acceptors →
38
[Instances →
39
[Ballots →{None} ∪V ]]]
40
∧
propCmds ∈subset V
Now starts the speciﬁcation of the algorithm
A ballot is conservative when all acceptors which vote in the ballot vote for the same value. In
MultiPaxos, the leader of a ballot ensures that the ballot is conservative.
52 Conservative(i, b)
∆=
53
∀a1, a2 ∈Acceptors :
54
let v1
∆= vote[a1][i][b]
55
v2
∆= vote[a2][i][b]
56
in
(v1 ̸= None ∧v2 ̸= None) ⇒v1 = v2
58 ConservativeVoteArray
∆=
59
∀i ∈Instances : ∀b ∈Ballots :
60
Conservative(i, b)
The maximal ballot smaller than max in which a has voted in instance i.
1

--- Page 2 ---
65 MaxVotedBallot(i, a, max)
∆=
66
Max({b ∈Ballots : b ≤max ∧vote[a][i][b] ̸= None} ∪{ −1}, ≤)
68 MaxVotedBallots(i, Q, max)
∆= {MaxVotedBallot(i, a, max) : a ∈Q}
The vote casted in the maximal ballot smaller than max by an acceptor of the quorum Q.
74 HighestVote(i, max, Q)
∆=
75
if ∃a ∈Q : MaxVotedBallot(i, a, max) ̸= −1
76
then
77
let MaxVoter
∆= choose a ∈Q :
78
MaxVotedBallot(i, a, max) = Max(MaxVotedBallots(i, Q, max), ≤)
79
in
vote[MaxVoter][i][MaxVotedBallot(i, MaxVoter, max)]
80
else
81
None
Values that are safe to vote for in ballot b according to a quorum Q whose acceptors have all
reached ballot b.
If there is an acceptor in Q that has voted in a ballot less than b, then the only safe value is the
value voted for by an acceptor in Q in the highest ballot less than b.
Else, all values are safe.
In an implementation, the leader of a ballot b can compute ProvedSafeAt(i, Q, b) when it receives
1b messages from the quorum Q.
96 ProvedSafeAt(i, Q, b)
∆=
97
if HighestVote(i, b −1, Q) ̸= None
98
then {HighestVote(i, b −1, Q)}
99
else V
The propose action:
104 Propose(v)
∆=
105
∧propCmds′ = propCmds ∪{v}
106
∧unchanged ⟨ballot, vote⟩
The JoinBallot action: an acceptor can join a higher ballot at any time. In an implementation,
the JoinBallot action is triggered by a 1a message from the leader of the new ballot.
114 JoinBallot(a, b)
∆=
115
∧ballot[a] < b
116
∧ballot′ = [ballot except ![a] = b]
117
∧unchanged ⟨vote, propCmds⟩
The Vote action: an acceptor casts a vote in instance i. This action is enabled when the acceptor
has joined a ballot, has not voted in its current ballot, and can determine, by reading the last
vote cast by each acceptor in a quorum, which value is safe to vote for. If multiple values are
safe to vote for, we ensure that only one can be voted for by requiring that the ballot remain
conservative.
2

--- Page 3 ---
In an implementation, the computation of safe values is done by the leader of the ballot when it
receives 1b messages from a quorum of acceptors. The leader then picks a unique value among
the safe values and suggests it to the acceptors.
132 Vote(a, i)
∆=
133
∧ballot[a] ̸= −1
134
∧vote[a][i][ballot[a]] = None
135
∧∃Q ∈Quorums :
136
∧∀q ∈Q : ballot[q] ≥ballot[a]
137
∧∃v ∈ProvedSafeAt(i, Q, ballot[a]) ∩propCmds :
138
vote′ = [vote except ![a] =
139
[@ except ![i] = [@ except ![ballot[a]] = v]]]
140
∧unchanged ⟨ballot, propCmds⟩
141
∧Conservative(i, ballot[a])′
143 Next
∆=
144
∨∃v ∈V : Propose(v)
145
∨∃a ∈Acceptors : ∃b ∈Ballots : JoinBallot(a, b)
146
∨∃a ∈Acceptors : ∃i ∈Instances : Vote(a, i)
148 Spec
∆= Init ∧2[Next]⟨ballot, vote, propCmds⟩
Some properties and invariants that help understanding the algo and would probably be needed
in a proof.
The maximal ballot in which an acceptor a voted is always less than or equal to its current ballot.
159 WellFormed
∆= ∀a ∈Acceptors : ∀i ∈Instances : ∀b ∈Ballots :
160
b > ballot[a] ⇒vote[a][i][b] = None
162 theorem Spec ⇒2WellFormed
164 ChosenAt(i, b, v)
∆=
165
∃Q ∈Quorums : ∀a ∈Q : vote[a][i][b] = v
167 Chosen(i, v)
∆=
168
∃b ∈Ballots : ChosenAt(i, b, v)
170 Choosable(v, i, b)
∆=
171
∃Q ∈Quorums : ∀a ∈Q : ballot[a] > b ⇒vote[a][i][b] = v
173 SafeAt(v, i, b)
∆=
174
∀b2 ∈Ballots : ∀v2 ∈V :
175
(b2 < b ∧Choosable(v2, i, b2))
176
⇒v = v2
178 SafeInstanceVoteArray(i)
∆= ∀b ∈Ballots : ∀a ∈Acceptors :
179
let v
∆= vote[a][i][b]
180
in
v ̸= None ⇒SafeAt(v, i, b)
3

--- Page 4 ---
182 SafeVoteArray
∆= ∀i ∈Instances : SafeInstanceVoteArray(i)
184 theorem Spec ⇒2SafeVoteArray
If the vote array is well formed and the vote array is safe, then for each instance only a unique
value can be chosen.
190 theorem TypeInv ∧WellFormed ∧SafeVoteArray ⇒∀i ∈Instances :
191
∀v1, v2 ∈V : Chosen(i, v1) ∧Chosen(i, v2) ⇒v1 = v2
In a well-formed, safe, and conservative vote array, all values that are proved safe are safe.
197 theorem TypeInv ∧WellFormed ∧SafeVoteArray ∧ConservativeVoteArray
198
⇒
∀v ∈V : ∀i ∈Instances :
199
∀Q ∈Quorums : ∀b ∈Ballots :
200
∧∀a ∈Q : ballot[a] ≥b
201
∧v ∈ProvedSafeAt(i, Q, b)
202
⇒SafeAt(v, i, b)
203 Correctness
∆=
204
∀i ∈Instances : ∀v1, v2 ∈V :
205
Chosen(i, v1) ∧Chosen(i, v2) ⇒v1 = v2
207 theorem Spec ⇒2Correctness
209
\ * Modiﬁcation History
\ * Last modiﬁed Thu Jan 21 01:21:39 EST 2016 by nano
\ * Created Mon Nov 02 09:08:37 EST 2015 by nano
4
