Source: tr-2005-33.pdf
================================================================================

Generalized Consensus and Paxos
Leslie Lamport
3 March 2004
revised 15 March 2005
corrected 28 April 2005
Microsoft Research Technical Report MSR-TR-2005-33
Abstract
Theoretician’s Abstract
Consensus has been regarded as the fundamental problem that must be
solved to implement a fault-tolerant distributed system. However, only a
weaker problem than traditional consensus need be solved. We generalize
theconsensusproblemtoincludebothtraditionalconsensusandthisweaker
version. A straightforward generalization of the Paxos consensus algorithm
implements general consensus. The generalizations of consensus and of the
Paxosalgorithmrequireamathematicaldetour de force intoatypeofobject
called a command-structure set.
Engineer’s Abstract
The state-machine approach to implementing a fault-tolerant distributed
system involves reaching agreement on the sequence of system commands
by executing a sequence of separate instances of a consensus algorithm. It
can be shown that any fault-tolerant asynchronous consensus algorithm re-
quires at least two message delays between the issuing of a command and
when it can be executed. But even in the absence of faults, no algorithm
can guarantee this fast an execution if two different commands are issued
concurrently. We generalize the state-machine approach to involve reach-
ing agreement on a partially ordered set of commands. By generalizing the
Paxos consensus algorithm, we can implement a system in which concur-
rently issued commands can always be executed in two message delays if
they are non-interfering, so it does not matter in which order those com-
mands are executed. For many systems, concurrent commands are rarely
interfering, so the generalized Paxos algorithm can be quite efficient. And
command-structure sets are very simple.
Contents
1 Introduction 1
2 Traditional Consensus 3
2.1 The Requirements . . . . . . . . . . . . . . . . . . . . . . . . 3
2.2 Acceptors and Quorums . . . . . . . . . . . . . . . . . . . . . 4
2.3 Lower-Bound Results for Consensus . . . . . . . . . . . . . . 4
3 Generalized Consensus 6
4 Command-Structure Sets 8
4.1 Mathematical Preliminaries . . . . . . . . . . . . . . . . . . . 8
4.1.1 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . 8
4.1.2 Sequences . . . . . . . . . . . . . . . . . . . . . . . . . 8
4.1.3 Partial Orders . . . . . . . . . . . . . . . . . . . . . . 9
4.1.4 Equivalence Classes . . . . . . . . . . . . . . . . . . . 9
4.1.5 Directed Graph . . . . . . . . . . . . . . . . . . . . . . 9
4.2 C-Struct Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
4.3 The Consensus Requirements Restated . . . . . . . . . . . . . 12
4.4 Some Examples of C-Structs. . . . . . . . . . . . . . . . . . . 13
5 The Generalized Paxos Consensus Algorithm 17
5.1 Ballots and Quorums . . . . . . . . . . . . . . . . . . . . . . . 17
5.2 Ballot Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
5.3 The Abstract Algorithm . . . . . . . . . . . . . . . . . . . . . 21
5.4 A Distributed Abstract Algorithm . . . . . . . . . . . . . . . 26
5.5 The Generalized Paxos Consensus Algorithm . . . . . . . . . 29
6 Implementation Considerations 30
6.1 Normal Operation . . . . . . . . . . . . . . . . . . . . . . . . 30
6.2 Ensuring Liveness . . . . . . . . . . . . . . . . . . . . . . . . 32
6.3 Large C-Structs . . . . . . . . . . . . . . . . . . . . . . . . . . 33
7 Summary 34
Acknowledgments 36
References 36
A Lower-Bound Proof Ideas 38
1
B Proofs of Propositions 40
C TLA+ Specifications 43
C.1 Command Structures . . . . . . . . . . . . . . . . . . . . . . . 43
C.2 Generalized Consensus . . . . . . . . . . . . . . . . . . . . . . 46
C.3 The Constant Operators of Paxos . . . . . . . . . . . . . . . . 47
C.4 The Abstract Algorithm . . . . . . . . . . . . . . . . . . . . . 49
C.5 The Distributed Abstract Algorithm . . . . . . . . . . . . . . 52
C.6 The Generalized Paxos Consensus Algorithm . . . . . . . . . 55
1 Introduction
A system in which clients issue commands and receive responses can be
represented as a state machine. Executing a command in a given state
produces an output and a new state. A simple example is a toy banking
system in which a client can deposit or withdraw money. The state consists
oftheamountofmoneyineachclient’saccount,andclientscanissuedeposit
orwithdraw commands. Executingthecommandc withdraws$100 inastate
with at least $100 in client c’s account subtracts $100 from the amount in
that account and produces as output$100 for c, which is some string of bits
that conveys $100 in digital cash to c. Executing c deposits $50 adds $50
to c’s account and produces OK as output.
In the standard state-machine approach, a sequence of instances of a
consensus algorithm are used to choose the sequence of client commands.
The ith instance of the algorithm chooses the ith command to be executed.
Given an initial state, the sequence of commands defines the output and
new state produced by executing each command in the sequence.
Classic Paxos [4] provides a fault-tolerant implementation of an arbi-
trary state machine in an asynchronous message-passing system. In Paxos,
clients send commands to a leader. During normal operation, the leader
receives a client’s command, assigns it a new command number i, and then
beginstheith instanceoftheconsensusalgorithmbysendingwhatarecalled
phase 2a messages to a set of acceptor processes. We ignore for now what
the acceptors do when they receive those messages.
A previously unpublished algorithm, called Fast Paxos, tries to save
one message delay by having the client send its command directly to the
acceptors, bypassing the leader. An acceptor interprets the client’s message
asifitwereaphase2amessagefromtheleaderforthenextunusedcommand
number—that is, the command number that the acceptor believes to be the
next unused one.
Fast Paxos works fine if all acceptors assign the same command number
toaclient’scommand. However,supposeallacceptorsthinkthenextunused
command number is 42, at which point client c issues command A and
A
client c concurrently issues command B. Some acceptors may get c ’s
B A
message first, assigning command number 42 to A, and then receive c ’s
B
message,assigning43toB. Othersmayreceivethemessagesintheopposite
order, making the opposite assignment of command numbers to commands.
This can cause instances 42 and 43 of the consensus algorithm not to choose
any command right away, forcing the leader to intercede. Resolving this
collision adds at least one more message delay.
1
In Section 2.3, we sketch a theorem asserting that deciding whether A
or B is the next command has to add an extra message delay to Fast Paxos.
If it matters in which order commands A and B are executed—for example,
if A deposits money in an account and B reads the account’s balance—then
there is no way to avoid this extra message delay. However, suppose A
and B commute, meaning that executing them in either order has the same
effect—for example, if they are operations to two different accounts. There
is then no inherent need to decide which to execute first. This suggests that
we should be able to get the speed of Fast Paxos even when two commands
are issued concurrently, if those two commands commute. In many systems,
concurrentlyissuedcommandsalmostalwayscommute. Animplementation
that saves a message delay in almost all cases can be significantly more
efficient than one using the conventional state-machine approach.
By choosing an execution sequence, the state-machine approach decides
the order in which all pairs of commands are executed—even pairs of com-
muting commands. Instead of choosing a sequence, it suffices to choose a
partially ordered set of commands in which any two non-commuting com-
mands are ordered. We call such a partially ordered set a command history.
Executingthecommandsinacommandhistoryinanyorderconsistentwith
its partial order has the same effect. We generalize the state-machine ap-
proach by choosing a history rather than a sequence of commands.
The key to this generalization lies in generalizing the concept of consen-
sus. The customary view of the state-machine approach is that it solves a
sequenceofseparateconsensusproblemstochooseasequenceofcommands,
where consensus means reaching agreement on a single value. Instead, we
think of it as solving a single more general consensus problem that requires
agreeing on an increasing set of values—namely, the currently chosen prefix
of the command sequence. We encompass traditional consensus, agreement
on command sequences, and agreement on histories by a general consensus
problem of reaching agreement on an increasing set of values in a partially
ordered set with an append operation—a type of set we call a command
structure set. The Paxos consensus algorithm can be directly extended to
solve the generalized consensus problem for values in an arbitrary command
structure set.
Section 2 motivates our search for faster algorithms by describing some
lower bounds for traditional consensus. Section 3 generalizes the traditional
consensus problem, which chooses a single value, to the problem of choosing
monotonically increasing, consistent values. Section 4 is a mathematical
detour in which we define command-structure sets and give some examples.
We then present the generalized Paxos algorithm in Section 5 and briefly
2
discuss its implementation in Section 6. A concluding section summarizes
whatwehavedone. Proofsandproofsketchesarerelegatedtotheappendix.
Section C of the appendix also contains TLA+ specifications of command
structure sets and of our algorithms.
Generalizedconsensusforcommandhistoriesisequivalenttotheconcept
of generic consensus introduced by Pedone and Schiper [9]. Generalized
Paxos is quite similar to their algorithm GB+ for this set of c-structs, but
theirralgorithmcandetectconflictsandincurtheexpenseofresolvingthem
in cases when generalized Paxos does not. Moreover, generalized Paxos is a
natural extension of Fast Paxos and shares its flexibility—in particular, it
canswitchtoordinaryPaxoswhentoomanyfailureshaveoccurredtopermit
fast execution. Pedone and Schiper’s algorithm employs an ad hoc prefix to
an ordinary consensus algorithm, and they did not consider switching from
fast to slower execution.
2 Traditional Consensus
We now review the conventional consensus problem and give some lower
bounds on solutions. We restrict ourselves to consensus in asynchronous
systems.
2.1 The Requirements
Theconsensusproblemistypicallydescribedintermsofagreementamonga
single set of processes. However, it is better to cast the problem in terms of
asetofproposer processesthatproposevaluesandasetoflearner processes
that must agree upon a value. Think of the proposers as a system’s clients
and the learners as the servers that cooperate to implement the system.
The traditional consensus problem has three safety requirements:
Nontriviality Any value learned must have been proposed.
Stability A learner can learn at most one value. (In other words, it cannot
change its mind about what value it has learned.)
Consistency Two different learners cannot learn different values.
(Stability is often only tacitly assumed.) The safety properties are required
to hold under certain failure assumptions. For asynchronous systems, they
are generally required to hold despite any number of non-Byzantine failures.
Thetraditionalconsensusproblemalsohasthefollowinglivenessrequire-
ment:
3
Liveness(C, l) If value C has been proposed, then eventually learnerl will
learn some value.
ThisrequirementisstatedintermsofC andl becausetheassumptionunder
which it must hold generally depends on these parameters. For asynchro-
nous implementations, the usual assumption is that learner l, the proposer
of C, and a sufficient number of other processes are nonfaulty and can com-
municate with one another.
2.2 Acceptors and Quorums
Consensus is implemented using a finite set of processes called acceptors.
Acceptors, proposers, and learners are processes. Each process is executed
on a node, and a single node may execute several of these processes. A set
of nodes is considered to be nonfaulty iff the set of processes executed by
those nodes is nonfaulty.
A quorum Q is a set of acceptors that is large enough to ensure liveness.
Moreprecisely, Q isaquorumiffconditionLiveness(C,l)ofconsensusholds
when the set containing the process that proposed command C, the learner
l, and the acceptors in Q is nonfaulty for a long enough period of time.
(How long is “long enough” depends on the algorithm.) This condition is
required to hold regardless of what may have happened before this set of
processes became nonfaulty.
Proposer, acceptor, and learner can be viewed as roles performed by the
nodesinadistributedsystem. Therelationbetweentheserolesandtheroles
of client and server can vary from system to system. Typically, the clients
are proposers and the server nodes are both learners and acceptors. There
maybeadditionalnodesthatactonlyasacceptors—nodessometimescalled
witnesses. The clients may also be considered to be learners. What roles a
node plays is an implementation choice that determines the fault-tolerance
properties of the system.
2.3 Lower-Bound Results for Consensus
When devising an algorithm, it helps to know what is possible. So before
derivingthegeneralizedPaxosconsensusalgorithm,wedescribesomelower-
bound results for consensus in asynchronous systems.
The precise statements of the lower-bound results are tricky. They re-
quire some unobvious hypotheses, and algorithms that violate the bounds
are possible in certain special cases. One obvious hypothesis that we state
onceandforallnowisthatthereareatleasttwoproposersandtwolearners.
4
(Consensus becomes a trivial problem if there is only one acceptor or one
learner.) We omit the less obvious hypotheses and state only approximate
versions of the results. The ideas behind their proofs are given in Section A
of the appendix. The precise statements of the results and their rigorous
proofs appear elsewhere [7].
Thefirstresultisratherobvious;equivalentresultshaveappearedbefore.
Approximate Theorem 1 Any two quorums have non-empty intersec-
tion.
A consensus algorithm using N acceptors is said to tolerate F faults if
every set of N −F acceptors is a quorum. Approximate Theorem 1 implies
that this is possible only if N > 2F.
The other results give lower bounds on the number of message delays
required to learn a value. The message delay between two events in the exe-
cution of an algorithm is the length of the longest message chain connecting
the two events. A message chain is a sequence of messages, each of which is
received by the sender of the next message before that next message is sent.
A message chain connects event e to event f if its first message is sent by
the process executing e when or after it executes e, and whose last message
is received by the process executing f before or when it executes f.
Wesaythatalearnerl learnsavalueink messagedelaysinanexecution
inwhichl learnsavalueC,andtherearek messagedelaysbetweentheevent
of proposing C and the event of l learning C. The following result is also
fairly obvious and has been proved in several settings [1].
Approximate Theorem 2 Learningisimpossibleinfewerthan2message
delays.
We define a set Q of acceptors to be a fast quorum iff, for every proposer
p and learner l, there is an execution involving only the set of processes
Q ∪{p, l} in which a value proposed by p is learned by l in two message
delays. Events that do not influence l’s learning event are irrelevant, and
processes could fail before they are performed. We can therefore assume
that the communication in such an execution consists only of p proposing a
value and sending messages to the acceptors in Q and to l, followed by the
acceptors in Q sending messages to l.
ComparingthefollowingresultwithApproximateTheorem1showsthat
fast quorums have to be bigger than plain quorums. We believe that this
result was first announced in [6] and first proved in [7].
Approximate Theorem 3 If Q and Q are fast quorums and Q is a
1 2
quorum, then Q ∩Q ∩Q is non-empty.
1 2
5
We say that an algorithm with N acceptors is fast learning despite E faults
iff every set of N −E acceptors is a fast quorum. Approximate Theorem 3
implies that such an algorithm that tolerates F faults is possible only if
N > 2E +F.
The following result shows that it is impossible for a fault-tolerant con-
sensus algorithm to guarantee, even in the absence of failure, that a value is
always learned in two message delays. Its proof shows that this can’t occur
because two proposers can concurrently propose different values. The result
is an approximate special case of the Collision-Fast Learning theorem of [7].
Approximate Theorem 4 If, for every acceptor a, there is a quorum not
containing a, then a consensus algorithm cannot ensure that, even in the
absence of failures, every learner learns a value in two message delays.
3 Generalized Consensus
We now generalize the consensus problem from agreeing on a single value
to agreeing on an increasing set of values. We start with the problem of
agreeing on a growing sequence of commands—the problem that must be
solved in the conventional state-machine approach. Letlearned[l] be learner
l’s current knowledge of the command sequence. The value oflearned[l] will
change over time as l learns more commands in the sequence.
In the conventional state-machine approach, a learner need not learn
the sequence of commands in order. It might learn the 5th command in
the sequence before learning the 3rd command. (However, it knows that the
commandisthe5th one.) Itisconvenienttodefinelearningsothatalearner
is not considered to have learned the 5th command until it has learned the
preceding four commands. This is a reasonable notion of learning, since a
server cannot execute the 5th command until it knows the first four. We
therefore let learned[l] always be a sequence of commands (with no gaps),
for every learner l.
The four requirements for traditional consensus can be generalized as
follows. The prefix relation on sequences is the usual reflexive one, in which
any sequence is a prefix of itself.
Nontriviality Foranylearnerl,thevalueoflearned[l]isalwaysasequence
of proposed commands,
Stability For any learner l, the value of learned[l] at any time is a prefix
of its value at any later time.
6
Consistency For any learners l and l , it is always the case that one of
1 2
the sequences learned[l ] and learned[l ] is a prefix of the other.
1 2
Liveness(C, l) If command C has been proposed, then eventually the se-
quence learned[l] will contain the element C.
We now abstract these four consensus requirements from sequences to a
more general set of values that we call command structures, or c-structs
for short. C-structs are formed from a “null” element, which we call ⊥,
by the operation of appending commands. More precisely, a c-struct set
is a set, containing the element ⊥, with an append operator • such that
v • C is a c-struct, for any c-struct v and command C. We extend • to
sequences of commands in the usual way, definingv•(cid:104)C ,...,C (cid:105) to equal
1 m
v • C • ··· • C . C-structs are more general than command sequences
1 m
because ⊥•σ can equal ⊥•τ for two different command sequences σ and τ.
We now generalize the requirements for consensus from sequences to c-
structs. The generalizations of nontriviality, stability, and liveness are fairly
obvious.
Nontriviality For any learner l, there always exists a sequence σ of pro-
posed commands such that learned[l] = ⊥•σ.
Stability For any learner l, if the value of learned[l] at any time is v,
then at all later times there exists a command sequence σ such that
learned[l] = v •σ.
Liveness(C, l) If command C has been proposed, then learned[l] eventu-
ally equals v •C •σ, for some c-struct v and command sequence σ.
The obvious generalization of consistency is to use the same condition as
before, wherev isdefinedtobeaprefixofw iffw = v•σ forsomecommand
sequence σ. However, it turns out that we want to generalize still further by
requiring only that any two learned c-structs are both prefixes of the same
c-struct. (This is obviously true if one is a prefix of the other.) So, our
generalized condition is:
Consistency For all learners l and l , there always exist command se-
1 2
quences σ and σ such that learned[l ]•σ = learned[l ]•σ .
1 2 1 1 2 2
Section C.2 of the appendix contains a TLA+ specification of generalized
consensus.
7
4 Command-Structure Sets
In Section 3, we informally introduced the concept of a c-struct to define
the generalized consensus problem. We now formalize the notion of a set
of c-structs and give some examples of such sets. But first we review some
standard notation and simple mathematics.
4.1 Mathematical Preliminaries
4.1.1 Notation
Whenever possible, we use an informal style to describe mathematical con-
cepts. But mathematics can sometimes be quite hard to understand when
written in prose. While we try to keep the mathematics as prosaic as possi-
ble, there are times when words are inadequate and formulas are required.
We introduce here some fairly standard mathematical notation. We use
the customary operators of propositional logic and predicate calculus, with
∀x ∈ S : P and ∃x ∈ S : P asserting that P holds for all and for some x in
S, respectively, and we let =∆ mean is defined to equal. We use the following
notation for representing sets.
• {e ,...,e }isthesetconsistingonlyoftheelementse . Inparticular,
1 n i
{} is the empty set.
• {x | P} is the set of all x such that P is true.
• {x ∈ S | P} equals {x | (x ∈ S)∧P}.
(cid:83) (cid:84)
For example, we define the union ( ) and intersection ( ) of a set S of sets
as follows:
(cid:83)
• S =∆ {x | ∃T ∈ S : x ∈ T}
(cid:84)
• S =∆ {x | ∀T ∈ S : x ∈ T}
4.1.2 Sequences
We use the term sequence to mean a finite sequence. We enclose sequences
in angle brackets, so (cid:104)e ,...,e (cid:105) is a sequence with elements e , and (cid:104)(cid:105)
1 m i
is the empty sequence. We let Seq(S) be the set of all sequences whose
elements are in the set S, and let ◦ be the usual concatenation operator:
(cid:104)e ,...,e (cid:105)◦(cid:104)f ,...,f (cid:105) =∆ (cid:104)e ,...,e ,f ,...,f (cid:105)
1 m 1 n 1 m 1 n
For conciseness, we use the term c-seq for a finite sequence of commands.
8
4.1.3 Partial Orders
Arelation(cid:118)isa(reflexive)partialorderonasetS iffitsatisfiesthefollowing
properties, for all u, v, and w in S:
• u (cid:118) v and v (cid:118) u iff u = v.
• u (cid:118) v and v (cid:118) w imply u (cid:118) w.
For a partial order (cid:118), we define v (cid:60) w to mean v (cid:118) w and v (cid:54)= w.
Given a partial order (cid:118) on S, a lower bound of a subset T of S is an
element v of S such that v (cid:118) w for all w in T. A greatest lower bound (glb)
of T is a lower bound v of T such that w (cid:118) v for every lower bound of T.
If a glb exists, then it is unique. We write the glb of T as (cid:117)T, and we let
v (cid:117)w equal (cid:117){v, w} for any v and w in S.
Upper bounds and the least upper bound (lub) of a set T are defined
in the analogous fashion. We write the lub of T as (cid:116)T (remember “l(cid:116)b”),
and we let v (cid:116)w equal (cid:116){v, w} for any v and w in S.
The TLA+ module OrderRelations in Section C.1 of the appendix for-
malizes these definitions.
4.1.4 Equivalence Classes
A relation ∼ on a set S is called an equivalence relation iff it satisfies the
following properties, for all u, v, and w in S:
• u ∼ u
• u ∼ v iff v ∼ u
• u ∼ v and v ∼ w imply u ∼ w.
We define [u], the equivalence class under ∼ of an element u in S, by
[u] =∆ {v ∈ S | v ∼ u}
Thus, u ∼ v iff [u] = [v]. The set of all such equivalence classes is called the
quotient space of S under ∼, and is written S/ ∼.
4.1.5 Directed Graph
A directed graph consists of a pair (cid:104)N, E(cid:105) where N (the set of nodes) is a
set and E (the set of edges) is a subset of N ×N (the set of pairs of nodes).
A subgraph of a directed graph (cid:104)N, E(cid:105) is a directed graph (cid:104)M, D(cid:105) where
M ⊆ N and D = E ∩(M ×M). The subgraph (cid:104)M, D(cid:105) is defined to be a
prefix of (cid:104)N, E(cid:105) iff for every edge (cid:104)m, n(cid:105) in E, if n is in M then m is in M.
9
4.2 C-Struct Sets
Let Cmd be the set of all commands and CStruct be the set of all c-structs.
So far, all we have assumed about the set CStruct is that it contains an
element ⊥ and an operator • that appends a command to a c-struct. We
now introduce four axioms CS1–CS4 on CStruct. In other words, a set
CStruct containing an element ⊥ and an append operator • is defined to be
a c-struct set iff these axioms are satisfied. The definitions of this section
are formalized in TLA+ module CStructs of Appendix Section C.1.
We inductively define v • (cid:104)C ,...,C (cid:105) for a c-struct v and a c-seq
1 m
(cid:104)C ,...,C (cid:105) by:
1 m
(cid:40)
v if m = 0,
v •(cid:104)C ,...,C (cid:105) =
1 m (v •C )•(cid:104)C ,...,C (cid:105) otherwise
1 2 m
Our first axiom asserts that every c-struct is obtained by concatenating a
c-seq to ⊥.
CS1. CStruct = {⊥•σ | σ ∈ Seq(Cmd)}
It follows from CS1 that CStruct is isomorphic to the quotient space of
Seq(Cmd) under the equivalence relation defined by σ ∼ τ iff ⊥•σ = ⊥•τ.
We define the prefix relation (cid:118) on c-structs by
v (cid:118) w iff there exists a c-seq σ such that w = v •σ.
for any c-structs v and w. The next assumption we make about c-structs is:
CS2. (cid:118) is a partial order on the set of c-structs.
It is not hard to show that CS2 is equivalent to the assumption
v • σ • τ = v implies v • σ = v, for every c-struct v and command
sequences σ and τ.
As is customarywith a partial order, weread(cid:118)as“less than or equal”. But
because (cid:118) is a prefix relation, we also read v (cid:118) w as “v is a prefix of w” or
“w is an extension of v”.
We say that the c-struct ⊥ • (cid:104)C ,...,C (cid:105) is constructible from the
1 m
commands C . We define Str(P) to be the set of all c-structs that can be
i
constructed from elements of the set P of commands:
Str(P) =∆ {⊥•σ | σ ∈ Seq(P)}
CS1 asserts that CStruct equals Str(Cmd).
10
Wedefinetwoc-structsv andw tobecompatible ifftheyhaveacommon
upper bound—that is, iff there is some c-struct z with v (cid:118) z and w (cid:118) z.
A set S of c-structs is called compatible iff every pair of elements in S are
compatible.
The generalized Paxos algorithm computes lubs and glbs of c-structs. It
requires that any non-empty finite set S of c-structs has a glb, and if S is
compatible, then it has a lub. Moreover, it requires that its glb and lub
be constructible from the same commands as the elements of S. In other
words:
CS3. For any set P of commands and any c-structs u,v, and w in
Str(P):
• v (cid:117)w exists and is in Str(P)
• If v and w are compatible, then v (cid:116)w exists and is in Str(P).
• If {u, v, w} is compatible, then u and v (cid:116)w are compatible.
It follows from CS3 that for any finite set S of c-structs in Str(P), if S is
non-empty then (cid:117)S ∈ Str(P), and if S is compatible then (cid:116)S ∈ Str(P).
(The definition of lub implies that ⊥ is the lub of the empty set.) Letting
P equal the set Cmd, CS3 asserts the existence of the glb of any non-empty
finite set S of c-structs, and the existence of its lub if S is compatible.
For any compatible set S of c-structs, we define the (cid:116)-completion of S
to be the set of all lubs of finite subsets of S—that is, the set
{(cid:116)T | (T ⊆ S)∧(T finite)}
ThesetS isasubsetofits(cid:116)-completion, since(cid:116){v} = v, foranyc-structv.
The(cid:116)-completionofanycompatiblesetiscompatible,since((cid:116)T)(cid:116)((cid:116)U) =
(cid:116)(T ∪U) for any compatible finite sets T and U.
We say that a c-struct v contains a command C iff v is constructible
from some set of commands containing C. Equivalently, v contains C iff
v = ⊥ • σ • C • τ for some c-seqs σ and τ. A c-struct v can contain
a command C even if v is constructible from commands not containing
C. That is, v could contain C and be an element of Str(P) for some set
P of commands that does not contain C. This is because we could have
⊥•σ = ⊥•τ eventhough thec-seqsσ andτ haveno commandsin common.
Forexample,commandscouldhavesomeirrelevantfieldthatisthrownaway
by the append operator •. We would then have ⊥•σ = ⊥•τ for any τ
obtained from σ by changing just that field in all the elements of σ.
It follows easily from the definition of (cid:118) that if v (cid:118) w and v contains C
then w also contains C. Hence, the lub of any non-empty set of compatible
11
c-structs that contain C also contains C. We need to assume this for glbs
as well.
CS4. For any command C and compatible c-structs v and w, if v and
w both contain C then v (cid:117)w contains C.
ItfollowsfromCS4thatifalltheelementsofafinite, non-emptycompatible
set S of c-structs contain C, then (cid:117)S also contains C.
Theoperator•combinesc-structsandc-seqs. Mathematicianslikemore
symmetric operators, so it is natural to try to define v •w when v and w
are both c-structs. The obvious definition is:
v •(⊥•σ) =∆ v •σ, for any c-struct v and c-seq σ.
For this to uniquely define • on c-structs, we need the addition assumption:
Monoid AssumptionForallc-structsv andc-seqsσ andτ,if⊥•σ =
⊥•τ then v •σ = v •τ.
We can then extend the operator • to be a “multiplication” operator on
CStruct. ThesetCStruct withthisoperatoriscalledamonoid withidentity
element ⊥. We say that a c-struct set is monoidal iff it satisfies the monoid
assumption. The generalized Paxos algorithm does not require CStruct to
be monoidal. However, certain optimizations are possible if it is.
Onemightexpectthatthereshouldnotexistaninfinitedescendingchain
v (cid:61) v (cid:61) v (cid:61) ··· of c-structs, each an extension of the next. We leave
1 2 3
to the reader the exercise of finding a c-struct set that allows such infinite
descending chains. That the generalized Paxos algorithm works even on
such a c-struct set seems to be of no practical significance.
4.3 The Consensus Requirements Restated
We now restate the requirements for consensus in terms of the concepts
defined above, where propCmd is the set of all proposed commands:
Nontriviality learned[l] ∈ Str(propCmd)alwaysholds, foreverylearnerl.
Stability It is always the case that learned[l] = v implies v (cid:118) learned[l] at
all later times, for any learner l and c-struct v.
Consistency learned[l ]andlearned[l ]arealwayscompatible,foralllearn-
1 2
ers l and l .
1 2
Liveness(C, l) If C ∈ propCmd then eventually learned[l] contains C.
12
The approximate theorems of Section 2.3 above also hold (approximately)
for the generalized consensus problem if there exist commands C and D
such that ⊥•C and ⊥•D are not compatible.
4.4 Some Examples of C-Structs
The most obvious example of a c-struct set is the setSeq(Cmd) of all c-seqs,
where • is the usual append operator and (cid:118) the ordinary prefix relation.
Two c-seqs are compatible iff one is a prefix of the other. It is easy to see
that the set of c-seqs satisfies C1–C4, so it is indeed a c-struct set, and that
it is monoidal.
As we have seen, the generalization of consensus to this c-struct set is
essentially the problem solved by the conventional state-machine approach.
We now introduce some other c-struct sets that lead to different consensus
problems.
Nonduplicate Command Sequences
The traditional state-machine approach, specified by letting CStruct equal
Seq(Cmd), allows multiple copies of a proposed command to appear in the
commandsequence. Abankingsystemshouldnotallowasinglec withdraws
$100 command to withdraw more than $100. The problem of multiple exe-
cutions of the same command is traditionally solved by making commands
idempotent. The state machine used to implement the banking system is
defined so that only the first execution of any single withdrawal or deposit
command has any effect. A command contains a unique identifier (uid), so
c can withdraw $200 by issuing two different c withdraws $100 commands.
(The uid also appears on the command’s output, so the client knows to
which command a response is for.)
An alternative way of handling the problem of duplicate commands is
to solve a different consensus problem that eliminates them. We do this by
taking CStruct to be the set of c-seqs with no duplicates—that is, c-seqs
(cid:104)C ,...,C (cid:105) such that the C are all distinct. For any command C and
1 m i
sequence (cid:104)C ,...,C (cid:105) without duplicates, we define
1 m
(cid:40)
(cid:104)C ,...,C (cid:105) if C equals some C ,
(cid:104)C ,...,C (cid:105)•C =∆ 1 m i
1 m (cid:104)C ,...,C ,C(cid:105) otherwise
1 m
As with ordinary sequences, (cid:118) is the prefix relation and two c-structs are
compatible iff one is a prefix of the other. It is easy to see that this is a
c-struct set (satisfies axioms CS1–CS4) and that it is monoidal.
13
Redefining consensus in this way does not make it any easier to solve
the problem of multiple executions of the same command. It just transfers
the problem from the state machine to the computation of •. Instead of
duplicate commands being detected when executing the state machine, they
are detected when executing the consensus algorithm.
Commands with ⊥
We now show that generalized consensus generalizes the ordinary consensus
problem of choosing a single command. To obtain the ordinary consensus
problem,wedefineCStruct bethesetCmd∪{⊥}consistingofallcommands
together with the additional element ⊥. We define • by
(cid:40)
C if v = ⊥,
v •C =∆
v otherwise
This implies that v (cid:118) w iff v = ⊥ or v = w. Two commands are compatible
iff they are equal, and every command contains every command, since C =
C •(cid:104)D(cid:105) for any commands C and D. It is not hard to check that the set
Cmd ∪{⊥} and the operation • form a monoidal c-struct set.
With this c-struct set, generalized consensus reduces to the traditional
consensus problem, where learned[l] = ⊥ means that l has not yet learned
a value. For example, the consistency condition of generalized consensus
asserts that, for any two learners l and l , either learner[l ] and learner[l ]
1 2 1 2
are equal, or one of them equals ⊥.
Command Sets
A very simple consensus problem is obtained by taking CSruct to be the set
of all finite sets of commands. We let ⊥ be the empty set and define v •C
to equal v ∪{C}.
This c-struct set is interesting because the resulting consensus problem
is very easy to solve. Proposers simply send commands to learners, and a
learner l adds a command to learned[l] whenever it receives a proposer’s
message containing that command.
We can also let CStruct be the set of all finite multisets of commands,
whereamultisetisasetinwhichanelementcanappearmultipletimes. The
definition of ⊥ and • are the same, except where ∪ is taken to be multiset
union.
It is not too hard to see that these two different choices of CStruct
yield equivalent consensus problems. In particular, an algorithm in which a
14
learnerl keepsonlyasinglecopyofanycommandinlearned[l]alsosolvesthe
consensus problem for multisets of commands. This observation illustrates
that our statement of the consensus problem considers multiple proposals of
the same command to be the same as a single proposal.
Command Histories
As observed in the introduction, defining an execution of a set of commands
does not require totally ordering them. It suffices to determine the order
in which every pair of non-commuting commands are executed. Determin-
ing whether or not two commands commute can be difficult. Instead, one
generally introduces an interference relation (cid:179) (also called a dependence re-
lation) and requires that C (cid:179) D holds for any non-commuting pair C, D of
commands. We can allow C (cid:179) D to hold for some pairs C, D of commuting
commands as well. For the banking example, we can define C (cid:179) D to be
true iff commands C and D both access the same account. Then C (cid:179) D
holds even if C and D just deposit money into the same account, so they
commute.
In general, we assume a symmetric relation (cid:179) on commands—that is a
relation satisfying C (cid:179) D iff D (cid:179) C for any commands C and D. We define
the equivalence relation ∼ on c-seqs by letting two sequences be equivalent
iff one can be transformed into the other by permuting elements in such a
way that the order of all pairs of interfering commands is preserved. The
precise definition is:
(cid:104)C ,...,C (cid:105) ∼ (cid:104)D ,...,D (cid:105) iff m = n and there exists a permuta-
1 m 1 n
tion π of {1,...,m} such that, for each i,j = 1,...,m:
• D = C
i π(i)
• If i < j and C (cid:179) C then π(i) < π(j).
i j
We define a command history to be an equivalence class of c-seqs under this
equivalence relation. Command histories are isomorphic to Mazurkiewicz
traces [8], which were introduced to study the semantics of concurrent sys-
tems. For conciseness, we usually write history instead of command history.
We now let CStruct be the set of all histories (that is, the quotient space
Seq(Cmd)/ ∼), and we define • by
[(cid:104)C ,...,C (cid:105)]•C =∆ [(cid:104)C ,...,C ,C(cid:105)]
1 m 1 m
for any c-seq (cid:104)C ,...,C (cid:105) and command C. It is easy to check that, for
1 m
any two c-seqs σ and τ, if [σ] = [τ] then [σ ◦ (cid:104)C(cid:105)] = [τ ◦ (cid:104)C(cid:105)] for any
command C. Therefore, this uniquely defines the operator •.
15
Toshowthatthesetofhistoriesisac-struct, weobservethatthehistory
[(cid:104)C ,...,C (cid:105)] is isomorphic to a directed graph G((cid:104)C ,...,C (cid:105)) whose
1 m 1 m
nodesaretheC ,wherethereisanedgefromC toC iffi < j andC (cid:179) C .
i i j i j
TodefinethemappingG fromc-seqstographsprecisely,wemustdistinguish
different occurrences of the same command in a history. So we define the
nodes of G((cid:104)C ,...,C (cid:105)) to consist of all pairs (cid:104)C ,k (cid:105) where C is the
1 m i i i
k th occurrence of the command C in the sequence (cid:104)C ,...,C (cid:105). There
i i 1 m
is an edge from (cid:104)C ,k (cid:105) to (cid:104)C ,k (cid:105) iff i < j and C (cid:179) C . For example,
i i j j i j
suppose that C, D, and E are distinct commands with C (cid:179) D, C (cid:179) E,
D (cid:54)(cid:179) E, and no command interferes with itself. Then G((cid:104)C, D, E, C, E(cid:105))
is the graph
(cid:104)D, 1(cid:105)
(cid:126)
(cid:179)(cid:179)(cid:49) (cid:80)(cid:80)(cid:113)
(cid:104)C, 1(cid:105) (cid:104)C, 2(cid:105) (cid:45) (cid:104)E, 2(cid:105)
(cid:80)(cid:80)(cid:113) (cid:179)(cid:179)(cid:49)
(cid:104)E, 1(cid:105)
It is not hard to see that for any two c-seqs σ and τ:
• [σ] = [τ] iff G(σ) = G(τ).
• [σ] (cid:118) [τ] iff G(σ) is a prefix of G(τ).
• [σ] and [τ] are compatible iff the subgraphs of G(σ) and G(τ) consist-
ing of the nodes they have in common are identical, and C (cid:54)(cid:179) D for
every node (cid:104)C, i(cid:105) in G(σ) that is not in G(τ) and every node (cid:104)D, j(cid:105)
in G(τ) that is not in G(σ).
Usingtheseobservations,onecanshowthatthesetofhistoriesisamonoidal
c-struct set.
If non-interfering commands commute, then it is easy to see that execu-
tions of equivalent c-seqs yield the same result—that is, the same output for
eachcommandandthesamefinalstate. Hence,tousethestate-machineap-
proach for implementing a system, it suffices to solve the consensus problem
for histories.
If(cid:179)isdefinedsothatallpairsofcommandsareinterfering,thenhistories
are equivalent to sequences. If (cid:179) is defined so no commands interfere, then
histories are equivalent to finite multisets of commands. Intuitively, the
weaker the (cid:179) relation is (the less likely it is for commands to interfere), the
easier it is to solve the generalized consensus problem. As we have seen, in
the limiting case of command sets, the problem has a trivial solution.
16
Our definition of a history allows it to contain duplicate commands. As
we did with sequences, we can also define c-structs to consist of histories
without duplicates. (A history without duplicates is an equivalence class of
sequences without duplicates.) As with sequences, this moves the problem
of duplicate detection from the state machine to the consensus algorithm.
5 The Generalized Paxos Consensus Algorithm
We now develop an algorithm to implement generalized consensus in an
asynchronous, non-Byzantine distributed setting. This means that we as-
sume a network of processes that communicate by sending messages. Mes-
sages can be lost, but they cannot be corrupted. A process can fail by
stopping and doing nothing, but it cannot execute its algorithm incorrectly.
We make no assumption about relative execution speeds or about the time
it takes for a message to be delivered.
Werequirethesafetyconditionsforconsensustoholdwithnoadditional
assumptions. The famous theorem of Fischer, Lynch, and Paterson [3] im-
plies that additional assumptions are needed to ensure liveness. We defer a
discussion of liveness to Section 6.2. (However, the need to satisfy liveness
will motivate our development of the algorithm.)
Section C of the appendix contains formal TLA+ specifications of our
algorithms. The definitions of Sections 5.1 and 5.2 are formalized in Sec-
tion C.3. Appendix Section C.4 contains a TLA+ specification of the ab-
stract algorithm of Section 5.3. The distributed abstract algorithm of Sec-
tion 5.4 and the generalized Paxos consensus algorithm of Section 5.5 are
formalized in the TLA+ specifications of Sections C.5 and C.6, respectively.
5.1 Ballots and Quorums
LikeordinaryPaxos, thegeneralizedPaxosalgorithmexecutesasequenceof
numbered ballots to choose values. If a ballot does not succeed in choosing
values because of a failure, then a higher-numbered ballot is executed. Each
acceptorparticipatesinonlyoneballotatatime, goingfromoneballotonly
toahigher-numberedone. However,differentacceptorsmaybeparticipating
in different ballots at the same time.
We assume an unbounded set of ballot numbers that are totally ordered
by a relation <, with a smallest ballot number that we call 0. The natural
numbers is an obvious choice for the set of ballot numbers, but not the only
one. The set of all non-negative reals is another possible choice. We write
17
balnum as an abbreviation for ballot number, and we let BalNum be the set
of all balnums.
We assume that some ballot numbers are designated to be fast. Ballots
with fast balnums will be used to try to have learners learn commands in
twomessagedelays. Abalnumthatisnotfastissaidtobeaclassic balnum.
We assume that the sets of fast and classic balnums are both unbounded.
A quorum of acceptors must participate in a ballot for that ballot to
succeed in choosing values. What constitutes a quorum can depend upon
the ballot number. For each balnum m, we assume a collection of sets
of acceptors called m-quorums. We let Quorum(m) be the set of all m-
quorums. Approximate Theorems 1 and 3 lead us to make the following
assumption about quorums:
Quorum Assumption For all balnums k and m:
1. The intersection of any k-quorum and any m-quorum is non-
empty.
2. If k is a fast balnum, then the intersection of any two k-quorums
and any m-quorum is non-empty. More precisely:
∀Q , Q ∈ Quorum(k), R ∈ Quorum(m) :
1 2
Q ∩Q ∩R (cid:54)= {}
1 2
5.2 Ballot Arrays
The state of the balloting is described by a data structure called a ballot
array. Before talking about algorithms, we define ballot arrays and prove
some properties about them.
Wefirstintroduceanewvaluenone thatisnotac-struct, andweextend
(cid:118) to c-structs and none by defining none (cid:118) none to be true and v (cid:118) w
to be false if either v or w (but not both) equals none. We define a ballot
array as follows.
Definition 1 A ballot array β is a mapping that assigns to each acceptor
a a balnum β(cid:98) and to each acceptor a and balnum m a value β [m] that is
a a
a c-struct or equals none, such that for every acceptor a:
• β [0] (cid:54)= none
a
• The set of balnums m with β [m] (cid:54)= none is finite.
a
• β [m] = none for all balnums m > β(cid:98) .
a a
18
Thinkofaballotarrayβ asdescribingapossiblestateofavotingalgorithm.
The value of β(cid:98) represents the number of the ballot in which a is currently
a
participating. Thevalueofβ [m]representsthevotescastbya intheballot
a
numbered m; if β [m] = none then a has not voted in ballot m, otherwise
a
a has voted for all prefixes of β [m]. But this is only how we think about
a
ballot arrays. A ballot array is really just any data structure satisfying the
definition.
We now define a c-struct to be chosen in a ballot array iff it is the glb
of the c-structs voted for in some ballot by a quorum:
Definition 2 A c-struct v is chosen at balnum m in ballot array β iff there
exists an m-quorum Q such that v (cid:118) β [m] for all acceptors a in Q. A
a
c-struct v is chosen in ballot array β iff it is chosen at m in β for some
balnum m.
Remember that if v is a c-struct, then v (cid:118) w implies w (cid:54)= none. Hence, for
a c-struct to be chosen at m, there must be at least one m-quorum Q all of
whose members have voted in ballot m.
We next define what it means for v to be choosable at balnum m in β.
Intuitively, it means that β represents a state of a voting algorithm in which
it is possible for acceptors to cast additional votes that cause v to become
chosen at m, assuming that an acceptor a can cast new votes only in ballots
numbered β(cid:98) or higher.
a
Definition 3 A c-struct v is choosable at balnum m in ballot array β iff
there exists an m-quorum Q such that v (cid:118) β [m] for every acceptor a in Q
a
with β(cid:98) > m.
a
It follows immediately from the definition that if v is chosen at m in β, then
it is choosable at m in β.
We define v to be safe at m iff it is an extension of any value choosable
at a balnum less than m, and we define β to be safe iff every β [m] that is
a
a c-struct is safe at m.
Definition 4 A c-struct v is safe at m in β iff w (cid:118) v for every balnum
k < m and every c-struct w that is choosable at k. A ballot array β is safe
iff for every acceptor a and balnum k, if β [k] is a c-struct then it is safe at
a
k in β.
Observe that if v is safe at m in β, then every extension of v is also safe at
m in β. Every c-struct is trivially safe at 0 in any ballot array.
The following result shows that a voting algorithm can satisfy the con-
sistencyrequirementofconsensusbyensuringthatanacceptorvotesineach
19
ballot number m only for c-structs that are safe at m. Detailed proofs of all
the propositions in this section appear in Section B of the Appendix.
Proposition 1 If a ballot array β is safe, then the set of values that are
chosen in β is compatible.
Proposition 1 shows that an algorithm can satisfy the consistency require-
mentofconsensusbyallowingacceptorstovoteonlyforsafevalues. Satisfy-
ing liveness requires that the algorithm be able to get values chosen, which
requires that acceptors must be able to vote in some ballot with a larger
balnum than any in which they have already voted. Hence, the algorithm
must be able to find values that are safe at some sufficiently large balnum.
Moreover, sincelivenessshouldbesatisfiedifonlyaquorumofacceptorsare
non-faulty, thealgorithmshouldbeabletofindsafevaluesknowingonlythe
states of acceptors in some quorum. Hence, we need to be able to compute
safe values knowing onlyβ(cid:98) and the subarrayβ for the acceptors a in some
a a
quorum. We now show how this is done.
We define a set ProvedSafe(Q, m, β) of c-structs that depends only on
the values of β [j] for a ∈ Q and j < m. We then show that, if β(cid:98) ≥ m for
a a
every a in Q, then every c-struct in ProvedSafe(Q, m, β) is safe at m in β.
In the following definition, Max B is the largest element in the finite set B
of balnums.
Definition 5 For any balnum m, m-quorum Q, and ballot array β, let:
• k =∆ Max {i ∈ BalNum | (i < m)∧(∃a ∈ Q : β [i] (cid:54)= none)}.
a
[This set is non-empty if m >0 because β is a ballot array.]
• R =∆ {R ∈ Quorum(k) | ∀a ∈ Q ∩R : β [k] (cid:54)= none}.
a
• γ(R) =∆ (cid:117){β [k] | a ∈ Q ∩R}, for any R in R.
a
[γ(R) exists by CS3 because Q and R are quorums, so Q∩R is non-empty.]
• Γ =∆ {γ(R) | R ∈ R}
Then ProvedSafe(Q, m, β) is defined to equal
if R = {} then {β [k] | (a ∈ Q)∧(β [k] (cid:54)= none)}
a a
else if Γ is compatible then {(cid:116)Γ}
else {}
The set Γ is finite because the set of acceptors is finite. Hence, if Γ is
compatible, then (cid:116)Γ exists. If R is non-empty, then ProvedSafe(Q, m, β)
contains at most one element.
20
Proposition 2 Foranybalnumm > 0, m-quorumQ, andballotarrayβ, if
β issafeandβ(cid:98) ≥ m foralla ∈ Q,theneveryelementofProvedSafe(Q, m, β)
a
is safe at m in β.
This proposition implies that an algorithm can find a c-struct safe at
a ballot number m by computing the set ProvedSafe(Q, m, β) for an m-
quorum Q, if that set is non-empty. Let k, R, and Γ be as in the definition.
ThedefinitionimpliesthatProvedSafe(Q, m, β)isnon-emptyifRisempty.
To find safe values, we must ensure that ProvedSafe(Q, m, β) is also non-
empty if R is non-empty. By the definition, this means showing that Γ is
compatible if R is non-empty. The proof of Proposition 3 in the appendix
showsthatthisisthecaseifk isafastbalnum. However, itneednotbetrue
for a classic balnum k. To ensure that ProvedSafe(Q, m, β) is non-empty,
we need β to satisfy another condition that we now define.
Definition 6 A ballot array β is called conservative iff for every classic
balnum m and all acceptors a and b, if β [m] and β [m] are both different
a b
from none, then they are compatible.
Proposition 3 For any balnum m > 0, m-quorum Q, and ballot array β,
if β is conservative then ProvedSafe(Q, m, β) is non-empty.
5.3 The Abstract Algorithm
Paxos assumes some method of selecting a single leader. However, a unique
leader is required only to ensure liveness. The safety requirements for con-
sensus are satisfied even if there is no leader, or if multiple leaders are
selected. We assume a set of possible leaders among which the leader is to
bechosen. Eachbalnumisassignedtoapossibleleader, eachpossibleleader
being assigned unbounded sets of both classic and fast balnums.
Since we are considering only safety properties here, we don’t care how
many of the possible leaders actually are leaders. So, wedrop the “possible”
and simply call them leaders.
Intuitively, the abstract algorithm works as follows. Each acceptor par-
ticipatesinasequenceofballots. Itparticipatesinonlyoneballotatatime,
endingitsparticipationinaballotbyjoiningahigher-numberedballot. Vot-
ing in that ballot begins when the leader of a ballot (the one assigned its
balnum) suggests c-structs for acceptors to vote for in that ballot. In a fast
ballot, an acceptor first votesfor a c-struct suggested bythe leaderand then
decides by itself what additional c-structs to vote for. In a classic ballot, an
acceptor votes only for c-structs suggested by the leader.
21
Acceptors,leaders,andlearnersperformthefollowingactions. Anaccep-
tor a can at any time stop participating in its current ballot and join a new
one with number m by performing action JoinBallot(a, m). When enough
acceptors have joined ballot m, its leader can perform a StartBallot(m, Q)
action to suggest a c-struct for that ballot. If this is a classic ballot, the
leaderthensuggestsadditionalc-structsbyperformingactionSuggest(m, C)
for proposed commands C. This action suggests a new c-struct v•C, where
v is a c-struct the leader had previously suggested. An acceptor a can per-
form action ClassicVote(a, v) to vote in its current ballot for a c-struct v
suggested by the leader. If it is participating in a fast ballot and has already
voted for a c-struct suggested by the leader, acceptor a can then perform
action FastVote(a, C) to vote for a new c-struct containing the proposed
command C. It can keep performing FastVote(a, C) actions for different
commands C, until it joins a higher-numbered ballot. A learner l can at
any time perform an AbstractLearn(l, v) action that sets learned[l] to v, if
v is an extension of learned[l] that is chosen.
We describe the algorithm precisely in terms of the following variables.
learned Anarrayofc-structs,wherelearned[l]isthec-structcurrently
learned by learner l. Initially, learned[l] = ⊥ for all learners l.
propCmd Thesetofproposedcommands. Itinitiallyequalstheempty
set.
bA A ballot array. It represents the current state of the voting. Ini-
tially, b(cid:99)A = 0, bA [0] = ⊥ and bA [m] = none for all m > 0.
a a a
(Every acceptor casts a default vote for ⊥ in ballot 0, so the
algorithm begins with ⊥ chosen.)
minTried, maxTried Arrays,whereminTried[m]andmaxTried[m]are
either both c-structs or both equal to none, for every balnum
m. All the c-structs suggested thus far by the leader in ballot
m are extensions of minTried[m] and prefixes of maxTried[m].
Initially, minTried[0] = maxTried[0] = ⊥ and minTried[m] =
maxTried[m] = none for all m > 0.
The algorithm maintains the following three invariants, where a c-struct v
is said to be proposed iff it is an element of Str(propCmd).
Tried Invariant For all balnums m,
1. minTried[m] (cid:118) maxTried[m]
2. If minTried[m] (cid:54)= none, then minTried[m] is safe at m in bA and
maxTried[m] is proposed.
22
[This implies that minTried[m] and maxTried[m] are both proposed
and are both safe at m in bA, if either is not none.]
bA Invariant For all acceptors a and balnums m, if bA [m] (cid:54)= none, then
a
1. minTried[m] (cid:118) bA [m].
a
2. If m is a classic balnum, then bA [m] (cid:118) maxTried[m].
a
[Thisandpart2oftheTried invariantimplythatbA [m]isproposed.]
a
3. If m is a fast balnum, then bA [m] is proposed.
a
learned Invariant For every learner l:
1. learned[l] is proposed.
2. learned[l] is the lub of a finite set of c-structs chosen in bA.
It is easy to check that the invariants are satisfied by the initial values of
the variables. Observe that because the extension of a safe c-struct is safe,
part 2 of the Tried invariant and part 1 of the bA invariant imply that bA
is safe. The bA invariant implies that bA is also conservative.
We now show that these invariants imply that the algorithm satisfies the
nontriviality and consistency requirements.
Nontriviality This is asserted by part 1 of the learned invariant.
Consistency By the bA invariant, bA [m] (cid:54)= none implies minTried[m] (cid:118)
a
bA [m], which implies minTried[m] (cid:54)= none. Part 2 of the Tried
a
invariant then implies that bA [m] is safe at m in bA. This shows that
a
bA is safe, so Proposition 1 implies that the set of values chosen in
bA is compatible. Consistency then follows from part 2 of the learned
invariant, since the (cid:116)-completion of a compatible set is compatible.
To complete the description of the abstract algorithm, we now specify
each of its atomic actions.
Propose(C) for any command C. It is enabled iff C ∈/ propCmd. It sets
propCmd to propCmd ∪{C}.
JoinBallot(a, m) for acceptor a and balnum m. It is enabled iff b(cid:99)A < m.
a
It sets b(cid:99)A to m.
a
StartBallot(m, Q) for balnum m and m-quorum Q. It is enabled iff
• maxTried[m] = none and
• ∀a ∈ Q : b(cid:99)A ≥ m.
a
23
ItsetsminTried[m]andmaxTried[m]tow•σ foranarbitraryelement
w in ProvedSafe(Q, m, bA) and sequence σ in Seq(propCmd).
Suggest(m, C) for balnum m and command C. It is enabled iff
• C ∈ propCmd and
• maxTried[m] (cid:54)= none.
It sets maxTried[m] to maxTried[m]•C.
ClassicVote(a, v) for acceptor a and c-struct v. It is enabled iff
• maxTried[b(cid:99)A ] (cid:54)= none,
a
• minTried[b(cid:99)A ] (cid:118) v (cid:118) maxTried[b(cid:99)A ], and
a a
• bA [b(cid:99)A ] = none or bA [b(cid:99)A ] (cid:60) v
a a a a
It sets bA [b(cid:99)A ] to v.
a a
FastVote(a, C) for acceptor a and command C. It is enabled iff
• C ∈ propCmd,
• b(cid:99)A is a fast balnum, and
a
• bA [b(cid:99)A ] (cid:54)= none.
a a
It sets bA [b(cid:99)A ] to bA [b(cid:99)A ]•C.
a a a a
AbstractLearn(l, v) for learner l and c-struct v. It is enabled iff v is chosen
in bA. It sets learned[l] to learned[l](cid:116)v.
Note that the Join and StartBallot actions are never enabled for balnum 0.
(The initial state is one in which those ballot 0 actions have already been
performed.)
We first need to show that these actions are type correct, meaning that
they set the variables to values of the right type. The only non-trivial
condition to check is that bA is always set to a ballot array. Since bA [m]
a
is changed only by setting it to a c-struct for m = b(cid:99)A , and b(cid:99)A is only
a a
increased, this follows from the definition of ballot array.
We now show that each of these actions maintains the invariance of the
three invariants. In the proofs, we let an ordinary expression exp be the
value of that expression before executing the action, and exp(cid:48) be its value
after the execution.
Propose(C) This action only increases the set propCmd, and this is easily
seen to preserve the invariants.
24
JoinBallot(a, m) This action changes only b(cid:99)A , so it does not affect the
a
bA or learned invariant. It could violate the Tried invariant only if
minTried[m] is safe at m in bA but not in bA(cid:48), for some m. But the
definition of choosable at implies that if w is choosable at k in bA(cid:48),
then it is choosable at k in bA. Hence, the definition of safe at implies
that any c-struct v safe at m in bA is also safe at m in bA(cid:48).
StartBallot(m, Q) ThisactionchangesonlyminTried[m]andmaxTried[m],
settingthemfromnone toac-structv thatissafeatm inbAbyPropo-
sition2andtheobservationthatanyextensionofasafec-structissafe.
The bA invariant, assumption CS3, and the definition of ProvedSafe
imply that v is proposed. Hence, the action preserves the Tried in-
variant. It preserves the bA invariant because part 1 of that invariant
implies bA [m] = none for all acceptors a. It preserves the learned
a
invariantbecauseitdoesnotchangelearned, propCmd, orwhatvalues
are chosen in bA.
Suggest(m, C) This action changes only maxTried[m], setting it to an ex-
tensionofitspreviousvalue. Part2of theTried invariantimplies that
maxTried[m] is safe and proposed. Since the extension of a safe value
is safe, maxTried[m](cid:48) is safe. Since the action is enabled only if C is
proposed, maxTried[m](cid:48) is also proposed. It is then easy to check that
the invariants are maintained.
ClassicVote(a, v) This action changes only bA [b(cid:99)A ], setting it to v. Since
a a
minTried[b(cid:99)A ] (cid:118) v (cid:118) maxTried[b(cid:99)A ], the action clearly maintains the
a a
bA and learned invariants. It can violate the Tried invariant only by
making minTried[m] unsafe at m in bA(cid:48) for some balnum m. But it
follows from the definition of choosable at that any c-struct choosable
at balnum k in bA(cid:48) is choosable at k in bA, which implies that the
action preserves safety at any balnum m.
FastVote(a, C) This action changes only bA [b(cid:99)A ], setting it to an exten-
a a
sion of its previous value. Since it is performed only if b(cid:99)A is a fast
a
balnum, itobviouslypreservesthebAinvariant. ItpreservestheTried
invariant for the same reason that the ClassicVote action does, and it
is easily seen to preserve the learned invariant.
AbstractLearn(l, v) This action trivially maintains theTried and bA invari-
ants. The enabling condition implies that it maintains part 2 of the
learned invariant. Part 1 of that invariant follows from parts 2 and 3
25
of the bA invariant and assumption CS3, which imply that any chosen
c-struct is proposed.
Since the invariants hold in the initial state, this proves that they hold
throughout any execution of the algorithm. As observed above, this proves
that the algorithm satisfies the non-triviality and consistency requirements.
Since learned[l] is changed only by action AbstractLearn(l, v), which sets it
to learned[l](cid:116)v, the stability requirement is obviously satisfied.
5.4 A Distributed Abstract Algorithm
The abstract algorithm is non-distributed because an action performed by
one process depends on the values of variables set by another process. For
example, the action ClassicVote(a, v) performed by acceptor a depends
upon the values of minTried and maxTried, variables set by a leader. To
implement this non-distributed algorithm with a distributed one, we must
have each process send information to other processes when it changes the
values of its variables. For example, the leader of ballot m sends messages
to acceptors when it changes minTried[m] or maxTried[m]. The problem is
that the values of those variables can change between when the message is
sent and when it is received. This problem is solvable because the values
of variables change monotonically. The values of maxTried[m] and bA [m]
a
change only from none to a sequence of c-structs, each a prefix of the next.
The value of minTried[m] changes only from none to a c-struct, and then
remains unchanged. Each b(cid:99)A can only increase.
a
We now describe a distributed abstract algorithm. Its variables consist
of the variables of the abstract algorithm plus additional variables that we
don’tspecifythatrepresentwhatmessagesareintransitandwhatmessages
have been received. The variables taken from the abstract algorithm are
initialized as in that algorithm, and initially no messages have been sent.
We now describe each of the distributed algorithm’s actions, and we explain
what action of the abstract algorithm it implements.
Following previous descriptions of classic Paxos [5], we divide acceptor
and leader actions into phase 1 and phase 2 actions. Phase 1 actions im-
plement the Join and StartBallot actions of the abstract algorithm; phase 2
actions implement Suggest, ClassicVote, and FastVote. (The FastVote ac-
tion does not appear in classic Paxos.) Phase 1 actions are never enabled
for ballot 0. (They are unnecessary.)
SendProposal(C) executed by the proposer of command C. The action
is always enabled. It sets propCmd to propCmd ∪{C} and sends a
26
(cid:104)“propose”, C(cid:105) message. This message may be sent to one or more
possible leaders and/or to the acceptors; we discuss later where they
are sent.
The action implements the abstract algorithm’s Propose(C) action
if C ∈/ propCmd; otherwise it leaves that algorithm’s variables un-
changed.
Phase1a(m) executed by the leader of ballot numbered m. The action is
enabled iff maxTried[m] = none. It sends the message (cid:104)“1a”, m(cid:105) to
acceptors.
The action leaves the abstract algorithm’s variables unchanged.
Phase1b(a, m) executed by acceptor a, for balnum m. The action is en-
abled iff a has received a (cid:104)“1a”, m(cid:105) message (from the leader) and
b(cid:99)A < m. It sends the message (cid:104)“1b”, m, a, bA (cid:105) to the leader and
a a
sets b(cid:99)A to m.
a
This action implements the abstract algorithm’s JoinBallot(a, m) ac-
tion.
Phase2Start(m, v) executed by the leader of ballot m, for c-struct v. The
action is enabled when:
• maxTried[m] = none,
• the leader has received a “1b” message for balnum m from every
acceptor in an m-quorum Q, and
• v = w •σ, where σ ∈ Seq(propCmd), w ∈ ProvedSafe(Q, m, β),
and β is any ballot array such that, for every acceptor a in Q,
β(cid:98) = k and the leader has received a message (cid:104)“1b”, m, a, ρ(cid:105)
a
with β = ρ.
a
The action sets minTried[m] and maxTried[m] to v •σ and sends the
message (cid:104)“2a”, m, v • σ(cid:105) to acceptors, where σ is some sequence of
commands, each element of which the leader has received in “propose”
messages.
We now show that this action implements the abstract algorithm’s
StartBallot(m, Q) action. To show that the enabling condition im-
plies that StartBallot(m, Q) is enabled, we must show that b(cid:99)A ≥ m
a
for all a ∈ Q. This is true because the Phase1b message that sent the
“1b” message from acceptora ∈ Q set b(cid:99)A to m, and the value ofb(cid:99)A
a a
never decreases. Since a “propose” message is send only for commands
27
inpropCmd,itisclearthattheactionimplementsStartBallot(m, Q)if
ProvedSafe(Q, m, β)equalsProvedSafe(Q, m, bA). TheseProvedSafe
sets are equal for the following reason. The set ProvedSafe(Q, m, β)
depends only on the values β [k] for a ∈ Q and k < m. But β [k]
a a
equals ρ[k] for some (cid:104)“1b”, m, a, ρ(cid:105) message sent by a. When that
message was sent, ρ[k] equaled bA [k]. Moreover, the Phase1b ac-
a
tion that sent the message also set b(cid:99)A to m, which prevents any
a
further change to bA [k] for k < m. Hence, β [k] equals the current
a a
value of bA [k] for all a ∈ Q and k < m, so ProvedSafe(Q, m, β) =
a
ProvedSafe(Q, m, bA). This completes the proof that the action im-
plements StartBallot(m, Q).
Phase2aClassic(m, C) executed by the leader of ballot m, for command
C. The action is enabled iff maxTried[m] (cid:54)= none and the leader has
received a (cid:104)“propose”, C(cid:105) message. It sends the message
(cid:104)“2a”, m, maxTried[m]•C(cid:105)
to the acceptors and sets maxTried[m] to maxTried[m]•C.
It is easy to see that this implements action Suggest(m, C) of the
abstract algorithm.
Phase2bClassic(a, m, v) executedbyacceptora forbalnumm andc-struct
v. The action is enabled iff b(cid:99)A = m, acceptor a has received the
a
message (cid:104)“2a”, m, v(cid:105), and bA [m] equals none or bA [m] (cid:60) v. It sets
a a
bA [m] to v and sends a (cid:104)“2b”, m, a,v(cid:105) message to every learner.
a
ThisactionclearlyimplementsactionClassicVote(a, v)oftheabstract
algorithm if minTried[m] (cid:118) v (cid:118) maxTried[m]. But minTried[m] (cid:118)
v = maxTried[m] held when the “2a” message was sent, minTried[m]
never changes once it is different from none, and maxTried[m] can
only increase. Hence, minTried[m] (cid:118) v (cid:118) maxTried[m] must hold.
Phase2bFast(a, m, C) executed by acceptora for balnumm and command
C. The action is enabled iff m is a fast balnum, b(cid:99)A = m, bA [m] (cid:54)=
a a
none, and a has received a (cid:104)“propose”, C(cid:105) message. It sets bA [m] to
a
bA [m]•C and sends the message (cid:104)“2b”, m, a, bA [m]•C(cid:105) to every
a a
learner.
It is easy to see that this implements action FastVote(a, C) of the
abstract algorithm.
28
Learn(l, v) performed by learner l for c-struct v. The action is enabled iff,
for some balnum m and some m-quorum Q, learner l has received a
message (cid:104)“2b”, m, a, w(cid:105) with v (cid:118) w from every acceptor a in Q. It
sets learned[l] to learned[l](cid:116)v.
The existence of the message (cid:104)“2b”, m, a, w(cid:105) implies w (cid:118) bA [m],
a
since the value of bA [m] equaled w when the message was sent and
a
can only increase. Hence, the enabling condition implies that v is
chosen in bA, so this action implements action AbstractLearn(l, v) of
the abstract algorithm.
Since the distributed abstract algorithm implementsthe abstract algorithm,
it satisfies the nontriviality, consistency, and stability requirements.
5.5 The Generalized Paxos Consensus Algorithm
In our distributed abstract algorithm, processes maintain a lot of informa-
tion. A leader maintains the values of minTried[m] and maxTried[m] for
each of its balnums m; an acceptor a maintains the array bA . Moreover,
a
the complete array bA is sent in phase 1b messages. We obtain the gener-
a
alized Paxos consensus algorithm by eliminating most of this information,
so a process maintains only the data it needs.
The variable minTried is not used at all by the algorithm, so it can
be eliminated. (It appears only in the proof that the distributed algo-
rithm’sactionsimplementthenon-distributedabstractalgorithm’sactions.)
Moreover, when the leader has begun the execution of ballot m with a
Phase1a(m) action, it can forget about lower-numbered ballots. (It can
ignore phase 1b messages for lower-numbered ballots.) Therefore, a leader
r need only maintain a variable maxStarted[r] whose value is the largest
balnum m assigned to it such that maxTried[m] (cid:54)= none, and a variable
maxVal[r] whose value is maxTried[maxStarted[r]].
To compute ProvedSafe(Q, m, bA), a leader does not need the complete
arrays bA ; it needs to know only the largest balnum k < m such that
a
bA [k] (cid:54)= none and the value of bA [k]. It is therefore not hard to see that
a a
an acceptor a need keep only the following information:
mbal[a] =∆ b(cid:99)A
a
bal[a] =∆ Max{k ∈ balnum | bA [k] (cid:54)= none}
a
val[a] =∆ bA [bal[a]]
a
The Phase1b(a, m) action is then enabled iff a has received a (cid:104)“1a”, m(cid:105)
message with m < mbal[a]; the action sets mbal[a] to m and sends the
29
message (cid:104)“1b”, m, a, bal[a], val[a](cid:105). The modifications to the other actions
are straightforward. Since this is just an optimization of the distributed
abstract algorithm, it satisfies the safety requirements for consensus.
In the generalized Paxos consensus algorithm, the state of a leader, ac-
ceptor,orlearnerconsistsofac-structandatmosttwobalnums. Thelargest
message sent (a phase 1b message) contains a c-struct, a pair of balnums,
and the name of an acceptor. This is very little data, if c-structs are small.
However, a c-struct might be a history containing all the commands ever
executed by the system. It would be impractical to send a lot of messages
containing such c-structs. It might even be difficult for a process to store
a c-struct. The problem of handling large c-structs is discussed below in
Section 6.3.
6 Implementation Considerations
6.1 Normal Operation
In the usual implementations, one builds a system with some number N of
processors acting as acceptors. One can then let a quorum for both classic
and fast balnums consist of any set with at least (cid:98)2N/3(cid:99) + 1 acceptors.
One can also let a quorum for classic balnums consist of any set of at least
(cid:98)N/2(cid:99)+1 acceptors, and let a quorum for fast balnums consist of any set of
atleast(cid:100)3N/4(cid:101)acceptors. AlittlesimplesettheoryshowsthattheQuorum
Assumption is satisfied by these choices of quorums.
We consider how the system behaves in normal operation, starting with
the failure of the current leader and the selection of a new one. As part
of the leader-selection process, the new leader tries to learn what acceptors
are working. It also tries to learn the number of the largest ballot that
was in progress and chooses a larger balnum m that is assigned to it. The
leader chooses a fast balnum m if (cid:98)2N/3(cid:99)+1 acceptors are working; other-
wise, it must choose a classic one. It then begins ballot m by executing its
Phase1a(m) action, sending phase 1a messages to an m-quorum of accep-
tors. Uponreceiptofthosemessages, theacceptorsexecutePhase1b actions
and send phase 1b messages to the leader. (Those Phase1b actions are en-
abled unless an acceptor had already participated in a higher-numbered
ballot, in which case the acceptor notifies the leader and the leader tries
again with a larger balnum.)
When the leader has received phase 1b messages from an m-quorum,
it begins the second phase of ballot m (the voting phase) by executing
a Phase2aStart action, sending phase 2a messages to acceptors in an m-
30
quorum. Those acceptors will then execute their Phase2aClassic action,
sending phase 2b messages to the learners. The effect of this is to complete
thechoosingofallc-structsthatfailedtobechoseninanearlierballot. (The
failure of the previous leader may have resulted in a partially completed
ballot, in which fewer than a quorum of acceptors voted for some c-struct.)
What happens next depends on whether the leader has chosen a clas-
sic or a fast balnum. If it has chosen a classic balnum, then it notifies
proposers to send it their “propose” messages. Upon receipt of such a mes-
sage, it executes the Phase2aClassic action, sending phase 2a messages to
an m-quorum of acceptors. Upon receipt of a phase 2a message, acceptors
execute Phase2bClassic actions, sending phase 2b messages to the learners.
A learner learns a c-struct containing the proposed command when it has
received the phase 2b messages from an m-quorum. Thus, three message
delays elapse between the proposal of a command and the learning of a c-
struct containing that command. Approximate Theorem 3 implies that this
delay is optimal if fewer than (cid:98)2N/3(cid:99)+1 acceptors are non-faulty.
If the leader has chosen a fast balnum, then it notifies proposers to send
their proposals directly to an m-quorum of acceptors. Upon receipt of a
proposal, an acceptor executes a Phase2bFast action, sending a phase 2b
message to the learners. By assumption CS4, a learner learns a c-struct
containing a command C if it receives phase 2b messages with compatible
c-structs containing C from an m-quorum of acceptors. The command is
therefore learned within two message delays of its proposal, if a quorum of
acceptors all send compatible c-structs. When the c-structs are histories,
this will be the case unless an interfering command D is proposed concur-
rently. In that case, some acceptors a may execute Phase2bFast(a, m, C)
before executing Phase2bFast(a, m, D), and other acceptors may execute
the actions in the opposite order. Thus, some acceptors may vote for a c-
struct w•C•D and others for the incompatible c-struct w•D•C, for some
c-struct w. In that case, no c-struct containing either C or D is chosen in
ballot m.
When such a collision occurs, the leader can intervene by executing
a Phase1a(n) action for a higher fast balnum n. Suppose as a result of
the phase 1b messages it receives, the leader’s Phase2Start(n, w) action is
enabled. It begins phase 2 of ballot n by executing that action, sending
phase 2a messages for the c-struct w •C •D or w •D •C. Upon receipt of
this message, the acceptors perform the corresponding Phase2bClassic ac-
tions, sending phase 2b messages that cause a c-struct containing C and D
to be learned. The acceptors then resume normal fast operation, receiving
proposals directly from proposers and executing Phase2bFast actions.
31
The failure or repair of an acceptor can cause the leader to switch from
fast to slow Paxos or vice-versa. It does this by executing Phase1a(n) for a
new balnum n.
6.2 Ensuring Liveness
We now consider the liveness condition LiveChoice(C, l). It holds under
certainassumptionsthatcanbestatedintermsoftheconceptofanonfaulty
setofprocesses. Intuitively,asetofprocessesisnonfaultyiffthereareupper
bounds on the time taken by each process to perform an action and on the
delivery time of messages sent from one of the processes to another. We do
not attempt to define precisely what nonfaulty means.
When classic balnums are used, the liveness properties of generalized
Paxos are essentially the same as for ordinary Paxos. It is not hard to see
that progress can be guaranteed if eventually:
• A single unique, non-faulty leader r is chosen, and no other possible
leader performs Phase1a actions.
• Leader r executes a Phase1a(m) action for a sufficiently large classic
balnum m, and executes no Phase1a(n) actions for n > m.
• All messages sent between r and an m-quorum Q of acceptors are
eventually delivered.
• Leader r and all acceptors in Q eventually execute enabled Phase1
and Phase2 actions.
Under those assumptions, condition LiveChoice(C, l) will hold if the pro-
poser of C eventually executes a SendProposal(C) action, the message
(cid:104)“propose”, C(cid:105) sent by that action is received by leader r, and learner l
receives the phase 2b messages sent by acceptors in Q. The details are the
same as for ordinary Paxos, and the reader is referred to the proof by de
Prisco et al. [2].
To achieve liveness with fast Paxos, the leader must receive phase 2b
messages and observe if a collision has occurred—a situation indicated by
receipt of phase 2b messages for incompatible c-structs. It must then start
a new, higher-numbered ballot and get the conflicting proposed commands
chosen as described above. The basic idea is clear, though formalizing the
details is tedious.
32
6.3 Large C-Structs
ThegeneralizedPaxosalgorithmusesc-structsthroughout, savingtheirval-
uesinvariablesandsendingtheminmessages. Thisisobviouslyaproblemif
c-structs are large—for example, if they contain the entire execution history
of the system. We now indicate how they are handled in practice.
A process constructs a c-struct v by appending a short command se-
quence σ to another c-struct w. When a process sends v in a message,
it has already sent w to the same recipient. So it can send v by sending
only σ and the identifier of the message containing w. Sending c-structs in
messages therefore poses no problem.
If a c-struct contains the entire history of the system, even storing it in
memory may be a problem. Moreover, a leader must compute glbs and lubs
of sets of c-structs to execute a Phase2Start action.
Maintaining the entire execution history is a problem faced by the ordi-
nary state-machine approach. Even if the entire command sequence can be
kept in a process’s memory, restarting a failed server could require sending
an infeasibly large sequence of commands. This problem is solved by letting
a process forget the initial prefix of the command sequence, remembering
only the state after that prefix’s execution. That state is the only informa-
tionneededtoexecutelatercommands. Aprocessthusremembersthestate
after executing some initial prefix of commands, the number of commands
in that prefix, and the sequence of subsequent commands.
The same idea can be applied in general when c-structs are histories. If
aserverhaslearnedthatthe“current”historyofthesystemisv•σ forsome
c-seq σ, then it can execute the commands in σ knowing only the state after
executing the history v. So in generalized Paxos, servers can also forget
prefixes of the current history. However, we now explain why this is not as
simple for arbitrary c-structs as it is for command sequences.
To execute the generalized Paxos algorithm, a process must be able to
compute the glb and lub of two c-structs. For example, to execute action
Phase2bClassic(a, m, v) upon receipt of a phase 2a message containing c-
struct v, acceptor a must check that bA [m] (cid:118) v, which is equivalent to
a
checking that v = bA [m](cid:116)v. Suppose that a process a must compute the
a
lub of a c-struct v in its memory and a c-struct v that it has received in a
a b
message from another process b. If prefixes of c-structs have been forgotten,
then a will know only that v = w •σ and v = w •σ for known c-seqs
a a a b b b
σ and σ , but for prefixes w and w that it has forgotten. In general, it
a b a b
is not possible to compute v (cid:116)v knowing only σ , σ , and the states after
a b a b
executing the histories w and w .
a b
33
To solve this problem, we introduce the concept of a checkpoint. A
checkpoint is a command C satisfying the following property: for any c-seqs
ρ, σ, and τ, if ⊥ • ρ • C • σ = ⊥ • τ, then there is a c-seq η such that
τ = η◦(cid:104)C(cid:105)◦σ and ⊥•ρ = ⊥•η. For a monoidal c-struct set, this implies
that any c-struct v can be written uniquely in the form v •C •···•C •v
1 n
where each v equals ⊥•τ and the c-seq τ does not contain the command
i i i
C. For histories, a checkpoint is any command that interferes with every
command. Any state machine can be augmented by a checkpoint that is
defined to be a no-op (produces no output and leaves the state unchanged)
that interferes with ever command.
Assume a special checkpoint command C. A leader can periodically
propose command C. A prefix is forgotten only if it is of the form v•C. In
an ordinary state-machine implementation, a process might remember only
the state after executing command number i, for some i, and the sequence
of later commands. Similarly, in an implementation of generalized Paxos, a
process might remember only the state after executing the prefix v ending
i
with the ith checkpoint and the c-struct w such that the history it currently
knows is v •w.
i
Just as in the ordinary state-machine approach, an implementation can
use a sequence of separate instances of the generalized Paxos algorithm to
choose successive parts of the command history. In the ordinary approach,
thecommandsequenceC ,C ,...ischosenbylettingtheith instanceofthe
1 2
ordinaryPaxosconsensusalgorithmchoosethecommandC . Ingeneralized
i
Paxos, a command history v •C •v •C •··· can be chosen by letting the
1 2
ith instance of the generalized Paxos algorithm choose the history v •C,
i
where C is a special checkpoint command. The procedures for forgetting
historyprefixesandupdatingrestartedserversingeneralizedPaxosarethen
completely analogous to the ones for the ordinary state-machine method.
7 Summary
ClassicalPaxosusesasequenceofconsensusalgorithmstochooseasequence
of commands. In normal operation, a client (proposer) sends its command
to the leader, which forwards it in a phase 2a message to the acceptors,
which then send phase 2b messages to the servers (learners), which execute
the command upon receipt of enough phase 2b messages. Thus, it takes
three message delays for a command to be executed. Messages can be saved
at the cost of an extra message delay by having the phase 2b messages sent
only to the leader.
34
Consistency of the system is maintained despite any number of non-
Byzantinefailures. ToensureprogressdespitethefailureofF nodesrequires
more than 2F acceptors.
Fast Paxos saves one message delay by having the client send its com-
mand directly to the acceptors. Allowing fast progress despite the failure of
E nodes requires more than 2E +F acceptors. However, if two clients con-
currently send commands, then the normal procedure might fail to choose
a command, incurring one or more extra message delays.
Instead of executing a sequence of ordinary consensus algorithms, each
choosing a single command, we have restated the problem of implementing
a state machine as that of agreeing on a growing command history. We
generalized both ordinary consensus and consensus on command histories
to the problem of learning a monotonic sequence of objects called command
structures, and we generalized the Paxos consensus algorithm to solve this
problem.
The purpose of this generalization is to obtain an algorithm with the
same message delay as fast Paxos, but that remains fast despite concur-
rent issuing of client commands, if those commands are non-interfering. In
many applications, concurrently issued commands are almost always non-
interfering. The generalized Paxos algorithm provides a new method of
implementing such systems that, in the normal case, is optimal in terms of
the number of message delays required to execute a command.
In principle, a single instance of the generalized consensus algorithm can
beusedtoimplementasystem. Inpractice, asequenceofseparateinstances
willbeused, eachchoosingtheportionofthehistorybetweentwosuccessive
checkpoints.
All the implementation details of the ordinary state-machine approach
apply to the generalized algorithm. In particular, reconfiguration can be
performed by state-machine commands. In the original state-machine ap-
proach, based on a sequence of instances of a consensus algorithm, the set
of acceptors (and hence the set of quorums) used in instance i can be de-
termined by the state after executing command i−1.1 The same applies to
the generalized state-machine approach based on command histories. The
instance of generalized Paxos used to choose the portion of the history be-
tweencheckpointsi andi+1canbedeterminedbythestateafterexecuting
checkpoint i
1InordinaryPaxos,oneallowspipeliningofα−1instancesbylettingthesetofacceptors
in instance i depend on the state after command i −α. There is no reason to do this in
generalized Paxos, where each instance chooses a set of commands.
35
Acknowledgments
Lasaro Jonas Camargos and Rodrigo Schmidt found some minor errors in
an earlier version.
References
[1] Bernadette Charron-Bost and Andr´e Schiper. Uniform consensus
is harder than consensus (extended abstract). Technical Report
DSC/2000/028,E´colePolytechniqueF´ed´eraledeLausanne,Switzerland,
May 2000.
[2] Roberto De Prisco, Butler Lampson, and Nancy Lynch. Revisiting the
paxos algorithm. Theoretical Computer Science, 243:35–91, 2000.
[3] MichaelJ.Fischer,NancyLynch,andMichaelS.Paterson. Impossibility
of distributed consensus with one faulty process. Journal of the ACM,
32(2):374–382, April 1985.
[4] Leslie Lamport. The part-time parliament. ACM Transactions on Com-
puter Systems, 16(2):133–169, May 1998.
[5] Leslie Lamport. Paxos made simple. ACM SIGACT News (Distributed
Computing Column), 32(4):18–25, December 2001.
[6] Leslie Lamport. Lower bounds for asynchronous consensus. In Andr´e
Schiper, Alex A. Shvartsman, Hakim Weatherspoon, and Ben Y. Zhao,
editors,Future Directions in Distributed Computing,volume2584ofLec-
ture Notes in Computer Science, pages 22–23. Springer, 2003.
[7] Leslie Lamport. Lower bounds for asynchronous consensus. Tech-
nical Report MSR-TR-2004-71, Microsoft Research, July 2004.
Currently available from http://research.microsoft.com/users/
lamport/pubs/pubs.html, or by searching the Web for the 23-letter
string obtained by removing the - characters from all-lamports-pubs-
onthe-web.
[8] A. Mazurkiewicz. Semantics of concurrent systems: A modular fixed
point trace approach. In G. Rozenberg, editor, FAdvances in Petri Nets
1984, volume 188 of Lecture Notes in Computer Science, pages 353–375.
Springer-Verlag, 1984.
36
[9] Fernando Pedone and Andr´e Schiper. Handling message semantics with
generic broadcast. Distributed Computing, 15(2):97–107, 2002.
37
A Lower-Bound Proof Ideas
We describe the ideas behind the proofs of the approximate theorems as-
serted in Section 2.3. We make no attempt to convince the reader that the
results are really valid. In fact, most of them are false as stated. Their
precise statements and rigorous proofs appear in [7].
Approximate Theorem 1 Any two quorums have non-empty intersec-
tion.
Proof Idea:WeassumethatQ andQ aredisjointquorumsandobtaina
1 2
contradiction. Let p and p be two proposers that propose different values
1 2
C and C , and let l and l be different learners. Suppose both of the
1 2 1 2
sets S =∆ Q ∪{p , l } are nonfaulty, but all messages sent between S and
i i i i 1
S are lost. The requirement Liveness(C , l ) implies that both learners l
2 i i i
must learn a value. Nontriviality implies thatl must learn v . Thus, l and
i i 1
l must learn different values, violating the consistency requirement. (cid:50)
2
Approximate Theorem 2 Learningisimpossibleinfewerthan2message
delays.
Proof Idea: Suppose l learns a value proposed by p in one message delay.
Then it is possible that every message sent by p was lost except for ones
received by l. If all messages from p and l to other processes are lost, then
there is nothing to prevent another learner from learning a different value
proposed by another proposer, violating consistency. (cid:50)
Approximate Theorem 3 If Q and Q are fast quorums and Q is a
1 2
quorum, then Q ∩Q ∩Q is non-empty.
1 2
Proof Idea: Let A and A be sets of acceptors such that A , A , and
1 2 1 2
Q ∩ Q are pairwise disjoint and Q = A ∪ (Q ∩ Q ), for each i. Let
1 2 i i 1 2
p and p be proposers and let l be a learner. Let F be an execution in
1 2 a i
which p proposes a value v and sends messages to the acceptors in Q and
i i i
to l , then the acceptors in Q then send messages to l , and l learns v .
a i a a i
(Any messages sent by or to processes not in Q ∪{p , l } are lost.) Define
i i a
ˆi so ˆ1 = 2 and ˆ2 = 1. (Thus, Q and A are disjoint, for each i.)
i ˆi
We now define two executions, E and E as follows. In both executions,
1 2
p and p propose two different values v and v . In E , messages sent
1 2 1 2 i
between processes in the set Q ∪{p , l } are delivered very quickly, as are
i i a
messages sent between processes in the set A ∪ {p }; however messages
ˆi ˆi
38
sent between those two sets travel very slowly. Moreover, messages sent
betweenprocessesinQ ∪{p , l }aredeliveredsothatthebeginningofthat
i i a
execution looks to those processes exactly like the execution F . Hence, l
i a
learns v in execution E .
i i
Suppose that l and all the acceptors in Q ∩Q lose communication
a 1 2
with the rest of the processes. Executions E and E appear the same to
1 2
those other processes—that is, to processes p and p and the acceptors in
1 2
A and A . Hence, those processes have no way of knowing if l learned v
1 2 a 1
orv . IftherewereaquorumQ disjointfromQ ∩Q ,thenlivenessrequires
2 1 2
that a different learner l eventually learn a value. This is impossible, since
b
consistency cannot be ensured without knowing which value l learned. (cid:50)
a
Approximate Theorem 4 If, for every acceptor a, there is a quorum not
containing a, then a consensus algorithm cannot ensure that, in the absence
of failures, every learner learns a value in two message delays.
Proof Idea: Let p and p be proposers and l a learner. Let F be a
1 2 a i
scenario in which p proposes value v , it sends messages to all learners and
i i
acceptors, all acceptors send messages to all learners, and l then learns
a
v . Define ˆi so ˆ1 = 2 and ˆ2 = 1. Let E be the scenario obtained from F
i i i
by having all messages lost except those needed for E to look the same to
i
l as F , and having proposer p also proposes value v , but letting all its
a i ˆi ˆi
messages arrive after all the messages that were in F .
i
Let a , ..., a be the acceptors, and define a sequence of executions
1 n
G , ..., G as follows. Let G equal E and G equal E . In G , all the
0 n 0 1 n 2 0
messages sent by p arrive before all the messages sent by p , while in G ,
1 2 n
those messages all arrive in the opposite order. For 0 < i < n, let G be
i
the same as G , except that the message from p arrives at acceptor a
i−1 2 i
before the message from p . Learner l learns value v in G and v in G .
1 a 1 0 2 n
So there is some i > 0 so that l learns v in G and v in G .
a 1 i−1 2 i
Now consider an execution that begins like either G or G , and then
i−1 i
a and l both lose contact with the remaining processes. Both executions
i a
look exactly the same to those remaining processes, which therefore cannot
tell which value l learned. There is a quorum Q not containing a all of
a i
whose processes have not failed, so another learner l must be able to learn
b
a value. But there is no way to discover what value l has learned, so there
a
is no way to ensure consistency while allowing l to learn a value. (cid:50).
b
39
B Proofs of Propositions
Proposition 1 If a ballot array β is safe, then the set of values that are
chosen in β is compatible.
Proof: By the definition of chosen in and compatible, it suffices to assume
1. β is safe
2. c-struct v is chosen at balnum m in β
3. c-struct w is chosen at balnum n in β
and to prove v and w are compatible.
1. Choose an m-quorum Q and an n-quorum Q such that v (cid:118) β [m] for
v w a
all a ∈ Q and w (cid:118) β [n] for all a ∈ Q .
v a w
Proof: Q and Q exist by assumptions 2 and 3 and the definition of
v w
chosen at.
2. Case: m = n
2.1. Choose an acceptor a in Q ∩Q .
v w
Proof: a exists by the case assumption, step 1 (which implies Q
v
and Q are m-quorums), and the Quorum Assumption.
w
2.2. Q.E.D.
Proof: Steps 1 and 2.1 imply v (cid:118) β [m] and w (cid:118) β [m], so v and
a a
w are compatible.
3. Case: m < n
3.1. v is choosable at m in β.
Proof: By assumption 2, since choosable at implies chosen at.
3.2. Choose an acceptor a in Q .
w
Proof: a exists by choice of Q (step 1), since the Quorum As-
w
sumption implies that any n-quorum is non-empty.
3.3. Q.E.D.
Proof: Steps 3.2 and 1 imply w (cid:118) β [n]. Assumption 1 implies
a
β [n] is safe at n, so 3.1, the case assumption m < n, and the
a
definitionofsafeat implyv (cid:118) β [n]. Hence,w andv arecompatible.
a
4. Q.E.D.
Proof: By steps 2 and 3, the case n < m following from 3 by symmetry.
Proposition 2 Foranybalnumm > 0, m-quorumQ, andballotarrayβ, if
β issafeandβ(cid:98) ≥ m foralla ∈ Q,theneveryelementofProvedSafe(Q, m, β)
a
is safe at m in β.
Proof: Assume β is safe, ∀a ∈ Q : β(cid:98) ≥ m, and v ∈ ProvedSafe(Q, m, β).
a
Let w be a c-struct choosable at some balnum j < m. By definition of
40
safe at, it suffices to prove w (cid:118) v. Let k, R, and γ(R) be defined as in
Definition 5.
1. Choose a j-quorum Q such that β [j] (cid:54)= none and w (cid:118) β [j] for all a
w a a
in Q such that β(cid:98) > j.
w a
Proof: Q exists by the assumption that w is choosable at j and the
w
definition of choosable at.
2. j ≤ k < m
2.1. k < m and β [i] = none for all a ∈ Q and all i with k < i < m.
a
Proof: By definition of k.
2.2. Choose a in Q ∩Q .
w
Proof: a exists by step 1 (Q a j-quorum), the assumption that Q
w
is an m-quorum, and the Quorum Assumption.
2.3. β(cid:98) ≥ m and β [i] = none for all i with k < i < m.
a a
Proof: The hypothesis ∀a ∈ Q : β(cid:98) ≥ m and the choice of a (step
a
2.2) imply β(cid:98) ≥ m. Step 2.1 implies β [i] = none if k < i < m.
a a
2.4. β [j] (cid:54)= none
a
Proof: Step 2.3 and the hypothesis j < m imply β(cid:98) > j. Step 2.2
a
(which implies a ∈ Q ) and step 1 then imply β [j] (cid:54)= none.
w a
2.5. Q.E.D.
Proof: Steps 2.3 and 2.4 and the hypothesis j < m imply j ≤ k;
step 2.1 asserts k < m.
3. Case: j = k
3.1. Q ∈ R
w
Proof: The hypothesis ∀a ∈ Q : β(cid:98) ≥ m and step 2 (j < m) imply
a
β(cid:98) > j for all a ∈ Q. By step 1 and the case assumption j = k, this
a
implies β [k] (cid:54)= none for all a ∈ Q ∩Q .
a w
3.2. γ(Q ) (cid:118) v
w
Proof: By step 3.1, the hypothesis v ∈ ProvedSafe(Q, m, β), and
the definition of ProvedSafe.
3.3. w (cid:118) γ(Q )
w
Proof: Steps 1 and 3.1, the case assumption j = k, and the defini-
tion of R imply w (cid:118) β [j] for all a ∈ Q ∩Q . The definitions of γ
a w
and of the glb imply w (cid:118) γ(Q )
w
3.4. Q.E.D.
Proof: Assumption CS2 ((cid:118) a partial order) and steps 3.2 and 3.3
imply w (cid:118) v.
4. Case: j < k
4.1. Case: R is empty.
4.1.1. Choose a in Q such that β [k] (cid:54)= none and v = β [k].
a a
41
Proof: a exists by case assumption 4.1 (R empty) and the
hypothesis v ∈ ProvedSafe(Q, m, β).
4.1.2. w (cid:118) β [k]
a
Proof: Step 4.1.1 (β [k] (cid:54)= none), the hypotheses that w is
a
choosableatj,caseassumption4(j < k),andtheassumption
that β is safe.
4.1.3. Q.E.D.
Proof: Steps 4.1.1 and 4.1.2 imply w (cid:118) v.
4.2. Case: R is non−empty.
4.2.1. Choose a k-quorum R in R.
Proof: R exists by case assumption 4.2.
4.2.2. w (cid:118) β [a] for all a ∈ Q ∩R
k
Proof: For all a ∈ Q ∩R, step 4.2.1 and the definition of R
imply β [a] (cid:54)= none. The hypothesis that w is choosable at j,
k
case assumption 4 (j < k), and the hypothesis that β is safe
then imply w (cid:118) β [a].
k
4.2.3. w (cid:118) γ(R)
Proof: Step 4.2.2, the definition of γ, and the definition of
the glb.
4.2.4. γ(R) (cid:118) v
Proof: Step 4.2.1, the hypothesis v ∈ ProvedSafe(Q, m, β),
and the definition of the lub.
4.2.5. Q.E.D.
Proof: Steps 4.2.3 and 4.2.4 and the transitivity of (cid:118) (as-
sumption CS2) imply w (cid:118) v.
4.3. Q.E.D.
Proof: By steps 4.1 and 4.2.
5. Q.E.D.
Proof: Step 2 implies that steps 3 and 4 cover all possible cases.
Proposition 3 For any balnum m > 0, m-quorum Q, and ballot array β,
if β is conservative then ProvedSafe(Q, m, β) is non-empty.
Proof:Letm beabalnum,Q anm-quorum,andβ aconservativeballotar-
ray. Let k, R, and γ be defined as in the definition of ProvedSafe(Q, m, β).
We assume that R and R are k-quorums in R (so R is non-empty) and
1 2
show that γ(R ) and γ(R ) are compatible. The definition of ProvedSafe
1 2
then implies that ProvedSafe(Q, m, β) is non-empty.
1. Case: k is a fast balnum.
1.1. Choose an acceptor a in R ∩R ∩Q
1 2
42
Proof: a exists by the case 1 assumption that k is a fast balnum
and the Quorum Assumption, since the definition of R implies that
R and R are k-quorums.
1 2
1.2. Q.E.D.
Proof: Step 1.1 and the definition of γ imply γ(R ) (cid:118) β [k] and
1 a
γ(R ) (cid:118) β [k], so γ(R ) and γ(R ) are compatible.
2 a 1 2
2. Case: k is a classic balnum.
2.1. Choose an upper bound w of {β [k] | (a ∈ Q)∧(β [k] (cid:54)= none)}.
a a
Proof: w exists by case assumption 2 and the hypothesis that β is
conservative.
2.2. Q.E.D.
Proof: It follows from the definitions of R and γ that γ(R) (cid:118) w for
all R in R. Hence R and R are compatible because they are in R.
1 2
3. Q.E.D.
Proof:BySteps1and2andtheassumptionthateverybalnumiseither
a fast or a classic one.
C TLA+ Specifications
C.1 Command Structures
module OrderRelations
We make some definitions for an arbitrary ordering relation (cid:185) on a set S. The module
will be used by instantiating (cid:185) and S with a particular operator and set.
constants S, (cid:185)
We define IsPartialOrder to be the assertion that (cid:185) is an (irreflexive) partial order on a
set S, and IsTotalOrder to be the assertion that it is a total ordering of S.
IsPartialOrder =∆
∧∀u, v, w ∈ S : (u (cid:185) v)∧(v (cid:185) w) ⇒ (u (cid:185) w)
∧∀u, v ∈ S : (u (cid:185) v)∧(v (cid:185) u) ≡ (u = v)
IsTotalOrder =∆
∧IsPartialOrder
∧∀u, v ∈ S : (u (cid:185) v)∨(v (cid:185) u)
We now define the glb (greatest lower bound) and lub (least upper bound) operators.
TLA+ does not permit the use of (cid:117) and (cid:116) as prefix operators, so we use GLB and LUB
forthoseoperators. TodefineGLB,wefirstdefineIsLB(lb, T)tobetrueifflb isalower
bound of S, and IsGLB(lb, T) to be true iff lb is a glb of S. The value of GLB(T) is
unspecified if T has no glb. The definitions for upper bounds are analogous.
IsLB(lb, T) =∆ ∧lb ∈ S
43
∧∀v ∈ T : lb (cid:185) v
IsGLB(lb, T) =∆ ∧IsLB(lb, T)
∧∀v ∈ S : IsLB(v, T) ⇒ (v (cid:185) lb)
GLB(T) =∆ choose lb ∈ S : IsGLB(lb, T)
v (cid:117)w =∆ GLB({v, w})
IsUB(ub, T) =∆ ∧ub ∈ S
∧∀v ∈ T : v (cid:185) ub
IsLUB(ub, T) =∆ ∧IsUB(ub, T)
∧∀v ∈ S : IsUB(v, T) ⇒ (ub (cid:185) v)
LUB(T) =∆ choose ub ∈ S : IsLUB(ub, T)
v (cid:116)w =∆ LUB({v, w})
module CStructs
extends Sequences
The Sequences module defines the operator Seq.
We declare the assumed objects as parameters. TLA+ does not permit the identifier ⊥,
so we use Bottom instead.
constants Cmd, CStruct, • , Bottom
TLA+ does not permit operator overloading, so we write v ∗∗σ instead of v •σ for a
commandsequenceσ. TLA+ allowsrecursivedefinitionsonlyoffunctions,notoperators,
so the definition of ∗∗ recursively defines the function conc such that conc[w, t]=w ∗∗t.
v ∗∗s =∆ let conc[w ∈ CStruct, t ∈ Seq(Cmd)] =∆
if t = (cid:104)(cid:105) then w
else conc[w •Head(t), Tail(t)]
in conc[v, s]
TLA+ does not permit the general construct {e |P}, instead having two more restricted
set-forming operators.
Str(P) =∆ {Bottom ∗∗s : s ∈ Seq(P)}
Our algorithms use a value none that is not a c-struct and extend the relation (cid:118) to the
element none so that none (cid:118) none, none (cid:54)(cid:118) v, and v (cid:54)(cid:118) none for any c-struct v. It is
simpler to define the extended (cid:118) relation here than to extend it later.
none =∆ choose n : n ∈/ CStruct
v (cid:118) w =∆ ∨ ∧v ∈ CStruct
∧w ∈ CStruct
∧∃s ∈ Seq(Cmd) : w = v ∗∗s
∨ ∧v = none
∧w = none
44
v (cid:60) w =∆ (v (cid:118) w)∧(v (cid:54)= w)
WenowimportthedefinitionsoftheOrderRelations modulewithCStruct substitutedfor
S and (cid:118) substituted for (cid:185).
instance OrderRelations with S ← CStruct, (cid:185) ← (cid:118)
We now define compatibility of c-structs and of sets of c-structs, and the of contains,
giving them obvious operator names.
AreCompatible(v, w) =∆ ∃ub ∈ CStruct : IsUB(ub, {v, w})
IsCompatible(S) =∆ ∀v, w ∈ S : AreCompatible(v, w)
Contains(v, C) =∆ ∃s, t ∈ Seq(Cmd) : v = ((Bottom ∗∗s)•C)∗∗t
Here are the formal statements of assumptions CS1–CS4, as well as an assumption CS0
that was tacitly made but not explicitly named.
CS0 =∆ ∀v ∈ CStruct, C ∈ Cmd : v •C ∈ CStruct
CS1 =∆ CStruct = Str(Cmd)
CS2 =∆ IsPartialOrder
CS3 =∆ ∀P ∈ subset Cmd\{{}} :
∧∀v, w ∈ Str(P) :
∧v (cid:117)w ∈ Str(P)
∧IsGLB(v (cid:117)w, {v, w})
∧AreCompatible(v, w) ⇒ ∧v (cid:116)w ∈ Str(P)
∧IsLUB(v (cid:116)w, {v, w})
CS4 =∆ ∀v, w ∈ CStruct, C ∈ Cmd :
AreCompatible(v, w)∧Contains(v, C)∧Contains(w, C) ⇒
Contains(v (cid:117)w, C)
assume CS0∧CS1∧CS2∧CS3∧CS4
45
C.2 Generalized Consensus
module GeneralConsensus
Wespecifythesafetypropertiesofthegeneralconsensusproblem. Wefirstgivea“state-
machinestyle”TLA+specificationSpec. WethenassertthatSpecimpliesthethreesafety
properties Nontriviality, Stability, and Consistency.
extends CStructs
constant Learner
variables propCmd, learned
TypeInv asserts a type invariant; the assertion that TypeInv is always true is a property
of (implied by) the specification.
TypeInv =∆ ∧propCmd ⊆ Cmd
∧learned ∈ [Learner → CStruct]
Init is the initial predicate.
Init =∆ ∧propCmd = {}
∧learned = [l ∈ Learner (cid:55)→ Bottom]
We now define the two actions of proposing a command and learning a c-struct. The
Learn action sets learned[l] to the lub of its present value and a proposed c-struct.
Propose =∆ ∃C ∈ Cmd\propCmd : ∧propCmd(cid:48) = propCmd ∪{C}
∧unchanged learned
Learn(l) =∆ ∧∃v ∈ Str(propCmd) :
∧∀r ∈ Learner : AreCompatible(v, learned[r])
∧learned(cid:48) = [learned except ![l] = learned[l](cid:116)v]
∧unchanged propCmd
Next is the complete next-state action; Spec is the complete specification.
Next =∆ Propose ∨∃l ∈ Learner : Learn(l)
Spec =∆ Init ∧(cid:50)[Next]
(cid:104)propCmd,learned(cid:105)
We now define the three safety properties as temporal formulas and assert that they and
the type-correctness invariant are properties of the specification.
Nontriviality =∆ ∀l ∈ Learner : (cid:50)(learned[l] ∈ Str(propCmd))
Stability =∆ ∀l ∈ Learner, v ∈ CStruct :
(cid:50)((learned[l] = v) ⇒ (cid:50)(v (cid:118) learned[l]))
Consistency =∆ ∀l1, l2 ∈ Learner :
(cid:50)AreCompatible(learned[l1], learned[l2])
theorem Spec ⇒ ((cid:50)TypeInv)∧Nontriviality ∧Stability ∧Consistency
46
C.3 The Constant Operators of Paxos
module PaxosConstants
This module defines the data structures for the abstract algoritm, introduced in Sections
5.1 and 5.2.
extends CStructs, FiniteSets
Module FiniteSets defines IsFiniteSet(S) to be true iff S is a finite set.
WeintroducetheparameterIsFast,whereIsFast(m)istrueiffm isafastballotnumber.
The ordering relation ≤ on ballot numbers is also a parameter.
constants BalNum, ≤ , IsFast( )
We assume that 0 is a balnum, and that ≤ is a total ordering of the set BalNum of
balnums. (Note: 0ispre-definedinTLA+ tohaveitsusualvalue. However,thisdoesnot
imply that BalNum contains any other usual numbers.)
assume
∧0 ∈ BalNum
∧let PO =∆ instance OrderRelations with S ← BalNum, (cid:185) ← ≤
in PO!IsTotalOrder
i < j =∆ (i ≤ j)∧(i (cid:54)= j)
IfB isasetofballotnumbersthatcontainsamaximumelement,thenMax(B)isdefined
to equal that maximum. Otherwise, its value is unspecified.
Max(B) =∆ choose i ∈ B : ∀j ∈ B : j ≤ i
constants Learner, Acceptor, Quorum( )
QuorumAssumption =∆
∧∀m ∈ BalNum : Quorum(m) ⊆ subset Acceptor
∧∀k, m ∈ BalNum :
∀Q ∈ Quorum(k), R ∈ Quorum(m) : Q ∩R (cid:54)= {}
∧∀k ∈ BalNum :
IsFast(k) ⇒ ∀m ∈ BalNum :
∀Q1, Q2 ∈ Quorum(k), R ∈ Quorum(m) :
Q1∩Q2∩R (cid:54)= {}
assume QuorumAssumption
We define BallotArray to be the set of all ballot arrays. We represent a ballot array as a
record, where we write β [m] as β.vote[a][m] and β(cid:98) as β.mbal[a].
a a
47
BallotArray =∆
{beta ∈ [vote : [Acceptor → [BalNum → CStruct ∪{none}]],
mbal : [Acceptor → BalNum]] :
∀a ∈ Acceptor :
∧beta.vote[a][0] (cid:54)= none
∧IsFiniteSet({m ∈ BalNum : beta.vote[a][m] (cid:54)= none})
∧∀m ∈ BalNum : (beta.mbal[a] < m) ⇒ (beta.vote[a][m] = none)}
Wenowformalizethedefinitionsofchosenat,safeat,etc. WetranslatetheEnglishterms
into obvious operator names. For example, IsChosenAt(v, mβ) is define to be true iff v
is chosen at m in β, assuming that v is a c-struct, m a balnum, and β a ballot array.
(Wedon’tcarewhatIsChosenAt(v, mβ)meansforothervaluesofv,m,andβ.) Wealso
assert the three propositions as theorems.
IsChosenAt(v, m, beta) =∆
∃Q ∈ Quorum(m) :
∀a ∈ Q : (v (cid:118) beta.vote[a][m])
IsChosenIn(v, beta) =∆ ∃m ∈ BalNum : IsChosenAt(v, m, beta)
IsChoosableAt(v, m, beta) =∆
∃Q ∈ Quorum(m) :
∀a ∈ Q : (m < beta.mbal[a]) ⇒ (v (cid:118) beta.vote[a][m])
IsSafeAt(v, m, beta) =∆
∀k ∈ BalNum :
(k < m) ⇒ ∀w ∈ CStruct : IsChoosableAt(w, k, beta) ⇒ (w (cid:118) v)
IsSafe(beta) =∆
∀a ∈ Acceptor, k ∈ BalNum :
(beta.vote[a][k] (cid:54)= none) ⇒ IsSafeAt(beta.vote[a][k], k, beta)
theorem Proposition 1
∀beta ∈ BallotArray :
IsSafe(beta) ⇒ IsCompatible({v ∈ CStruct : IsChosenIn(v, beta)})
ProvedSafe(Q, m, beta) =∆
let k =∆ Max({i ∈ BalNum :
(i < m)∧(∃a ∈ Q : beta.vote[a][i] (cid:54)= none)})
RS =∆ {R ∈ Quorum(k) : ∀a ∈ Q ∩R : beta.vote[a][k] (cid:54)= none}
g(R) =∆ GLB({beta.vote[a][k] : a ∈ Q ∩R})
G =∆ {g(R) : R ∈ RS}
in if RS = {} then {beta.vote[a][k] :
a ∈ {b ∈ Q : beta.vote[b][k] (cid:54)= none}}
48
else if IsCompatible(G) then {LUB(G)}
else {}
theorem Proposition 2
∀m ∈ BalNum\{0}, beta ∈ BallotArray :
∀Q ∈ Quorum(m) :
∧IsSafe(beta)
∧∀a ∈ Q : m ≤ beta.mbal[a]
⇒ ∀v ∈ ProvedSafe(Q, m, beta) : IsSafeAt(v, m, beta)
IsConservative(beta) =∆
∀m ∈ BalNum, a, b ∈ Acceptor :
∧¬IsFast(m)
∧beta.vote[a][m] (cid:54)= none
∧beta.vote[b][m] (cid:54)= none
⇒ AreCompatible(beta.vote[a][m], beta.vote[b][m])
theorem Proposition 3
∀beta ∈ BallotArray :
IsConservative(beta) ⇒
∀m ∈ BalNum\{0} :
∀Q ∈ Quorum(m) : ProvedSafe(Q, m, beta) (cid:54)= {}
C.4 The Abstract Algorithm
module AbstractGPaxos
extends PaxosConstants
variables propCmd, learned, bA, minTried, maxTried
We begin with the type invariant and the initial predicate.
TypeInv =∆ ∧propCmd ⊆ Cmd
∧learned ∈ [Learner → CStruct]
∧bA ∈ BallotArray
∧minTried ∈ [BalNum → CStruct ∪{none}]
∧maxTried ∈ [BalNum → CStruct ∪{none}]
Init =∆ ∧propCmd = {}
∧learned = [l ∈ Learner (cid:55)→ Bottom]
∧bA = [vote (cid:55)→ [a ∈ Acceptor (cid:55)→
[m ∈ BalNum (cid:55)→
49
if m = 0 then Bottom else none]],
mbal (cid:55)→ [a ∈ Acceptor (cid:55)→ 0]]
∧maxTried = [m ∈ BalNum (cid:55)→
if m = 0 then Bottom else none]
∧minTried = maxTried
We next define the three invariants of the abstract algorithm.
TriedInvariant =∆
∀m ∈ BalNum : ∧minTried[m] (cid:118) maxTried[m]
∧(minTried[m] (cid:54)= none) ⇒
∧IsSafeAt(minTried[m], m, bA)
∧maxTried[m] ∈ Str(propCmd)
bAInvariant =∆
∀a ∈ Acceptor, m ∈ BalNum :
(bA.vote[a][m] (cid:54)= none) ⇒
∧minTried[m] (cid:118) bA.vote[a][m]
∧¬IsFast(m) ⇒ (bA.vote[a][m] (cid:118) maxTried[m])
∧IsFast(m) ⇒ (bA.vote[a][m] ∈ Str(propCmd))
learnedInvariant =∆
∀l ∈ Learner : ∧learned[l] ∈ Str(propCmd)
∧∃S ∈ subset CStruct :
∧IsFiniteSet(S)
∧∀v ∈ S : IsChosenIn(v, bA)
∧learned[l] = LUB(S)
We now define the actions.
Propose(C) =∆
∧C ∈/ propCmd
∧propCmd(cid:48) = propCmd ∪{C}
∧unchanged (cid:104)learned, bA, minTried, maxTried(cid:105)
JoinBallot(a, m) =∆
∧bA.mbal[a] < m
∧bA(cid:48) = [bA except !.mbal[a] = m]
∧unchanged (cid:104)propCmd, learned, minTried, maxTried(cid:105)
StartBallot(m, Q) =∆
∧maxTried[m] = none
∧∀a ∈ Q : m ≤ bA.mbal[a]
50
∧∃w ∈ ProvedSafe(Q, m, bA), s ∈ Seq(propCmd) :
∧minTried(cid:48) = [minTried except ![m] = w ∗∗s]
∧maxTried(cid:48) = [maxTried except ![m] = w ∗∗s]
∧unchanged (cid:104)propCmd, learned, bA(cid:105)
Suggest(m, C) =∆
∧C ∈ propCmd
∧maxTried[m] (cid:54)= none
∧maxTried(cid:48) = [maxTried except ![m] = maxTried[m]•C]
∧unchanged (cid:104)propCmd, learned, bA, minTried(cid:105)
ClassicVote(a, v) =∆
∧maxTried[bA.mbal[a]] (cid:54)= none
∧minTried[bA.mbal[a]] (cid:118) v
∧v (cid:118) maxTried[bA.mbal[a]]
∧ ∨bA.vote[a][bA.mbal[a]] = none
∨bA.vote[a][bA.mbal[a]] (cid:60) v
∧bA(cid:48) = [bA except !.vote[a][bA.mbal[a]] = v]
∧unchanged (cid:104)propCmd, learned, minTried, maxTried(cid:105)
FastVote(a, C) =∆
∧C ∈ propCmd
∧IsFast(bA.mbal[a])
∧bA.vote[a][bA.mbal[a]] (cid:54)= none
∧bA(cid:48) = [bA except !.vote[a][bA.mbal[a]] = bA.vote[a][bA.mbal[a]]•C]
∧unchanged (cid:104)propCmd, learned, minTried, maxTried(cid:105)
AbstractLearn(l, v) =∆
∧IsChosenIn(v, bA)
∧learned(cid:48) = [learned except ![l] = learned[l](cid:116)v]
∧unchanged (cid:104)propCmd, bA, minTried, maxTried(cid:105)
We combine the actions into the next-state relation and define Spec to be the complete
specification.
Next =∆ ∨∃C ∈ Cmd : ∨Propose(C)
∨∃m ∈ BalNum : Suggest(m, C)
∨∃a ∈ Acceptor : FastVote(a, C)
∨∃m ∈ BalNum : ∨∃a ∈ Acceptor : JoinBallot(a, m)
∨∃Q ∈ Quorum(m) : StartBallot(m, Q)
∨∃v ∈ CStruct : ∨∃a ∈ Acceptor : ClassicVote(a, v)
∨∃l ∈ Learner : AbstractLearn(l, v)
51
Spec =∆ Init ∧(cid:50)[Next]
(cid:104)propCmd,learned,bA,minTried,maxTried(cid:105)
The following theorem asserts the invariance of our invariants.
theorem
Spec ⇒ (cid:50)(TypeInv ∧TriedInvariant ∧bAInvariant ∧learnedInvariant)
ThefollowingassertsthatourspecificationSpecimplies/implementsthespecificationSpec
from module GeneralConsensus.
GC =∆ instance GeneralConsensus
theorem Spec ⇒ GC!Spec
C.5 The Distributed Abstract Algorithm
module DistAbstractGPaxos
We import all the declarations and definitions from module AbstractGPaxos.
extends AbstractGPaxos
WedefineMsg tobethesetofallpossiblemessages. Forthesakeofclarityandavoiding
errors,weletmessagesberecordsinsteadoftuples. Forexample,themessage(cid:104)“2a”, m, v(cid:105)
in the text becomes a record with type field “2a”, bal field m, and val field v.
Msg =∆ [type : {“propose”}, cmd : Cmd]
∪ [type : {“1a”}, bal : BalNum]
∪ [type : {“1b”}, bal : BalNum, acc : Acceptor,
vote : [BalNum → CStruct ∪{none}]]
∪ [type : {“2a”}, bal : BalNum, val : CStruct]
∪ [type : {“2b”}, bal : BalNum, acc : Acceptor, val : CStruct]
We describe the state of the message-passing system by the value of the variable msgs.
Becausewearespecifyingonlysafetyandnotliveness,wedonotneedexplicitlytomodel
message loss. Since an action is never required to happen, the loss of a message during
an execution of the system is modeled by the receive action for that message never being
executed in the corresponding behavior. We can also model the possibility of receiving
the same message multiple times by never deleting a message when it is received. So, we
use a simple model of the message passing in which a message is sent by adding it to the
set msgs, and a process can at any time receive any message that is an element of msgs.
variables msgs
We begin with the type invariant and the initial predicate. We prefix with a D standard
names like Init, which are already defined in the AbstractGPaxos
DTypeInv =∆ ∧TypeInv
∧msgs ⊆ Msg
DInit =∆ ∧Init
52
∧msgs = {}
We now define the actions. When an action very directly implements an action of
the abstract non-distributed algorithm, we can re-use the action definition from module
AbstractGPaxos.
SendProposal(C) =∆
∧propCmd(cid:48) = propCmd ∪{C}
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “propose”, cmd (cid:55)→ C]}
∧unchanged (cid:104)learned, bA, minTried, maxTried(cid:105)
Phase1a(m) =∆
∧maxTried[m] = none
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “1a”, bal (cid:55)→ m]}
∧unchanged (cid:104)propCmd, learned, bA, minTried, maxTried(cid:105)
Phase1b(a, m) =∆
∧[type (cid:55)→ “1a”, bal (cid:55)→ m] ∈ msgs
∧JoinBallot(a, m)
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “1b”, bal (cid:55)→ m, acc (cid:55)→ a,
vote (cid:55)→ bA.vote[a]]}
Phase2Start(m, v) =∆
∧maxTried[m] = none
∧∃Q ∈ Quorum(m) :
∧∀a ∈ Q : ∃msg ∈ msgs : ∧msg.type = “1b”
∧msg.bal = m
∧msg.acc = a
∧let beta =∆
choose b ∈ BallotArray :
∀a ∈ Q : ∧b.mbal[a] = m
∧∃msg ∈ msgs : ∧msg.type = “1b”
∧msg.bal = m
∧msg.acc = a
∧b.vote[a] = msg.vote
pCmd =∆
{msg.cmd : msg ∈ {mg ∈ msgs : mg.type = “propose”}}
in ∃w ∈ ProvedSafe(Q, m, beta), s ∈ Seq(pCmd) :
∧minTried(cid:48) = [minTried except ![m] = w ∗∗s]
∧maxTried(cid:48) = minTried(cid:48)
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “2a”, bal (cid:55)→ m, val (cid:55)→ w ∗∗s]}
∧unchanged (cid:104)propCmd, learned, bA(cid:105)
53
Phase2aClassic(m, C) =∆
∧[type (cid:55)→ “propose”, cmd (cid:55)→ C] ∈ msgs
∧maxTried[m] (cid:54)= none
∧maxTried(cid:48) = [maxTried except ![m] = maxTried[m]•C]
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “2a”, bal (cid:55)→ m, val (cid:55)→ maxTried(cid:48)[m]]}
∧unchanged (cid:104)propCmd, learned, bA, minTried(cid:105)
Phase2bClassic(a, m, v) =∆
∧[type (cid:55)→ “2a”, bal (cid:55)→ m, val (cid:55)→ v] ∈ msgs
∧bA.mbal[a] = m
∧ ∨bA.vote[a][bA.mbal[a]] = none
∨bA.vote[a][bA.mbal[a]] (cid:60) v
∧bA(cid:48) = [bA except !.vote[a][bA.mbal[a]] = v]
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “2b”, bal (cid:55)→ m, acc (cid:55)→ a, val (cid:55)→ v]}
∧unchanged (cid:104)propCmd, learned, minTried, maxTried(cid:105)
Phase2bFast(a, m, C) =∆
∧[type (cid:55)→ “propose”, cmd (cid:55)→ C] ∈ msgs
∧bA.mbal[a] = m
∧bA.vote[a][m] (cid:54)= none
∧bA(cid:48) = [bA except !.vote[a][m] = bA.vote[a][m]•C]
∧msgs(cid:48) = msgs ∪
{[type (cid:55)→ “2b”, bal (cid:55)→ m, acc (cid:55)→ a, val (cid:55)→ bA(cid:48).vote[a][m]]}
∧unchanged (cid:104)propCmd, learned, minTried, maxTried(cid:105)
Learn(l, v) =∆
∧ ∃m ∈ BalNum :
∃Q ∈ Quorum(m) :
∀a ∈ Q : ∃msg ∈ msgs : ∧msg.type = “2b”
∧msg.bal = m
∧msg.acc = a
∧v (cid:118) msg.val
∧ learned(cid:48) = [learned except ![l] = learned[l](cid:116)v]
∧ unchanged (cid:104)propCmd, bA, minTried, maxTried, msgs(cid:105)
DNext and DSpec are the complete next-state relation and specification.
DNext =∆ ∨∃C ∈ Cmd : SendProposal(C) The proposers’ actions.
∨∃m ∈ BalNum : The leaders’ actions.
∨Phase1a(m)
∨∃v ∈ CStruct : Phase2Start(m, v)
∨∃C ∈ Cmd : Phase2aClassic(m, C)
54
∨∃a ∈ Acceptor : The acceptors’ actions.
∨Phase1b(a, m)
∨∃v ∈ CStruct : Phase2bClassic(a, m, v)
∨∃C ∈ Cmd : Phase2bFast(a, m, C)
∨∃l ∈ Learner : The learners’ actions.
∃v ∈ CStruct : Learn(l, v)
DSpec =∆ DInit ∧(cid:50)[DNext]
(cid:104)propCmd,learned,bA,minTried,maxTried,msgs(cid:105)
The following theorems assert that DTypeInv is an invariant and that DSpec implements
the specification of generalized consensus, formula Spec of module GeneralConsensus.
theorem DSpec ⇒ (cid:50)DTypeInv
theorem DSpec ⇒ GC!Spec
C.6 The Generalized Paxos Consensus Algorithm
module GeneralizedPaxos
extends PaxosConstants
We introduce a set Leader of leaders, and let LeaderOf(m) be the leader of ballot num-
ber m.
constant Leader, LeaderOf( )
assume ∀m ∈ BalNum : LeaderOf(m) ∈ Leader
ThesetMsg ofallpossiblemessagesisthesameasforthedistributedabstractalgorithm
of module DistAbstractGPaxos.
Msg =∆ [type : {“propose”}, cmd : Cmd]
∪ [type : {“1a”}, bal : BalNum]
∪ [type : {“1b”}, bal : BalNum, acc : Acceptor,
vbal : BalNum, vote : CStruct ∪{none}]
∪ [type : {“2a”}, bal : BalNum, val : CStruct]
∪ [type : {“2b”}, bal : BalNum, acc : Acceptor, val : CStruct]
We define NotABalNum to be an arbitrary value that is not a balnum.
NotABalNum =∆ choose m : m ∈/ BalNum
55
The variables propCmd, learned, and msgs are the same as in the distributed abstract
algorithm. We replace the abstract algorithm’s variable bA with the variables mbal, bal,
and val. The value of curLdrBal[ldr] is the ballot that leader ldr is currently leading or
has most recently led. Initially, its value is initially curLdrBal[ldr] equals NotABalNum
for all leaders except the leader of ballot 0, which is initially in progress. We replace
the variable maxTried of the abstract algorithm with maxLdrTried, where the value of
maxLdrTried[ldr] corresponds to the value of maxTried[curLdrBal[ldr]] in the abstract
algorithm.
variables propCmd, learned, msgs, maxLdrTried, curLdrBal, mbal, bal, val
We begin with the type invariant and the initial predicate.
TypeInv =∆ ∧propCmd ⊆ Cmd
∧learned ∈ [Learner → CStruct]
∧msgs ⊆ Msg
∧maxLdrTried ∈ [Leader → CStruct ∪{none}]
∧curLdrBal ∈ [Leader → BalNum ∪{NotABalNum}]
∧mbal ∈ [Acceptor → BalNum]
∧bal ∈ [Acceptor → BalNum]
∧val ∈ [Acceptor → CStruct]
Init =∆ ∧propCmd = {}
∧learned = [l ∈ Learner (cid:55)→ Bottom]
∧msgs = {}
∧maxLdrTried = [ldr ∈ Leader (cid:55)→ if ldr = LeaderOf(0)
then Bottom else none]
∧curLdrBal = [ldr ∈ Leader (cid:55)→ if ldr = LeaderOf(0)
then 0 else NotABalNum]
∧mbal = [a ∈ Acceptor (cid:55)→ 0]
∧bal = [a ∈ Acceptor (cid:55)→ 0]
∧val = [a ∈ Acceptor (cid:55)→ Bottom]
We now define the actions.
SendProposal(C) =∆
∧propCmd(cid:48) = propCmd ∪{C}
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “propose”, cmd (cid:55)→ C]}
∧unchanged (cid:104)learned, maxLdrTried, curLdrBal, mbal, bal, val(cid:105)
Phase1a(ldr) =∆
∧∃m ∈ BalNum :
∧ ∨curLdrBal[ldr] = NotABalNum
∨curLdrBal[ldr] < m
∧LeaderOf(m) = ldr
56
∧curLdrBal(cid:48) = [curLdrBal except ![ldr] = m]
∧maxLdrTried(cid:48) = [maxLdrTried except ![ldr] = none]
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “1a”, bal (cid:55)→ m]}
∧unchanged (cid:104)propCmd, learned, mbal, bal, val(cid:105)
Phase1b(a, m) =∆
∧[type (cid:55)→ “1a”, bal (cid:55)→ m] ∈ msgs
∧mbal[a] < m
∧mbal(cid:48) = [mbal except ![a] = m]
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “1b”, bal (cid:55)→ m, acc (cid:55)→ a,
vbal (cid:55)→ bal[a], vote (cid:55)→ val[a]]}
∧unchanged (cid:104)propCmd, learned, maxLdrTried, curLdrBal, bal, val(cid:105)
Phase2Start(ldr, v) =∆
∧curLdrBal[ldr] (cid:54)= NotABalNum
∧maxLdrTried[ldr] = none
∧∃Q ∈ Quorum(curLdrBal[ldr]) :
∧∀a ∈ Q : ∃msg ∈ msgs : ∧msg.type = “1b”
∧msg.bal = curLdrBal[ldr]
∧msg.acc = a
∧let WedefinePrSafe soitequalsthevalueofProvedSafe(Q,m,beta)where
computed in the corresponding action of the distributed abstract algo-
rithm. To help understand this correspondence, see the definition of
ProvedSafe in module PaxosConstants.
1bMsg(a) =∆
For an acceptor a in Q, this is the “1b” message sent by a for ballot
number curLdrBal[ldr]. There can be only one such message.
choose msg ∈ msgs : ∧msg.type = “1b”
∧msg.bal = curLdrBal[ldr]
∧msg.acc = a
k =∆ Max({1bMsg(a).vbal : a ∈ Q})
RS =∆ {R ∈ Quorum(k) : ∀a ∈ Q ∩R : 1bMsg(a).vbal = k}
g(R) =∆ GLB({1bMsg(a).vote : a ∈ Q ∩R})
G =∆ {g(R) : R ∈ RS}
PrSafe =∆
When the action is enabled, the set G will always be compatible.
if RS = {} then {1bMsg(a).vote :
a ∈ {b ∈ Q : 1bMsg(b).vbal = k}}
else {LUB(G)}
pCmd =∆ {msg.cmd : msg ∈ {mg ∈ msgs : mg.type = “propose”}}
in ∧∃w ∈ PrSafe, s ∈ Seq(pCmd) :
57
∧maxLdrTried(cid:48) = [maxLdrTried except ![ldr] = w ∗∗s]
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “2a”, bal (cid:55)→ curLdrBal[ldr],
val (cid:55)→ w ∗∗s]}
∧unchanged (cid:104)propCmd, learned, curLdrBal, mbal, bal, val(cid:105)
Phase2aClassic(ldr, C) =∆
∧curLdrBal[ldr] (cid:54)= NotABalNum
∧[type (cid:55)→ “propose”, cmd (cid:55)→ C] ∈ msgs
∧maxLdrTried[ldr] (cid:54)= none
∧maxLdrTried(cid:48) = [maxLdrTried except ![ldr] = maxLdrTried[ldr]•C]
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “2a”, bal (cid:55)→ curLdrBal[ldr],
val (cid:55)→ maxLdrTried(cid:48)[ldr]]}
∧unchanged (cid:104)propCmd, learned, curLdrBal, mbal, bal, val(cid:105)
Phase2bClassic(a, v) =∆
∧[type (cid:55)→ “2a”, bal (cid:55)→ mbal[a], val (cid:55)→ v] ∈ msgs
∧ ∨bal[a] < mbal[a]
∨val[a] (cid:60) v
∧bal(cid:48) = [bal except ![a] = mbal[a]]
∧val(cid:48) = [val except ![a] = v]
∧msgs(cid:48) = msgs ∪{[type (cid:55)→ “2b”, bal (cid:55)→ mbal[a], acc (cid:55)→ a, val (cid:55)→ v]}
∧unchanged (cid:104)propCmd, learned, maxLdrTried, curLdrBal, mbal(cid:105)
Phase2bFast(a, C) =∆
∧[type (cid:55)→ “propose”, cmd (cid:55)→ C] ∈ msgs
∧bal[a] = mbal[a]
∧val(cid:48) = [val except ![a] = val[a]•C]
∧msgs(cid:48) = msgs ∪
{[type (cid:55)→ “2b”, bal (cid:55)→ mbal[a], acc (cid:55)→ a, val (cid:55)→ val(cid:48)[a]]}
∧unchanged (cid:104)propCmd, learned, maxLdrTried, curLdrBal, mbal, bal(cid:105)
Learn(l, v) =∆
∧ ∃m ∈ BalNum :
∃Q ∈ Quorum(m) :
∀a ∈ Q : ∃msg ∈ msgs : ∧msg.type = “2b”
∧msg.bal = m
∧msg.acc = a
∧v (cid:118) msg.val
∧ learned(cid:48) = [learned except ![l] = learned[l](cid:116)v]
∧ unchanged (cid:104)propCmd, msgs, maxLdrTried, curLdrBal, mbal, bal, val(cid:105)
Next and Spec are the complete next-state relation and specification.
58
Next =∆ ∨∃C ∈ Cmd : SendProposal(C) The proposers’ actions.
∨∃ldr ∈ Leader : The leaders’ actions.
∨Phase1a(ldr)
∨∃v ∈ CStruct : Phase2Start(ldr, v)
∨∃C ∈ Cmd : Phase2aClassic(ldr, C)
∨∃a ∈ Acceptor : The acceptors’ actions.
∨∃v ∈ CStruct : Phase2bClassic(a, v)
∨∃m ∈ BalNum : Phase1b(a, m)
∨∃C ∈ Cmd : Phase2bFast(a, C)
∨∃l ∈ Learner : The learners’ actions.
∃v ∈ CStruct : Learn(l, v)
Spec =∆ Init ∧(cid:50)[Next]
(cid:104)propCmd,learned,msgs,maxLdrTried,curLdrBal,mbal,bal,val(cid:105)
ThefollowingtheoremsassertthatTypeInv isaninvariantandthatSpec implementsthe
specification of generalized consensus, formula Spec of module GeneralConsensus.
theorem Spec ⇒ (cid:50)TypeInv
GC =∆ instance GeneralConsensus
theorem Spec ⇒ GC!Spec
59